[
    {
        "id": 1577,
        "title": "Maximum Score",
        "problem_statement": "```html\r\n<h1>Maximum Score</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>An interviewer at HackerRank recently came up with an interesting problem for the candidates.</p>\r\n<p>Given an array <code>arr</code> of <code>n</code> integers, and an integer <code>k</code>, perform <code>k</code> operations on the array. Start with a score of 0.</p>\r\n<p>In one operation:</p>\r\n<ul>\r\n    <li>Choose any element.</li>\r\n    <li>Add its value to the score.</li>\r\n    <li>Replace the element with the integer ceiling of one-third of its value.</li>\r\n</ul>\r\n<p>For example, if the chosen element is 10, then 10 is added to the score, and 10 is replaced by <code>ceil(10 / 3) = 4</code>.</p>\r\n<p>Find the maximum possible score after <code>k</code> operations.</p>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input: n = 5, arr = [20, 4, 3, 1, 9], k = 4\r\nOutput: 40</code></pre>\r\n<p><strong>Explanation:</strong> One of the optimal ways to perform the operations is as follows:</p>\r\n<ol>\r\n    <li>Choose 20, score = 20, <code>ceil(20/3) = 7</code>. Replace 20 with 7 and <code>arr = [7, 4, 3, 1, 9]</code>.</li>\r\n    <li>Choose 7, score = 20 + 7 = 27, <code>ceil(7/3) = 3</code>. Replace 7 with 3 and <code>arr = [3, 4, 3, 1, 9]</code>.</li>\r\n    <li>Choose 4, score = 27 + 4 = 31, <code>ceil(4/3) = 2</code>. Replace 4 with 2 and <code>arr = [3, 2, 3, 1, 9]</code>.</li>\r\n    <li>Choose 9, score = 31 + 9 = 40, <code>ceil(9/3) = 3</code>. Replace 9 with 3 and <code>arr = [3, 2, 3, 1, 3]</code>.</li>\r\n</ol>\r\n<p>The final score after 4 operations is 40.</p>\r\n\r\n<h3>Example 2:</h3>\r\n<pre><code class='language-text'>Input: n = 4, arr = [4, 5, 18, 1], k = 3\r\nOutput: 29</code></pre>\r\n<p><strong>Explanation:</strong> Given <code>n = 4, arr = [4, 5, 18, 1], k = 3</code>.</p>\r\n<p>One of the optimal ways to perform the operations is as follows:</p>\r\n<ol>\r\n    <li>Choose 5, score = 5 and <code>arr = [4, 2, 18, 1]</code>.</li>\r\n    <li>Choose 18, score = 5 + 18 = 23 and <code>arr = [4, 2, 6, 1]</code>.</li>\r\n    <li>Choose 6, score = 23 + 6 = 29 and <code>arr = [4, 2, 2, 1]</code>.</li>\r\n</ol>\r\n\r\n<h3>Example 3:</h3>\r\n<pre><code class='language-text'>Input: n = 3, arr = [3, 1, 1], k = 2\r\nOutput: 2</code></pre>\r\n<p><strong>Explanation:</strong> Given <code>n = 3, arr = [3, 1, 1], k = 2</code>.</p>\r\n<p>One of the optimal ways to perform the operations is as follows:</p>\r\n<ol>\r\n    <li>Choose 1 (from <code>arr</code>), score = 1 and <code>arr = [3, 1, 1]</code>.</li>\r\n    <li>Choose 1 (from <code>arr</code>), score = 1 + 1 = 2 and <code>arr = [3, 1, 1]</code>.</li>\r\n</ol>\r\n\r\n<h2>Function Description</h2>\r\n<p>Complete the function <code>getMaximumScore</code> in the editor below.</p>\r\n<pre><code class='language-javascript'>long getMaximumScore(vector&lt;int&gt; arr, int k) {\r\n    // Function body\r\n}</code></pre>\r\n<p>The function accepts the following parameters:</p>\r\n<ul>\r\n    <li><code>int arr[n]</code>: the initial array</li>\r\n    <li><code>int k</code>: the number of operations to be performed</li>\r\n</ul>\r\n<p><strong>Returns:</strong></p>\r\n<ul>\r\n    <li><code>long_int</code>: the maximum possible score after <code>k</code> operations</li>\r\n</ul>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>1 &lt;= n &lt;= 10^5</code></li>\r\n    <li><code>1 &lt;= arr[i] &lt;= 10^9</code></li>\r\n    <li><code>1 &lt;= k &lt;= 10^5</code></li>\r\n</ul>\r\n```",
        "google_doc_link": null,
        "solution_code": null,
        "company_name": "HPE_3oct",
        "company_id": 555
    },
    {
        "id": 1578,
        "title": "Tree Value",
        "problem_statement": "<h1>Tree Value</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>Given an unweighted undirected tree with <code>g_nodes</code> nodes rooted at 0, each node has a value specified in array <code>arr</code>. There is also a parameter, <code>k</code>.</p>\r\n<p>The tree is represented with <code>g_nodes</code> nodes numbered from 0 to <code>g_nodes - 1</code> and <code>g_edges = g_nodes - 1</code> edges. The <code>i</code>th edge connects the nodes numbered <code>g_from[i]</code> to <code>g_to[i]</code>. Each node <code>u</code> has an associated value represented by <code>arr[u]</code>.</p>\r\n<p>Collect the values at the nodes using one of two methods:</p>\r\n<ol>\r\n    <li>Collect <code>arr[u] - k</code> points.</li>\r\n    <li>Collect <code>floor(arr[u]/2)</code> points. If this method is chosen, all values of node <code>j</code> in this node's subtree are changed to <code>floor(arr[j]/2)</code> as well.</li>\r\n</ol>\r\n<p>You can only collect the value at a node if its parent's value has been collected before (except the root). You have to maximize the total points collected.</p>\r\n<p><strong>Note:</strong> It is possible that the accumulated value may be negative at some point.</p>\r\n\r\n<p>Complete the function <code>treePoints</code> in the editor with the following parameters:</p>\r\n<pre><code class='language-javascript'>long treePoints(int g_nodes, vector&lt;int&gt; g_from, vector&lt;int&gt; g_to, vector&lt;int&gt; arr, int k)</code></pre>\r\n<ul>\r\n    <li><code>int g_nodes</code>: the number of nodes in the graph</li>\r\n    <li><code>vector&lt;int&gt; g_from</code>: <code>g_from[i]</code> is one end of each edge</li>\r\n    <li><code>vector&lt;int&gt; g_to</code>: <code>g_to[i]</code> is the other end of each edge</li>\r\n    <li><code>vector&lt;int&gt; arr</code>: <code>arr[i]</code> is the value at the nodes</li>\r\n    <li><code>int k</code>: the cost to collect a full value</li>\r\n</ul>\r\n<p><strong>Returns</strong></p>\r\n<ul>\r\n    <li><code>long</code>: the maximum sum of values that can be collected</li>\r\n</ul>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input:\r\ng_nodes = 3, g_edges = 2\r\ng_from = [0, 0], g_to = [1, 2]\r\narr = [1, 2, 3]\r\nk = 2\r\nOutput: 1</code></pre>\r\n<p><strong>Explanation:</strong> One optimal solution is shown.</p>\r\n<ul>\r\n    <li>Collect the value at node 0 reduced by k. The current balance is 0 + 1 - 2 = -1.</li>\r\n    <li>Collect the value at node 1 by using the second operation. The current balance is -1 + floor(2/2) = 0.</li>\r\n    <li>Collect the value at node 2 by using the second operation. The current balance is 0 + floor(3/2) = 1.</li>\r\n</ul>\r\n\r\n<h3>Example 2:</h3>\r\n<pre><code class='language-text'>Input:\r\ng_nodes = 4, g_edges = 3\r\ng_from = [0, 1, 2], g_to = [1, 2, 3]\r\narr = [10, 10, 3, 3]\r\nk = 5\r\nOutput: 13</code></pre>\r\n<p><strong>Explanation:</strong> One optimal strategy is as follows:</p>\r\n<ul>\r\n    <li>Take the value at node 0 reduced by k. The current balance is 0 + 15 - 7 = 8.</li>\r\n    <li>Take the value at node 1 using the second operation. The current balance is 8 + floor(10/2) = 13.</li>\r\n</ul>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>1 &lt;= g_nodes &lt;= 10^5</code></li>\r\n    <li><code>g_edges = g_nodes - 1</code></li>\r\n    <li><code>0 &lt;= g_from[i], g_to[i] &lt; g_nodes</code></li>\r\n    <li><code>1 &lt;= arr[i] &lt;= 10^9</code></li>\r\n    <li><code>1 &lt;= k &lt;= 10^9</code></li>\r\n</ul>",
        "google_doc_link": null,
        "solution_code": null,
        "company_name": "HPE_3oct",
        "company_id": 555
    },
    {
        "id": 1579,
        "title": "No Ancestor Subset",
        "problem_statement": "<h1>No Ancestor Subset</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>Given a tree with <code>tree_nodes</code> nodes, where each node <code>i</code> has an associated weight <code>weight[i]</code> (1-based indexing). The tree is rooted at node 1.</p>\r\n<p>A subset of nodes is called \"good\" if there is no pair of nodes where one node is an ancestor of the other.</p>\r\n<p>Find the maximum sum of weights from nodes that form a good subset.</p>\r\n<p><strong>Note:</strong> A node <code>u</code> is an ancestor of node <code>v</code> if it lies on the direct path from the root to node <code>v</code>.</p>\r\n\r\n<p>For example, consider the following tree structure and weights:</p>\r\n<pre><code class='language-text'>tree_nodes = 3\r\ntree_from = [1, 1]\r\ntree_to = [2, 3]\r\nweight = [2, 2, 1]</code></pre>\r\n<p>Nodes are labeled node:weight. The possible subsets are below.</p>\r\n<pre><code class='language-text'>Subset    | Is it good? | Sum of weights\r\n----------|-------------|---------------\r\n{1}       | Yes         | 2\r\n{2}       | Yes         | 2\r\n{3}       | Yes         | 1\r\n{1,2}     | No          |\r\n{1,3}     | No          |\r\n{2,3}     | Yes         | 3\r\n{1,2,3}   | No          |</code></pre>\r\n<p>The maximum sum of weights of nodes forming a good subset is 3.</p>\r\n\r\n<h2>Function Description</h2>\r\n<p>Complete the function <code>findMaximumSum</code> in the editor with the following parameters:</p>\r\n<ul>\r\n    <li><code>int tree_nodes</code>: the number of nodes</li>\r\n    <li><code>int tree_from[tree_nodes - 1]</code>: one set of endpoints of the edges</li>\r\n    <li><code>int tree_to[tree_nodes - 1]</code>: the other set of endpoints of the edges</li>\r\n    <li><code>int weight[tree_nodes]</code>: the weights of the nodes</li>\r\n</ul>\r\n\r\n<h3>Returns</h3>\r\n<p><code>long</code>: the maximum sum of nodes of a good subset</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>1 &lt;= tree_nodes &lt;= 10<sup>5</sup></code></li>\r\n    <li><code>1 &lt;= tree_from[i], tree_to[i] &lt;= tree_nodes</code></li>\r\n    <li><code>1 &lt;= weight[i] &lt;= 10<sup>9</sup></code></li>\r\n</ul>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<p><strong>Input Format for Custom Testing:</strong></p>\r\n<p>The first line contains two space-separated integers, <code>tree_nodes</code>, and <code>tree_edges</code>, the number of nodes and edges in the tree respectively. <code>tree_edges</code> will always be equal to <code>tree_nodes - 1</code>.</p>\r\n<p>Each line <code>i</code> of the next <code>tree_edges</code> subsequent lines (where <code>0 &lt;= i &lt; m</code>) contains 2 space-separated integers <code>tree_from[i]</code> and <code>tree_to[i]</code> that denote the <code>i</code>th edge of the tree.</p>\r\n<p>The next line contains an integer, <code>tree_nodes</code>, the number of nodes.</p>\r\n<p>Each line <code>i</code> of the <code>tree_nodes</code> subsequent lines (where <code>0 &lt;= i &lt; n</code>) contains an integer, <code>weight[i]</code>.</p>\r\n\r\n<pre><code class='language-text'>Input:\r\n3 2\r\n1 2\r\n1 3\r\n3\r\n2\r\n2\r\n1\r\nOutput:\r\n3</code></pre>\r\n<p><strong>Explanation:</strong>\r\nThis corresponds to <code>tree_nodes = 3</code>, <code>tree_edges = 2</code>, <code>tree_from = [1, 1]</code>, <code>tree_to = [2, 3]</code>, and <code>weight = [2, 2, 1]</code>.\r\nIt is optimal to choose {2,3} with a total weight of 3.</p>\r\n\r\n<h3>Example 2:</h3>\r\n<pre><code class='language-text'>Input:\r\n5 4\r\n1 2\r\n2 3\r\n2 4\r\n1 5\r\n5\r\n2\r\n6\r\n2\r\n3\r\n1\r\nOutput:\r\n7</code></pre>\r\n<p><strong>Explanation:</strong>\r\nThis corresponds to <code>tree_nodes = 5</code>, <code>tree_edges = 4</code>, <code>tree_from = [1, 2, 2, 1]</code>, <code>tree_to = [2, 3, 4, 5]</code>, and <code>weight = [2, 6, 2, 3, 1]</code>.\r\nIt is optimal to choose {2, 5} with a total weight of 6 + 1 = 7.\r\nNote that {1, 3, 4, 5} is not valid because 1 is an ancestor of 4, 3, and 5.</p>\r\n\r\n<p>The function signature provided is:</p>\r\n<pre><code class='language-javascript'>long findMaximumSum(int tree_nodes, vector&lt;int&gt; tree_from, vector&lt;int&gt; tree_to, vector&lt;int&gt; weight) {\r\n}</code></pre>",
        "google_doc_link": null,
        "solution_code": null,
        "company_name": "HPE_3oct",
        "company_id": 555
    }
]