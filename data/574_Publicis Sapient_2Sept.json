[
    {
        "id": 1647,
        "title": "Question 1",
        "problem_statement": "<h1>Question 1</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>Given <code>n</code> computer frames, each frame is associated with a power denoted by the array <code>power[]</code>. Where <code>power[i]</code> represents the power of the <code>i<sup>th</sup></code> frame. The current resolution starts at 1.</p>\r\n\r\n<p>Each frame can be unused or it can be utilized in one of three ways:</p>\r\n<ol>\r\n    <li>As a magnifying frame, which multiplies the current resolution by <code>power[i]</code>.</li>\r\n    <li>As a reducing frame, which divides the current resolution by <code>power[i]</code>.</li>\r\n    <li>By using both its magnifying and reducing powers together, leaving the current resolution unchanged.</li>\r\n</ol>\r\n\r\n<p>The target array contains <code>q</code> queries representing target resolutions. For each query, calculate the number of configurations required to achieve the target resolution, modulo (10<sup>9</sup>+7). It is not necessary to use all frames; each frame can be used or not used based on the configuration choice.</p>\r\n\r\n<p>Two configurations are considered different if at least one frame is used in one configuration but not in the other or if a frame is used in different ways in both configurations. For instance, a configuration using frame 1 and another that does not use frame 1 are also considered different. Similarly, using frame 1 as a magnifying frame in one configuration and as a reducing frame in another counts as different configurations.</p>\r\n\r\n<p>For example, given <code>n = 2</code>, <code>power = [1, 2]</code>, <code>q = 3</code>, <code>target = [1, 2, 4]</code>, the possible combinations and their resolutions are:</p>\r\n<pre><code class='language-text'>Frame 1 Usage     Frame 2 Usage     Resolution\r\n-------------------------------------------------\r\nUnused            Unused            1\r\nType 1 (magnify)  Unused            1*1 = 1\r\nType 2 (reduce)   Unused            1/1 = 1\r\nType 3 (both)     Unused            1\r\nUnused            Type 1            1*2 = 2\r\nUnused            Type 2            1/2 = 0.5\r\nUnused            Type 3            1\r\nType 1            Type 1            1*1*2 = 2\r\nType 1            Type 2            1*1*1/2 = 0.5\r\nType 1            Type 3            1*1*1 = 1\r\nType 2            Type 1            1/1*2 = 2\r\nType 2            Type 2            1/1*1/2 = 0.5\r\nType 2            Type 3            1/1*1 = 1\r\nType 3            Type 1            1*1*2 = 2\r\nType 3            Type 2            1*1*1/2 = 0.5\r\nType 3            Type 3            1*1*1 = 1</code></pre>\r\n\r\n<p>Complete the function <code>colNumberOfWays</code> in the editor with the following parameters:</p>\r\n<ul>\r\n    <li><code>int n</code>: the number of frames</li>\r\n    <li><code>vector&lt;int&gt; power</code>: the power values of the frames</li>\r\n    <li><code>vector&lt;long&gt; target</code>: the queries for target resolutions</li>\r\n</ul>\r\n<p><strong>Returns:</strong></p>\r\n<ul>\r\n    <li><code>vector&lt;long&gt;</code>: the answers to the queries in their order</li>\r\n</ul>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input: n = 4, power = [2,3,5,6], q = 3, target = [3,35,6]\r\nOutput: [12,0,12]</code></pre>\r\n<p><strong>Explanation:</strong></p>\r\n<ol>\r\n    <li>One way to achieve the target resolution of 3 is to use frame 1 as type 2, frame 4 as type 1, and do not use other frames. The resolution is (1/2)*6 = 3.</li>\r\n    <li>It is not possible. (for target 35)</li>\r\n    <li>One way to achieve target resolution 6 is to use frame 1 as type 1 and all other frames as type 3. Thus, the resolution is 1*6 = 6.</li>\r\n</ol>\r\n\r\n<h3>Example 2:</h3>\r\n<pre><code class='language-text'>Input: n = 3, power = [1,1,1], q = 2, target = [1,2]\r\nOutput: [64,0]</code></pre>\r\n<p><strong>Explanation:</strong> 64 configurations are possible, and the target resolution is always one. Therefore, the answer to the first query is 64, and to the second query is 0.</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>1 &lt;= n &lt;= 19</code></li>\r\n    <li><code>1 &lt;= power[i] &lt;= 6</code></li>\r\n    <li><code>1 &lt;= q &lt;= 5</code></li>\r\n    <li><code>1 &lt;= target[i] &lt;= 10<sup>15</sup></code></li>\r\n</ul>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <vector>\n#include <string>\n#include <numeric>\n\nclass Solution {\npublic:\n    std::vector<long long> colNumberOfWays(int n, std::vector<int>& power, std::vector<long long>& target) {\n        // Core logic to solve the problem goes here.\n        // The size of the returned vector should be equal to the number of queries (target.size()).\n        // For now, it returns a vector of zeros as a placeholder.\n        int q = target.size();\n        std::vector<long long> results(q, 0);\n        return results;\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    int n;\n    std::cin >> n;\n\n    std::vector<int> power(n);\n    for (int i = 0; i < n; ++i) {\n        std::cin >> power[i];\n    }\n\n    int q;\n    std::cin >> q;\n\n    std::vector<long long> target(q);\n    for (int i = 0; i < q; ++i) {\n        std::cin >> target[i];\n    }\n\n    Solution sol;\n    std::vector<long long> result = sol.colNumberOfWays(n, power, target);\n\n    for (size_t i = 0; i < result.size(); ++i) {\n        std::cout << result[i] << (i == result.size() - 1 ? \"\" : \" \");\n    }\n    std::cout << std::endl;\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "Publicis Sapient_2Sept",
        "company_id": 574
    },
    {
        "id": 1648,
        "title": "Minimum Server Connection Cost",
        "problem_statement": "<h1>Minimum Server Connection Cost</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>There are <code>n</code> servers in the network arranged in ascending order of their capacity. In the array <code>capacity</code>, the capacity of the <code>i<sup>th</sup></code> server is <code>capacity[i]</code>, where <code>0 &le; i &lt; n</code>.</p>\r\n<p>The distance between two servers, <code>i</code> and <code>j</code>, is defined as the absolute difference in their capacities: <code>|capacity[i] - capacity[j]|</code>. For each server <code>i</code>, the closest server <code>j</code> is the one with the smallest distance to <code>i</code>, and this closest server is unique.</p>\r\n<p>To manage the network, the following operations can be done to server <code>x</code>:</p>\r\n<ul>\r\n    <li>Connect to any server <code>y</code> at a cost of <code>|capacity[x] - capacity[y]|</code> units.</li>\r\n    <li>Connect to the closest server of <code>x</code> for a fixed cost of one unit.</li>\r\n</ul>\r\n<p>Given <code>m</code> queries, each defined by two integers <code>fromServer[i]</code> and <code>toServer[i]</code>, find the minimum cost required to connect from <code>fromServer[i]</code> to <code>toServer[i]</code> for each query. The connection can be either direct or routed through a server <code>z</code>.</p>\r\n<p><strong>Note:</strong> The values in the <code>capacity</code> array are distinct.</p>\r\n\r\n<h2>Function Description</h2>\r\n<p>Complete the function <code>getMinCost</code> in the editor with the following parameter(s):</p>\r\n<ul>\r\n    <li><code>int capacity[n]</code>: the capacity of each server</li>\r\n    <li><code>int fromServer[m]</code>: the starting server</li>\r\n    <li><code>int toServer[m]</code>: the ending server</li>\r\n</ul>\r\n<p><strong>Returns</strong></p>\r\n<ul>\r\n    <li><code>int[m]</code>: the minimum cost required for each query</li>\r\n</ul>\r\n\r\n<h2>Examples</h2>\r\n\r\n<h3>Illustrative Example:</h3>\r\n<p><strong>Input:</strong></p>\r\n<pre><code class='language-text'>n = 3, m = 3\r\ncapacity = [2, 7, 10]\r\nfromServer = [0, 1, 2]\r\ntoServer = [2, 2, 1]</code></pre>\r\n<p><strong>Output:</strong></p>\r\n<pre><code class='language-text'>[2, 1, 1]</code></pre>\r\n<p><strong>Explanation:</strong></p>\r\n<p>Closest servers:</p>\r\n<ul>\r\n    <li>For server 0 (capacity 2), closest is server 1 (capacity 7), distance <code>|2 - 7| = 5</code>.</li>\r\n    <li>For server 1 (capacity 7), closest is server 2 (capacity 10), distance <code>|7 - 10| = 3</code>.</li>\r\n    <li>For server 2 (capacity 10), closest is server 1 (capacity 7), distance <code>|10 - 7| = 3</code>.</li>\r\n</ul>\r\n<p>Optimal connections for each query:</p>\r\n<p><strong>Query 1:</strong> Server 0 to Server 2</p>\r\n<p>Connecting directly would cost <code>|2 - 10| = 8</code>. It is better to connect through the nearest server two times for 2 units (i.e., 0 connects to its closest server 1 for 1 unit, and 1 connects to its closest server 2 for 1 unit). Total cost: 2.</p>\r\n<p><strong>Query 2:</strong> Server 1 to Server 2</p>\r\n<p>Server 2 is closest to server 1, so a direct connection costs 1.</p>\r\n<p><strong>Query 3:</strong> Server 2 to Server 1</p>\r\n<p>Server 1 is closest to server 2, so a direct connection costs 1.</p>\r\n<p>The total costs of all queries are <code>[2, 1, 1]</code>.</p>\r\n\r\n<h3>Example 1:</h3>\r\n<p><strong>Input:</strong></p>\r\n<pre><code class='language-text'>n = 4, m = 3\r\ncapacity = [2, 3, 5, 6]\r\nfromServer = [0, 2, 0]\r\ntoServer = [3, 0, 1]</code></pre>\r\n<p><strong>Output:</strong></p>\r\n<pre><code class='language-text'>4\r\n3\r\n1</code></pre>\r\n<p><strong>Explanation:</strong></p>\r\n<p>Closest servers:</p>\r\n<ul>\r\n    <li><code>0 -> 1</code>, <code>1 -> 0</code>, because <code>|2 - 3|</code> is minimal.</li>\r\n    <li><code>2 -> 3</code>, <code>3 -> 2</code>, because <code>|5 - 6|</code> is minimal.</li>\r\n</ul>\r\n<p>Optimal connections for each query:</p>\r\n<table>\r\n<thead>\r\n<tr>\r\n<th>Starting server</th>\r\n<th>Ending server</th>\r\n<th>Path</th>\r\n<th>Cost</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr>\r\n<td>0</td>\r\n<td>3</td>\r\n<td><code>0 -> 1 -> 3</code></td>\r\n<td><code>|capacity[0]-capacity[1]| + |capacity[1]-capacity[3]| = |2-3| + |3-6| = 1 + 3 = 4</code></td>\r\n</tr>\r\n<tr>\r\n<td>2</td>\r\n<td>0</td>\r\n<td><code>2 -> 1 -> 0</code></td>\r\n<td><code>|capacity[2]-capacity[1]| + |capacity[1]-capacity[0]| = |5-3| + |3-2| = 2 + 1 = 3</code></td>\r\n</tr>\r\n<tr>\r\n<td>0</td>\r\n<td>1</td>\r\n<td><code>0 -> 1</code></td>\r\n<td><code>|capacity[0]-capacity[1]| = |2-3| = 1</code></td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n\r\n<h3>Example 2:</h3>\r\n<p><strong>Input:</strong></p>\r\n<pre><code class='language-text'>n = 5, m = 2\r\ncapacity = [2, 5, 6, 9, 11]\r\nfromServer = [2, 1]\r\ntoServer = [0, 2]</code></pre>\r\n<p><strong>Output:</strong></p>\r\n<pre><code class='language-text'>4\r\n1</code></pre>\r\n<p><strong>Explanation:</strong></p>\r\n<p>Closest servers and distances:</p>\r\n<table>\r\n<thead>\r\n<tr>\r\n<th>i</th>\r\n<th>j</th>\r\n<th>Distance</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr>\r\n<td>0</td>\r\n<td>1</td>\r\n<td><code>|2 - 5| = 3</code></td>\r\n</tr>\r\n<tr>\r\n<td>1</td>\r\n<td>2</td>\r\n<td><code>|5 - 6| = 1</code></td>\r\n</tr>\r\n<tr>\r\n<td>2</td>\r\n<td>1</td>\r\n<td><code>|6 - 5| = 1</code></td>\r\n</tr>\r\n<tr>\r\n<td>3</td>\r\n<td>4</td>\r\n<td><code>|9 - 11| = 2</code></td>\r\n</tr>\r\n<tr>\r\n<td>4</td>\r\n<td>3</td>\r\n<td><code>|11 - 9| = 2</code></td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p>Optimal connections for each query:</p>\r\n<p><strong>Query 1:</strong> Server 2 to Server 0</p>\r\n<p>Connecting directly would cost <code>|capacity[2] - capacity[0]| = |6 - 2| = 4</code>. Connecting through server 1: <code>2 -> 1 -> 0</code> (cost: <code>|capacity[2]-capacity[1]| + |capacity[1]-capacity[0]| = |6-5| + |5-2| = 1 + 3 = 4</code>).</p>\r\n<p><strong>Query 2:</strong> Server 1 to Server 2</p>\r\n<p>Server 2 is closest to server 1, so a direct connection costs 1.</p>\r\n<p>The total costs of all queries are <code>[4, 1]</code>.</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>1 &le; n, m &le; 2 * 10<sup>5</sup></code></li>\r\n    <li><code>1 &le; capacity[i] &le; 10<sup>9</sup></code></li>\r\n    <li><code>0 &le; fromServer[i], toServer[i] &lt; n</code></li>\r\n</ul>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cmath>\n\nclass Solution {\npublic:\n    std::vector<int> getMinCost(const std::vector<int>& capacity, const std::vector<int>& fromServer, const std::vector<int>& toServer) {\n        // Core logic to calculate minimum costs for each query goes here.\n        // The problem involves finding shortest paths in a graph where edge weights\n        // are determined by capacity differences or a fixed cost of 1.\n        // This might require building a graph and running a shortest path algorithm\n        // like Dijkstra's or Floyd-Warshall, or perhaps a more specialized approach\n        // leveraging the sorted nature of the capacity array.\n\n        int m = fromServer.size();\n        std::vector<int> result(m);\n        // Placeholder implementation\n        for (int i = 0; i < m; ++i) {\n            // This is just a placeholder, the actual logic will be more complex.\n            // result[i] = 0;\n        }\n        return result;\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    int n, m;\n    std::cin >> n >> m;\n\n    std::vector<int> capacity(n);\n    for (int i = 0; i < n; ++i) {\n        std::cin >> capacity[i];\n    }\n\n    std::vector<int> fromServer(m);\n    for (int i = 0; i < m; ++i) {\n        std::cin >> fromServer[i];\n    }\n\n    std::vector<int> toServer(m);\n    for (int i = 0; i < m; ++i) {\n        std::cin >> toServer[i];\n    }\n\n    Solution solution;\n    std::vector<int> result = solution.getMinCost(capacity, fromServer, toServer);\n\n    for (int i = 0; i < result.size(); ++i) {\n        std::cout << result[i] << (i == result.size() - 1 ? \"\" : \" \");\n    }\n    std::cout << std::endl;\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "Publicis Sapient_2Sept",
        "company_id": 574
    }
]