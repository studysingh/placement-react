[
    {
        "id": 1367,
        "title": "Hungry Policemen",
        "problem_statement": "<h1>Hungry Policemen</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>You are given a graph G of N nodes and M edges and each edge has some time associated with it.</p>\r\n<p>There is a policeman standing on each node except Node N.</p>\r\n<p>All of them get a report that there is thief is on Node N and the policemen start moving towards it, but all of them have been hungry for days, so they are looking to visit a few restaurants as well, before reaching the node N.</p>\r\n<p>There are K restaurants present on some nodes, and each restaurant has some satisfaction.</p>\r\n<p>Now, a policeman will only go to a restaurant if and only if the satisfaction he receives by reaching the restaurant is greater than the time he has invested in reaching there and then going to the Node N.</p>\r\n<p>Find and return the number of policemen who will have a meal at a restaurant.</p>\r\n\r\n<p><strong>Input Format:</strong></p>\r\n<p>The first argument contains an integer A, representing the number of nodes.</p>\r\n<p>The second argument of input contains a 2-d matrix of size M x 3, B, where Node B[i][0] and Node B[i][1] are bidirectionally connected with an edge that takes B[i][2] time to go through it.</p>\r\n<p>The third argument of input contains a 2-d matrix of size K x 2, C, where Node C[i][0] has a restaurant that has C[i][1] satisfaction.</p>\r\n\r\n<p><strong>Output Format:</strong></p>\r\n<p>Return an integer representing the number of people who will have a dinner at the restaurant.</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n<li>2 &lt;= N &lt;= 50000</li>\r\n<li>1 &lt;= M &lt;= 100000</li>\r\n<li>1 &lt;= K, B[i][0], B[i][1] &lt;= N</li>\r\n<li>1 &lt;= B[i][2] &lt;= 1e4</li>\r\n<li>1 &lt;= C[i][1] &lt;= 1e9</li>\r\n</ul>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input: A = 4\r\nB = [ [1, 2, 2],\r\n      [2, 4, 1],\r\n      [4, 3, 10],\r\n      [3, 1, 1] ]\r\nC = [ [1, 1] ]\r\nOutput: 2</code></pre>\r\n<p><strong>Explanation:</strong> Policemen at Node 1 and Node 3 will have a meal at node 1 without wasting any time.</p>",
        "google_doc_link": null,
        "solution_code": null,
        "company_name": "MediaNet_5sep",
        "company_id": 476
    },
    {
        "id": 1368,
        "title": "Orange Tax",
        "problem_statement": "<h1>Orange Tax</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>You live in Orange town. There are a lot of markets around that are connected with roads. These markets sell oranges at some prices. The town is not very well developed and they still use carts to transport goods from one place to the other. The roads connect two markets together and have one attribute associated with them. The attribute is the price to go from one market to the other in an empty cart. The town also has a tax factor, the tax factor is the number by which the price associated with a road needs to be multiplied, so it can go from one market to the other IF you are carrying oranges in your cart. So if a road's original price was 5 coins and tax factor of the town was 6 then in an empty cart it would take 5 coins to travel the road but if the cart contained oranges, it would cost 5 x 6 = 30 coins.</p>\r\n<p>You wonder what would be the cheapest way to buy oranges if you were initially at each market. You can either buy at the market you're at or travel to some other market, buy oranges there, and travel back to the original market.</p>\r\n<p>You are given an integer <strong>A</strong> denoting the number of total markets in orange town.<br>An integer array <strong>B</strong> denoting the price of purchasing oranges at each market.<br>A 2-D array <strong>C</strong> containing the information about the roads where each row contains three values.<br>The first two values denote the market numbers that are bi-directionally connected via a road and the third value is the price.<br>You are also given an integer <strong>D</strong>, this is the tax factor for the Orange town.</p>\r\n<p>Find and return the required array where each element is the minimum cost to buy oranges at each market such that the starting and ending point is that market.</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n<li>2 &lt;= A &lt;= 10<sup>5</sup></li>\r\n<li>B.size() == A</li>\r\n<li>1 &lt;= B[i] &lt;= 10<sup>7</sup></li>\r\n<li>1 &lt;= C.size() &lt;= 2 * 10<sup>5</sup></li>\r\n<li>1 &lt;= C[0], C[1] &lt;= A</li>\r\n<li>1 &lt;= C[2] &lt;= 10<sup>3</sup></li>\r\n<li>1 &lt;= D &lt;= 5</li>\r\n</ul>\r\n\r\n<h2>Input Format</h2>\r\n<p>The first argument is the integer <strong>A</strong>.<br>The second argument is the integer array <strong>B</strong>.<br>The third argument is the 2-D integer array <strong>C</strong>.<br>The fourth argument is the integer <strong>D</strong>.</p>\r\n\r\n<h2>Output Format</h2>\r\n<p>Return an integer array as per the given problem.</p>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input:\r\nA = 4\r\nB = [3, 1, 10, 1]\r\nC = [[2, 1, 2], [3, 1, 2], [4, 1, 4], [3, 2, 1], [4, 2, 2], [4, 3, 1]]\r\nD = 1\r\nOutput: [3, 1, 3, 1]</code></pre>\r\n\r\n<h3>Example 2:</h3>\r\n<pre><code class='language-text'>Input:\r\nA = 2\r\nB = [1, 3]\r\nC = [[2, 1, 3]]\r\nD = 1\r\nOutput: [1, 3]</code></pre>",
        "google_doc_link": null,
        "solution_code": null,
        "company_name": "MediaNet_5sep",
        "company_id": 476
    },
    {
        "id": 1369,
        "title": "Omega Primes",
        "problem_statement": "<h1>Omega Primes</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>Carl is bored of playing with ordinary prime numbers. Thus, he comes up with some special numbers called Omega Primes.</p>\r\n<p>A number X is called Omega Prime, if there exists no perfect square Y (Y > 1) such that Y divides X.</p>\r\n<p>For example, 6 is an Omega Prime because there is no perfect square except 1 that divides 6. On the other hand, 12 is not an Omega Prime as 4 (which is a perfect square) is a divisor of 12.</p>\r\n<p>Carl decides to play a bit more with Omega Primes. He has an array A of integers. Carl wants to find the number of different subsets such that the product of elements for each subset, results in an Omega Prime. Help Carl find this number.</p>\r\n<p>Since this number can be large, output the answer modulo 10<sup>9</sup> + 7.</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n<li>1 <= Length of A <= 2 * 10<sup>4</sup></li>\r\n<li>1 <= A[i] <= 30</li>\r\n</ul>\r\n\r\n<h3>Input Format</h3>\r\n<p>The first argument is the integer array A.</p>\r\n\r\n<h3>Output Format</h3>\r\n<p>Return an integer denoting the number of different desired subsets modulo 10<sup>9</sup> + 7.</p>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input 1:\r\nA = [2, 4, 3]\r\nOutput 1:\r\n3</code></pre>\r\n<p><strong>Explanation:</strong> The different subsets are [0, 2], [0], [2]. (the numbers denote the indices of the array elements)</p>\r\n\r\n<h3>Example 2:</h3>\r\n<pre><code class='language-text'>Input 2:\r\nA = [2, 2, 2]\r\nOutput 2:\r\n3</code></pre>\r\n<p><strong>Explanation:</strong> The different subsets are [0], [1], [2]. Note, the Omega Primes generated are same but the subset used to generate them are different.</p>\r\n\r\n<p>You only need to implement the given function. Do not read input; instead use the arguments to the function. Do not print the output; instead return values as specified. Still have a question? Check out Sample Codes for more details.</p>\r\n<pre><code class='language-cpp'>int Solution::findOmegas(vector&lt;int&gt; &amp;A) {\r\n    \r\n}</code></pre>",
        "google_doc_link": null,
        "solution_code": null,
        "company_name": "MediaNet_5sep",
        "company_id": 476
    }
]