[
    {
        "id": 941,
        "title": "Validate IP Address",
        "problem_statement": "<h1>Validate IP Address</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>You are using proxy server and Imagine you are given a string named proxy, which is essentially an unparsed string of numbers, sub-divided by decimals (.) or colons (:). Your quest is to determine what kind of treasure this string holds.</p>\r\n<p>Is it a secret IPv4 code reflected by the format 'x1.x2.x3.x4'? An IPv4 code is an elusive four-segment code where each segment (xi) ranges from 0 to 255 and does not keep any leading zeros in hiding. For instance, famous IPv4 sequences like '192.168.1.1' and '192.168.1.0' are valid, but wannabe sequences like '192.168.01.1', '192.168.1.00' and '192.168@1.1' are invalid as they disobey the code of IPv4 formatting laws.</p>\r\n<p>Or is it conveying an IPv6 message encapsulated in the format 'x1:x2:x3:x4:x5:x6:x7:x8'? Here, every xi segment can host between 1 to 4 characters. This mysterious string is allowed to contain digits, lowercase English letters ('a' to 'f'), or uppercase English letters ('A' to 'F'), and leading zeros are welcomed. Valid IPv6 messages could be '1990:0db8:85a3:0000:0000:8a2e:0370:7334' or '1990:db8:85a3:0:0:8a2e:0370:7334', while '1990:0db8:85a3:8A2E:037334' and '01990:0db8:85a3:0000:0000:8a2e:0370:7334' fail as authentic IPv6 messages.</p>\r\n<p>If the proxy does not unlock a valid IPv4 or IPv6 message, return 'Neither'; the string holds no treasure. So, will you be able to decipher this code?</p>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input: proxy = \"172.16.254.1\"\r\nOutput: \"IPv4\"</code></pre>\r\n<p><strong>Explanation:</strong> This is a valid IPv4 address, return \"IPv4\".</p>\r\n\r\n<h3>Example 2:</h3>\r\n<pre><code class='language-text'>Input: proxy = \"1990:0db8:85a3:0:0:8A2E:0370:7334\"\r\nOutput: \"IPv6\"</code></pre>\r\n<p><strong>Explanation:</strong> This is a valid IPv6 address, return \"IPv6\".</p>\r\n\r\n<h3>Example 3:</h3>\r\n<pre><code class='language-text'>Input: proxy = \"256.256.256.256\"\r\nOutput: \"Neither\"</code></pre>\r\n<p><strong>Explanation:</strong> This is neither a IPv4 address nor a IPv6 address.</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li>proxy consists only of English letters, digits and the characters '.' and ':'.</li>\r\n</ul>",
        "google_doc_link": null,
        "solution_code": null,
        "company_name": "Turing_24may",
        "company_id": 294
    },
    {
        "id": 942,
        "title": "Lexicographically Optimal Merging of Two Words",
        "problem_statement": "<h1>Lexicographically Optimal Merging of Two Words</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>You are given two strings, str1 and str2. Your goal is to construct a new string, result, by repeatedly performing one of the following operations until both str1 and str2 are empty:</p>\r\n<ul>\r\n    <li>Take from str1: Append the first character of str1 to result and remove it from str1.\r\n        <ul>\r\n            <li>For example, if str1 = \"xyz\" and result = \"a\", after this operation, str1 = \"yz\" and result = \"ax\".</li>\r\n        </ul>\r\n    </li>\r\n    <li>Take from str2: Append the first character of str2 to result and remove it from str2.\r\n        <ul>\r\n            <li>For example, if str2 = \"pq\" and result = \"ab\", after this operation, str2 = \"q\" and result = \"abp\".</li>\r\n        </ul>\r\n    </li>\r\n</ul>\r\n<p>Your objective is to construct the <strong>lexicographically largest</strong> string result.</p>\r\n<p>A string a is considered lexicographically larger than string b (of the same length) if, at the first position where they differ, the character in a is greater than the corresponding character in b. For example, \"zxy\" is lexicographically larger than \"zxx\" because y>x.</p>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input: str1 = \"acdbe\", str2 = \"bceaa\"\r\nOutput: \"bceacdbbea\"</code></pre>\r\n<p><strong>Explanation:</strong> We construct the lexicographically largest string result as follows:</p>\r\n<ol>\r\n    <li>Compare the first characters of str1 (a) and str2 (b). Since b > a, take the first character from str2.</li>\r\n    <li>result = \"b\", str1 = \"acdbe\", str2 = \"ceaa\".</li>\r\n    <li>Compare str1[0] = a and str2[0] = c. Since c > a, take the first character from str2.</li>\r\n    <li>result = \"bc\", str1 = \"acdbe\", str2 = \"eaa\".</li>\r\n    <li>Compare str1[0] = a and str2[0] = e. Since e > a, take the first character from str2.</li>\r\n    <li>result = \"bce\", str1 = \"acdbe\", str2 = \"aa\".</li>\r\n    <li>Compare str1[0] = a and str2[0] = a. Since they are equal, we prioritize the remaining parts of the strings.</li>\r\n    <li>Since str1 (acdbe) is lexicographically larger than str2 (aa), take the first character from str1.</li>\r\n    <li>result = \"bcea\", str1 = \"cdbe\", str2 = \"aa\".</li>\r\n    <li>Compare str1[0] = c and str2[0] = a. Since c > a, take the first character from str1.</li>\r\n    <li>result = \"bceac\", str1 = \"dbe\", str2 = \"aa\".</li>\r\n    <li>Compare str1[0] = d and str2[0] = a. Since d > a, take the first character from str1.</li>\r\n    <li>result = \"bceacd\", str1 = \"be\", str2 = \"aa\".</li>\r\n    <li>Compare str1[0] = b and str2[0] = a. Since b > a, take the first character from str1.</li>\r\n    <li>result = \"bceacdb\", str1 = \"e\", str2 = \"aa\".</li>\r\n    <li>Compare str1[0] = e and str2[0] = a. Since e > a, take the first character from str1.</li>\r\n    <li>result = \"bceacdbe\", str1 = \"\", str2 = \"aa\".</li>\r\n    <li>Finally, append the remaining characters.</li>\r\n    <li>result = \"bceacdbbea\".</li>\r\n</ol>\r\n\r\n<h3>Example 2:</h3>\r\n<p><em>(Content for Example 2 is not visible in the provided images.)</em></p>",
        "google_doc_link": null,
        "solution_code": null,
        "company_name": "Turing_24may",
        "company_id": 294
    }
]