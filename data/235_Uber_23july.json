[
    {
        "id": 742,
        "title": "Receipt Printing Optimization",
        "problem_statement": "<h1>Receipt Printing Optimization</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>Uber is a virtual accounting system, each trip generates a receipt that must be printed and archived. Uber offers n types of receipt paper packs, where each pack type i contains 2<sup>i</sup> receipt sheets and costs paperCost[i] units.</p>\r\n<p>The finance team is expected to print at least requiredReceipts number of trip receipts. They can purchase any number of paper packs of any type, even multiple packs of the same type, while minimizing the total cost.</p>\r\n<p>Implement a function that chooses the most cost-effective combination of paper packs such that they have at least the required number of receipt sheets.</p>\r\n<p>The function <code>getMinimumPaperCost</code> takes the following input:</p>\r\n<ul>\r\n<li><code>int paperCost[q]</code>: The cost of each type of paper pack.</li>\r\n<li><code>int requiredReceipts</code>: The minimum number of receipts that must be printed.</li>\r\n</ul>\r\n<p>The function should return a long integer representing the minimum total cost to purchase paper packs that provide at least <code>requiredReceipts</code> sheets.</p>\r\n<pre><code class='language-javascript'>long getMinimumPaperCost(vector&lt;int&gt; paperCost, int requiredReceipts)</code></pre>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input: n = 5, paperCost = [2, 5, 7, 11, 25], requiredReceipts = 26</code></pre>\r\n<p><strong>Explanation:</strong> An optimal strategy:</p>\r\n<ul>\r\n<li>Buy 2 packs of type 0 -> 2 x 2<sup>0</sup> = 2 sheets</li>\r\n<li>Buy 3 packs of type 3 -> 3 x 2<sup>3</sup> = 24 sheets</li>\r\n<li>Total sheets = 2 + 24 = 26, Total cost = 2 x 2 + 3 x 11 = 37</li>\r\n</ul>\r\n<p>It is guaranteed that no other strategy would cost lesser.</p>\r\n<pre><code class='language-text'>Output: 37</code></pre>\r\n<p><strong>Explanation:</strong> Hence, the answer is 37.</p>\r\n\r\n<h3>Example 2:</h3>\r\n<pre><code class='language-text'>Input: n = 5\r\npaperCost = [4, 3, 2, 1, 10]\r\nrequiredReceipts = 2</code></pre>\r\n<pre><code class='language-text'>Output: 1</code></pre>\r\n<p><strong>Explanation:</strong> In this case, the most cost-efficient strategy is to buy 1 unit of type 3, which provides 8 receipt sheets (more than the required 2 units) at the cost = 1. Hence, the answer is 1.</p>\r\n\r\n<h3>Example 3:</h3>\r\n<pre><code class='language-text'>Input: n = 4\r\npaperCost = [10, 9, 8, 10]\r\nrequiredReceipts = 14</code></pre>\r\n<pre><code class='language-text'>Output: 20</code></pre>\r\n<p><strong>Explanation:</strong> The most cost-effective strategy is to purchase 2 units of type 3, which provides 8 receipt sheets for each unit of paper pack purchased. So, total receipt sheets: 2 x 8 = 16 units (meets the requirement of at least 14 units) and the total cost incurred: 2 x 10 = 20. It is guaranteed that no other buying strategy would cost lesser than 20. Hence, the answer is 20.</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n<li><code>1 <= n <= 30</code></li>\r\n<li><code>1 <= paperCost[i] <= 10<sup>9</sup></code></li>\r\n<li><code>1 <= requiredReceipts <= 10<sup>9</sup></code></li>\r\n</ul>",
        "google_doc_link": null,
        "solution_code": null,
        "company_name": "Uber_23july",
        "company_id": 235
    },
    {
        "id": 743,
        "title": "Signal Blocks",
        "problem_statement": "<h1>Signal Blocks</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>Uber is testing a new multi-port charging strip used in electric vehicle hubs. Each port can handle a limited type of charge signal identified by characters 'a', 'e', 'i', 'o', and 'u', which correspond to different current frequencies.</p>\r\n<p>A diagnostic system logs these signals in a string <code>logSignals</code>. You need to find how many contiguous signal blocks that:</p>\r\n<ul>\r\n    <li>Contains only these five signal types (i.e., no other characters), and</li>\r\n    <li>Includes all five signal types at least once within the block.</li>\r\n</ul>\r\n<p>Implement a function that determines the number of such contiguous signal blocks.</p>\r\n<p>The function <code>countCompleteSignalBlocks</code> takes the following input:</p>\r\n<pre><code class='language-text'>string logSignals: log of signal types (lowercase letters)</code></pre>\r\n<p>The function should return a long integer denoting the number of contiguous blocks with only the five signal types and each appearing at least once.</p>\r\n<p>The expected function signature is:</p>\r\n<pre><code class='language-cpp'>long countCompleteSignalBlocks(string logSignals) {\r\n    // Complete the 'countCompleteSignalBlocks' function below.\r\n    // The function is expected to return a LONG_INTEGER.\r\n    // The function accepts STRING logSignals as parameter.\r\n}</code></pre>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input: logSignals = \"aeioaexaeuiou\"\r\nOutput: 4</code></pre>\r\n<p><strong>Explanation:</strong> In this scenario, all the contiguous signal blocks in the given <code>logSignals</code> are: \"aaeuiou\", \"aaeuio\", \"aeuiou\", \"aeuio\". Hence, the answer is 4.</p>\r\n\r\n<h3>Example 2:</h3>\r\n<pre><code class='language-text'>Input: logSignals = \"aaeiouxa\"\r\nOutput: 2</code></pre>\r\n<p><strong>Explanation:</strong> There are two valid contiguous signal blocks:</p>\r\n<ul>\r\n    <li><code>logSignals[0:5] = \"aaeiou\"</code></li>\r\n    <li><code>logSignals[1:5] = \"aeiou\"</code></li>\r\n</ul>\r\n<p>Hence, the answer is 2.</p>\r\n\r\n<h3>Example 3:</h3>\r\n<pre><code class='language-text'>Input: logSignals = \"axyzaeiou\"\r\nOutput: 1</code></pre>\r\n<p><strong>Explanation:</strong> There is only one valid contiguous signal block:</p>\r\n<ul>\r\n    <li><code>logSignals[4:8] = \"aeiou\"</code></li>\r\n</ul>\r\n<p>Hence, the answer is 1.</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>1 <= |logSignals| <= 10<sup>5</sup></code></li>\r\n    <li><code>logSignals[i]</code> is in the range ascii 'a'-'z' (where <code>0 <= i < |logSignals|</code>)</li>\r\n</ul>",
        "google_doc_link": null,
        "solution_code": null,
        "company_name": "Uber_23july",
        "company_id": 235
    },
    {
        "id": 744,
        "title": "Uber Green Zone Expansion",
        "problem_statement": "<h1>Uber Green Zone Expansion</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>In order to promote sustainability, Uber is planning to expand its Green Zones: areas where only electric vehicles (EVs) are allowed to pick up riders. The city map has <code>road_nodes</code> number of zones connected by roads (<code>road_from</code>, <code>road_to</code>, and <code>road_weight</code> length).</p>\r\n<p>Each zone is operated by a local Uber partner, listed in the <code>partner</code> array. If Uber signs a contract with a partner, all zones they manage become Green Zones. To prevent EV charging overload and rider confusion, no two active Green Zones can be within <code>minGap</code> of each other (measured by shortest road distance).</p>\r\n<p>Implement a function that calculates how many different partner group combinations can be activated without violating the distance rule.</p>\r\n<p>The function <code>countGreenZonePlans</code> takes the following inputs:</p>\r\n<ul>\r\n    <li><code>int road_nodes</code>: Total number of zones in the city.</li>\r\n    <li><code>int road_from</code>: An array representing one endpoint of each road.</li>\r\n    <li><code>int road_to</code>: An array representing the other endpoint of each road.</li>\r\n    <li><code>int road_weight</code>: An array representing the length of each road.</li>\r\n    <li><code>int minGap</code>: Minimum distance required between any two active Green Zones.</li>\r\n    <li><code>int partner</code>: An array representing the managing partner of each hub (zone).</li>\r\n</ul>\r\n<p>The function should return an integer denoting the number of valid partner combinations that result in feasible Green Zone deployments.</p>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input: road_nodes = 3, road_from = [1,2,3], road_to = [2,3,1], road_weight = [3,2,5], minGap = 4, partner = [1,2,3]\r\nOutput: 4</code></pre>\r\n<p><strong>Explanation:</strong> There are 3 potential drop-off centers to select from, each belonging to a different company as shown in the problem image. The required minimum distance between any 2 potential drop-off centers is 4 units.\r\nValid partner plans:\r\n<ul>\r\n    <li>Partner 1, alone</li>\r\n    <li>Partner 2, alone</li>\r\n    <li>Partner 3, alone, or</li>\r\n    <li>Partner 1 and 3</li>\r\n</ul>\r\nHence, the answer is 4.</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>2 &lt;= road_nodes &lt;= 1000</code></li>\r\n    <li><code>1 &lt;= n &lt;= min(1000, (road_nodes*(road_nodes+1))/2)</code> (where <code>n</code> is the number of roads/edges)</li>\r\n    <li><code>1 &lt;= road_weight[i] &lt;= 1000</code></li>\r\n    <li><code>1 &lt;= minGap &lt;= 1000</code></li>\r\n    <li><code>1 &lt;= partner[i] &lt;= 10</code></li>\r\n    <li>There are no self-loops and there is at most one edge between any 2 nodes.</li>\r\n</ul>\r\n\r\n<h2>Input Format for Custom Testing</h2>\r\n<p>The first line contains two integers: <code>road_nodes</code> and <code>n</code>, the number of locations and roads.</p>\r\n<p>The next <code>n</code> lines each contain three space-separated integers: <code>road_from[i]</code>, <code>road_to[i]</code>, and <code>road_weight[i]</code>, representing a road and its length.</p>\r\n<p>The next line contains an integer <code>minGap</code>.</p>\r\n<p>The next line contains an integer <code>road_nodes</code>, the size of the partner array.</p>\r\n<p>Each of the next <code>road_nodes</code> lines contains an integer <code>partner[i]</code>.</p>\r\n\r\n<h2>Sample Cases</h2>\r\n<h3>Sample Case 0:</h3>\r\n<pre><code class='language-text'>Input:\r\n2 1\r\n1 2 5\r\n4\r\n2\r\n1\r\n2\r\nOutput:\r\n3</code></pre>\r\n<p><strong>Explanation:</strong> There are two zones belonging to different partners. 5 units distance apart, which exceeds the minimum of 4. All subsets of partners i.e., {1}, {2}, {1,2} are acceptable, so the answer is 3.</p>\r\n\r\n<h3>Sample Case 1:</h3>\r\n<pre><code class='language-text'>Input:\r\n2 1\r\n1 2 5\r\n10\r\n2\r\n1\r\n2\r\nOutput:\r\n2</code></pre>\r\n<p><strong>Explanation:</strong> There are two zones belonging to different partners. 5 units distance apart, which is less than the minimum of 10. Partner with either one partner but not both. Hence, the answer is 2.</p>",
        "google_doc_link": null,
        "solution_code": null,
        "company_name": "Uber_23july",
        "company_id": 235
    },
    {
        "id": 748,
        "title": "Package Drop Optimization",
        "problem_statement": "<h1>Package Drop Optimization</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>Uber Connect package delivery team is reviewing how delivery agents handle packages across multiple zones.</p>\r\n<p>For each of the n delivery zones:</p>\r\n<ul>\r\n    <li><code>scheduledDrop[i]</code> stores the scheduled time (in minutes) to drop the package in the i<sup>th</sup> zone.</li>\r\n    <li><code>realDrop[i]</code> stores the actual time (in minutes) the package was dropped in the i<sup>th</sup> zone.</li>\r\n</ul>\r\n<p>Due to system limitations, the assignment of scheduled times and actual times to zones was not fixed, and can be shuffled independently before analysis. To evaluate overall performance, Uber calculates a weighted drop delay, where each zone is given a weight equal to its zone number.</p>\r\n<p>The weighted drop delay is formally defined as: (Assuming 1-based indexing)</p>\r\n<p>Total Weighted Drop Delay = &sum;<sub>i=1</sub><sup>n</sup> i * (realDrop[i] - scheduledDrop[i])</p>\r\n<p>Implement a function that determines the maximum possible weighted drop delay defined above. You are allowed to reorder both arrays independently in any way to maximize the total delay score.</p>\r\n<p>The function <code>maximizeDropDelay</code> takes the following parameters:</p>\r\n<ul>\r\n    <li><code>int scheduledDrop[n]</code>: the scheduled drop times (in minutes)</li>\r\n    <li><code>int realDrop[n]</code>: the actual drop times (in minutes)</li>\r\n</ul>\r\n<p>The function should return an integer representing the maximum possible weighted drop delay. Since the answer can be very large, return answer modulo (10<sup>9</sup> + 7).</p>\r\n<p><strong>Note:</strong> The array used in the problem statement follows 1-based indexing.</p>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input:\r\nn = 4\r\nscheduledDrop = [2, 1, 3, 4]\r\nrealDrop = [2, 3, 2, 3]</code></pre>\r\n<p>Some of the possible rearrangements and their resulting weighted drop delay scores:</p>\r\n<pre><code class='language-text'>scheduledDrop[i] Rearranged | realDrop[i] Rearranged | i * (realDrop[i] - scheduledDrop[i])\r\n----------------------------|------------------------|------------------------------------\r\n[2, 1, 3, 4]                | [2, 3, 2, 3]           | [0, 4, -3, -4]\r\n[3, 1, 2, 4]                | [2, 3, 2, 3]           | [-1, 4, 0, -4]\r\n[3, 1, 2, 4]                | [3, 2, 2, 3]           | [0, 2, 0, -4]\r\n[4, 3, 1, 2]                | [2, 2, 3, 3]           | [-2, -2, 6, 4]\r\n[4, 3, 2, 1]                | [2, 2, 3, 3]           | [-2, -2, 3, 8]</code></pre>\r\n<p><strong>Explanation:</strong> It is guaranteed that no other possible rearrangement of the arrays will generate weighted drop delay greater than 7. Thus, the maximum possible answer is 7 (7 modulo 10<sup>9</sup>+7 = 7). Hence, the answer is 7.</p>\r\n\r\n<h3>Sample Case 0:</h3>\r\n<pre><code class='language-text'>Input:\r\nn = 3\r\nscheduledDrop = [1, 2, 3]\r\nrealDrop = [10, 10, 10]\r\n\r\nOutput: 50</code></pre>\r\n<p><strong>Explanation:</strong> In this scenario it is optimal to rearrange the <code>scheduledDrop</code> to: <code>[3, 2, 1]</code> and keep <code>realDrop</code> the same. Calculating weighted drop delay for each of the index:</p>\r\n<ul>\r\n    <li>i = 1 -> 1 * (10 - 3) = 7.</li>\r\n    <li>i = 2 -> 2 * (10 - 2) = 16.</li>\r\n    <li>i = 3 -> 3 * (10 - 1) = 27.</li>\r\n</ul>\r\n<p>Thus, total weighted drop delay is 7 + 16 + 27 = 50. It is guaranteed that no other possible rearrangement of the arrays will generate weighted drop delay greater than 50. Hence, the answer is 50.</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li>1 &le; n &le; 10<sup>5</sup></li>\r\n    <li>1 &le; scheduledDrop[i] &le; 10<sup>9</sup></li>\r\n    <li>1 &le; realDrop[i] &le; 10<sup>9</sup></li>\r\n</ul>",
        "google_doc_link": null,
        "solution_code": null,
        "company_name": "Uber_23july",
        "company_id": 235
    }
]