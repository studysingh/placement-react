[
    {
        "id": 1756,
        "title": "Rectangle Area II",
        "problem_statement": "<h1>Rectangle Area II</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>You are given a 2D array of axis-aligned rectangles. Each <code>rectangle[i] = [xi1, yi1, xi2, yi2]</code> denotes the ith rectangle where <code>(xi1, yi1)</code> are the coordinates of the bottom-left corner, and <code>(xi2, yi2)</code> are the coordinates of the top-right corner.</p>\r\n<p>Calculate the total area covered by all rectangles in the plane. Any area covered by two or more rectangles should only be counted once.</p>\r\n<p>Return the total area. Since the answer may be too large, return it modulo <code>1e9 + 7</code>.</p>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input: rectangles = [[0,0,2,2],[1,0,2,3],[1,0,3,1]]\r\nOutput: 6</code></pre>\r\n<p><strong>Explanation:</strong> A total area of 6 is covered by all three rectangles, as illustrated in the picture. From (1,1) to (2,2), the green and red rectangles overlap. From (1,0) to (2,3), all three rectangles overlap.</p>\r\n\r\n<h3>Example 2:</h3>\r\n<pre><code class='language-text'>Input: rectangles = [[0,0,1000000000,1000000000]]\r\nOutput: 49</code></pre>\r\n<p><strong>Explanation:</strong> The answer is 10<sup>18</sup> modulo (10<sup>9</sup> + 7), which is 49.</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>1 &lt;= rectangles.length &lt;= 200</code></li>\r\n    <li><code>rectangles[i].length == 4</code></li>\r\n    <li><code>0 &lt;= xi1, yi1, xi2, yi2 &lt;= 1e9</code></li>\r\n    <li><code>xi1 &lt;= xi2</code></li>\r\n    <li><code>yi1 &lt;= yi2</code></li>\r\n    <li>All rectangles have non zero area.</li>\r\n</ul>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <vector>\n#include <numeric>\n#include <algorithm>\n\nclass Solution {\npublic:\n    int rectangleArea(std::vector<std::vector<int>>& rectangles) {\n        // Core logic to be implemented here.\n        // The result should be returned modulo 1e9 + 7.\n        // Intermediate area calculations might require 64-bit integers (long long).\n        \n        const int MOD = 1e9 + 7;\n        long long total_area = 0;\n\n        // Placeholder return\n        return 0;\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    // The problem description does not specify the number of rectangles N as part of the input.\n    // We will read rectangles line by line until end of input.\n    // Each line is expected to contain four integers: xi1, yi1, xi2, yi2.\n    std::vector<std::vector<int>> rectangles;\n    int x1, y1, x2, y2;\n    while (std::cin >> x1 >> y1 >> x2 >> y2) {\n        rectangles.push_back({x1, y1, x2, y2});\n    }\n\n    Solution sol;\n    int result = sol.rectangleArea(rectangles);\n    std::cout << result << std::endl;\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "wex",
        "company_id": 617
    },
    {
        "id": 1757,
        "title": "Maximize Distance to Closest Person",
        "problem_statement": "<h1>Maximize Distance to Closest Person</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>You are given an array representing a row of seats where <code>seats[i] = 1</code> represents a person sitting in the <code>i</code>th seat, and <code>seats[i] = 0</code> represents that the <code>i</code>th seat is empty (0-indexed).</p>\r\n<p>There is at least one empty seat, and at least one person sitting.</p>\r\n<p>Alex wants to sit in the seat such that the distance between him and the closest person to him is maximized.</p>\r\n<p>Return that maximum distance to the closest person.</p>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input: seats = [1,0,0,0,1,0,1]\r\nOutput: 2</code></pre>\r\n<p><strong>Explanation:</strong> If Alex sits in the second open seat (i.e. seats[2]), then the closest person has distance 2. If Alex sits in any other open seat, the closest person has distance 1. Thus, the maximum distance to the closest person is 2.</p>\r\n\r\n<h3>Example 2:</h3>\r\n<pre><code class='language-text'>Input: seats = [1,0,0,0]\r\nOutput: 3</code></pre>\r\n<p><strong>Explanation:</strong> If Alex sits in the last seat (i.e. seats[3]), the closest person is 3 seats away. This is the maximum distance possible, so the answer is 3.</p>\r\n\r\n<h3>Example 3:</h3>\r\n<pre><code class='language-text'>Input: seats = [0,1]\r\nOutput: 1</code></pre>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>2 &lt;= seats.length &lt;= 2 * 10^4</code></li>\r\n    <li><code>seats[i]</code> is <code>0</code> or <code>1</code>.</li>\r\n    <li>At least one seat is empty.</li>\r\n    <li>At least one seat is occupied.</li>\r\n</ul>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <numeric>\n\nclass Solution {\npublic:\n    int maxDistToClosest(const std::vector<int>& seats) {\n        // Core logic goes here\n        return 0;\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    // The problem description does not specify the exact input format.\n    // Assuming a standard competitive programming format where the size of the array\n    // is given first, followed by the elements of the array.\n    int n;\n    std::cin >> n;\n    std::vector<int> seats(n);\n    for (int i = 0; i < n; ++i) {\n        std::cin >> seats[i];\n    }\n\n    Solution solution;\n    int result = solution.maxDistToClosest(seats);\n    std::cout << result << std::endl;\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "wex",
        "company_id": 617
    }
]