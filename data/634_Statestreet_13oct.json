[
    {
        "id": 1798,
        "title": "Sum of Magic Nodes",
        "problem_statement": "<h1>Sum of Magic Nodes</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>Consider a binary tree of N nodes (1 Root and N-1 descendants). A node in this tree is called a 'Magic node' if both its descendants are 'Special numbers'. A Special number is one which reduces to 1 which successively replaced by the sum of the squares of its digits.</p>\r\n<p>For example, if n = 23:</p>\r\n<ul>\r\n    <li>First iteration: 2<sup>2</sup> + 3<sup>2</sup> = 4 + 9 = 13</li>\r\n    <li>Second iteration: 1<sup>2</sup> + 3<sup>2</sup> = 1 + 9 = 10</li>\r\n    <li>Third iteration: 1<sup>2</sup> + 0<sup>2</sup> = 1 + 0 = 1</li>\r\n</ul>\r\n<p>Since we reach 1, hence 23 is a Special number.</p>\r\n<p>The tree is represented as a series of relationships of each node to the Root node such as L, R, LL, LR... and so on, where each node is left (L) to Root or left-left (LL) or right-left (RL) to Root and so on.</p>\r\n<p>Write a program to find all the Magic nodes in the tree and print the sum of all such Magic nodes. Read the input from STDIN and print the output to STDOUT.</p>\r\n<p>Do not write arbitrary strings anywhere in the program, as these contribute to the standard output and testcases will fail.</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li>3 &lt;= N &lt;= 100</li>\r\n    <li>Node value X &gt; 0</li>\r\n</ul>\r\n\r\n<h2>Input Format</h2>\r\n<p>The first line of input contains an integer, N, the number of nodes in the tree.</p>\r\n<p>The second line of input contains the Root of the tree.</p>\r\n<p>The next N-1 lines of input contain a string, S and an integer, X separated by a single white space, where X is a node in the tree and S is the relation between Root and X.</p>\r\n\r\n<h2>Output Format</h2>\r\n<p>The output has an integer, which is the sum of all Magic nodes.</p>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input:\r\n9\r\n122\r\nL 376\r\nR 563\r\nLL 41\r\nLR 44\r\nRL 70\r\nRR 28\r\nRLL 19\r\nRLR 23\r\nOutput:\r\n755</code></pre>\r\n<p><strong>Explanation:</strong> The tree is shown as below. Since both 376 and 563 are special numbers, 122 is a Magic node. Similarly 563 and 70 are Magic nodes, since 70, 28, 19 and 23 are special numbers. Output is the sum of all Magic nodes in the tree which is 122+563+70=755.</p>\r\n\r\n<h3>Example 2:</h3>\r\n<pre><code class='language-text'>Input:\r\n7\r\n13\r\nL 31\r\nR 32\r\nRL 70\r\nRR 12\r\nRLL 82\r\nRLR 91\r\nOutput:\r\n83</code></pre>\r\n<p><strong>Explanation:</strong> The tree is shown as below. The Magic nodes are 13 and 70. Hence output is 83.</p>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <vector>\n#include <string>\n#include <numeric>\n#include <unordered_set>\n\n// Definition for a binary tree node.\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n};\n\nclass Solution {\npublic:\n    /**\n     * @param root The root of the binary tree.\n     * @return The sum of all Magic nodes in the tree.\n     */\n    int sumOfMagicNodes(TreeNode* root) {\n        // Core logic to be implemented here.\n        // This function should:\n        // 1. Define a helper function `isSpecial(int n)` to check if a number is special.\n        //    A number is special if the sequence of sums of squares of its digits eventually reaches 1.\n        //    Use a set to detect cycles to avoid infinite loops for non-special numbers.\n        // 2. Traverse the tree (e.g., using DFS/recursion).\n        // 3. For each node, check if it's a \"Magic node\".\n        //    A node is magic if it has both a left and a right child, AND\n        //    the values of both children are special numbers.\n        // 4. If a node is magic, add its value to a running total.\n        // 5. Return the total sum.\n        return 0;\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    int n;\n    std::cin >> n;\n\n    if (n == 0) {\n        std::cout << 0 << std::endl;\n        return 0;\n    }\n\n    int root_val;\n    std::cin >> root_val;\n    TreeNode* root = new TreeNode(root_val);\n\n    for (int i = 0; i < n - 1; ++i) {\n        std::string s;\n        int x;\n        std::cin >> s >> x;\n\n        TreeNode* current = root;\n        for (size_t j = 0; j < s.length() - 1; ++j) {\n            if (s[j] == 'L') {\n                current = current->left;\n            } else { // s[j] == 'R'\n                current = current->right;\n            }\n        }\n\n        if (s.back() == 'L') {\n            current->left = new TreeNode(x);\n        } else { // s.back() == 'R'\n            current->right = new TreeNode(x);\n        }\n    }\n\n    Solution solution;\n    int result = solution.sumOfMagicNodes(root);\n    std::cout << result << std::endl;\n\n    // Note: In competitive programming, memory for the tree is often not deallocated\n    // as the program terminates shortly after, and the OS reclaims the memory.\n    // For long-running applications, a proper cleanup would be necessary.\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "Statestreet_13oct",
        "company_id": 634
    }
]