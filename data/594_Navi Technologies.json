[
    {
        "id": 1701,
        "title": "Count Grid Coloring Patterns",
        "problem_statement": "<h1>Count Grid Coloring Patterns</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>An automated painting system needs a program that can paint an <code>n x 3</code> grid using three distinct colors: red (R), green (G), and blue (B). The coloring must adhere to a specific rule: no row or column should contain cells that are all the same color.</p>\r\n<p>For example, a row like <code>[R, R, R]</code> or a column where all three cells are <code>[G, G, G]</code> (vertically) would be invalid. However, a row like <code>[R, G, R]</code> or <code>[R, R, G]</code> is valid, as not all cells in that row are the same color. Similarly for columns.</p>\r\n<p>Given an integer <code>n</code>, representing the number of rows, determine the total number of valid patterns that can be painted on an <code>n x 3</code> grid. Since the number of patterns can be very large, return the result modulo <code>(10^9 + 7)</code>.</p>\r\n<p>For instance, a <code>4 x 3</code> grid has 296490 valid patterns.</p>\r\n<p>Complete the <code>countPatterns</code> function in the editor below.</p>\r\n<ul>\r\n    <li><strong>Parameter:</strong> <code>int n</code>: The number of rows in the <code>n x 3</code> grid.</li>\r\n    <li><strong>Returns:</strong> <code>int</code>: The number of ways in which the grid can be colored, calculated as a modulo of <code>(10^9 + 7)</code>.</li>\r\n</ul>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input: n = 2\r\nOutput: 174</code></pre>\r\n<p><strong>Explanation:</strong> For a <code>2x3</code> grid, there are 174 distinct valid coloring patterns. The problem statement provides visual examples of valid and invalid arrangements for a <code>2x3</code> grid to illustrate the rules.</p>\r\n\r\n<h3>Example 2:</h3>\r\n<pre><code class='language-text'>Input: n = 3\r\nOutput: 9750</code></pre>\r\n<p><strong>Explanation:</strong> For a <code>3x3</code> grid, there are 9750 distinct valid coloring patterns.</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>2 &le; n &le; 20000</code></li>\r\n</ul>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nclass Solution {\npublic:\n    int countPatterns(int n) {\n        // Core logic to solve the problem will be implemented here.\n        // The problem likely involves dynamic programming.\n        // Let's define the state based on the coloring of the previous row.\n        // A row can be colored in 3^3 = 27 ways.\n        // A row is invalid if all cells are the same color (RRR, GGG, BBB).\n        // So, there are 27 - 3 = 24 valid row colorings.\n        // The state of our DP could be dp[i][pattern], where i is the row number\n        // and pattern represents the coloring of the i-th row.\n        // We also need to check the column constraint.\n        // This suggests the state should depend on the previous row's coloring.\n        \n        // Let's define two types of valid row colorings:\n        // Type A: Two colors are the same, one is different (e.g., RRG, RGB). 3 choices for the pair color, 2 for the single, 3 positions for the single = 3*2*3 = 18 ways.\n        // Type B: All three colors are different (e.g., RGB). 3! = 6 ways.\n        // Total = 18 + 6 = 24 valid rows.\n\n        // Let dp[i][0] be the number of ways to color the first i rows such that row i is of Type A.\n        // Let dp[i][1] be the number of ways to color the first i rows such that row i is of Type B.\n\n        // We need to find the transition from row i-1 to row i.\n        // This requires analyzing how two rows can be stacked without creating a monochromatic column.\n        \n        // Placeholder return value.\n        return 0;\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    int n;\n    std::cin >> n;\n\n    Solution solution;\n    int result = solution.countPatterns(n);\n\n    std::cout << result << std::endl;\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "Navi Technologies",
        "company_id": 594
    },
    {
        "id": 1702,
        "title": "Minimum Spanning Tree Edge Weight Difference",
        "problem_statement": "<h1>Minimum Spanning Tree Edge Weight Difference</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>There is a given weighted undirected graph of <code>g_nodes</code> nodes numbered from 1 to <code>g_nodes</code>. There are <code>g_edges</code> edges where the <code>i</code>-th edge connects nodes <code>g_from[i]</code> and <code>g_to[i]</code> with a weight <code>g_weight[i]</code>. A spanning tree is defined as a graph obtained after deleting some edges from the original graph such that all nodes are connected by exactly <code>g_nodes - 1</code> edges.</p>\r\n<p>Find a spanning tree of the graph such that the difference between the maximum and minimum weights of the tree is the minimum possible. Report this minimum possible difference as the answer or -1 if no spanning tree exists in the graph.</p>\r\n<p>Complete the function <code>findMinDifference</code> in the editor below. The function must return a minimum difference between the maximal and the minimal edge weight or -1 if no Spanning Tree exists.</p>\r\n<p><code>findMinDifference</code> has the following parameters:</p>\r\n<ul>\r\n    <li><code>int g_nodes</code>: the number of nodes</li>\r\n    <li><code>vector&lt;int&gt; g_from</code>: 1-D array, one end of each edge</li>\r\n    <li><code>vector&lt;int&gt; g_to</code>: 1-D array, the other end of each edge</li>\r\n    <li><code>vector&lt;int&gt; g_weight</code>: 1-D array, the weights of each edge</li>\r\n</ul>\r\n<pre><code class='language-javascript'>int findMinDifference(int g_nodes, vector&lt;int&gt; g_from, vector&lt;int&gt; g_to, vector&lt;int&gt; g_weight)</code></pre>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input: g_nodes = 4, g_edges = 5, g_from = [1, 2, 3, 2], g_to = [2, 3, 4, 4], g_weight = [-1, 2, 5, 3]\r\nOutput: 4</code></pre>\r\n<p><strong>Explanation:</strong> By removing the edge 3-4 with the weight 5, we will obtain a spanning tree with weights equal to [-1, 2, 3]. Therefore, the difference between maximum and minimum weights of the edges is 3 - (-1) = 4. Hence, 4 is the answer. It can be shown that the answer cannot be less than this.</p>\r\n\r\n<h3>Example 2:</h3>\r\n<pre><code class='language-text'>Input: g_nodes = 3, g_edges = 3, g_from = [1, 2, 3], g_to = [2, 3, 1], g_weight = [5, 4, 3]\r\nOutput: 1</code></pre>\r\n<p><strong>Explanation:</strong> In this case, the spanning tree formed by the 2nd and the 3rd edge (edges with weights 4 and 3) would give the minimum difference between the edges. The maximum weight is 4, the minimum weight is 3. The difference is 4 - 3 = 1. It can be shown that no other possible combination would give a better answer.</p>\r\n\r\n<h3>Example 3:</h3>\r\n<pre><code class='language-text'>Input: g_nodes = 4, g_edges = 5, g_from = [1, 1, 1, 3, 3], g_to = [2, 3, 4, 2, 4], g_weight = [1, 2, 1, 2, 2]\r\nOutput: 0</code></pre>\r\n<p><strong>Explanation:</strong> A spanning tree can be formed using edges (1,2) with weight 1, (1,3) with weight 1, and (1,4) with weight 1. The maximum edge weight in this spanning tree is 1, and the minimum edge weight is 1. The difference is 1 - 1 = 0.</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>2 &lt;= g_nodes &lt;= 1500</code></li>\r\n    <li><code>0 &lt;= g_edges &lt;= 2500</code></li>\r\n    <li><code>1 &lt;= g_from[i], g_to[i] &lt;= g_nodes</code></li>\r\n    <li><code>-1000 &lt;= g_weight[i] &lt;= 1000</code></li>\r\n</ul>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <numeric>\n\nclass Solution {\npublic:\n    int findMinDifference(int g_nodes, const std::vector<int>& g_from, const std::vector<int>& g_to, const std::vector<int>& g_weight) {\n        // Core logic to find the minimum difference between max and min edge weights in a spanning tree goes here.\n        return 0;\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    int g_nodes;\n    std::cin >> g_nodes;\n\n    int g_edges;\n    std::cin >> g_edges;\n\n    std::vector<int> g_from(g_edges);\n    std::vector<int> g_to(g_edges);\n    std::vector<int> g_weight(g_edges);\n\n    for (int i = 0; i < g_edges; ++i) {\n        std::cin >> g_from[i] >> g_to[i] >> g_weight[i];\n    }\n\n    Solution solution;\n    int result = solution.findMinDifference(g_nodes, g_from, g_to, g_weight);\n\n    std::cout << result << std::endl;\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "Navi Technologies",
        "company_id": 594
    }
]