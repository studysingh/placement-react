[
    {
        "id": 1799,
        "title": "Total Transmitted Logs",
        "problem_statement": "<h1>Total Transmitted Logs</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>You are given a logging system that uses a circular buffer. This buffer can hold up to <code>n</code> logs. Each log has a unique timestamp (in milliseconds) and an associated tag.</p>\r\n<p>When a new log arrives, the system processes it as follows:</p>\r\n<ul>\r\n    <li>\r\n        <strong>Buffer Management:</strong>\r\n        If the circular buffer is currently full (i.e., it contains <code>bufferCapacity</code> logs), the oldest log in the buffer is removed to make space for the new log. After this potential removal, the new log is added to the buffer.\r\n    </li>\r\n    <li>\r\n        <strong>Log Transmission:</strong>\r\n        After the new log has been added to the buffer (and any necessary oldest log removed), the system identifies and transmits all logs that meet the following criteria:\r\n        <ul>\r\n            <li>They share the same tag as the newly arrived log.</li>\r\n            <li>Their timestamp falls within a specific time window relative to the newly arrived log's timestamp. This window is defined as <code>[new_log_timestamp - transmissionWindow, new_log_timestamp]</code>.</li>\r\n        </ul>\r\n    </li>\r\n</ul>\r\n<p>Your task is to implement a function that calculates the total number of logs transmitted throughout the entire process, considering the circular buffer's capacity and the specified transmission time window.</p>\r\n\r\n<p>The function <code>getTotalTransmittedLogs</code> takes the following parameters:</p>\r\n<ul>\r\n    <li><code>logTimestamp</code>: A <code>vector&lt;int&gt;</code> representing the recording times of logs in milliseconds.</li>\r\n    <li><code>logTag</code>: A <code>vector&lt;string&gt;</code> representing the tags of logs.</li>\r\n    <li><code>bufferCapacity</code>: An <code>int</code> indicating the maximum number of logs the circular buffer can hold.</li>\r\n    <li><code>transmissionWindow</code>: An <code>int</code> representing the time range (in milliseconds) for transmission. A log is transmitted if its timestamp <code>T_x</code> is within <code>[T_new - transmissionWindow, T_new]</code>, where <code>T_new</code> is the timestamp of the newly arriving log.</li>\r\n</ul>\r\n<p>The function should return the total number of logs transmitted during the process as a <code>long</code> integer.</p>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input:\r\nlogTimestamp = [1000, 2000, 3000, 4001]\r\nlogTag = [\"error\", \"warning\", \"error\", \"warning\"]\r\nbufferCapacity = 3\r\ntransmissionWindow = 2000\r\nOutput: 5</code></pre>\r\n<p><strong>Explanation:</strong>\r\nThe logs received are as follows:</p>\r\n<ul>\r\n    <li>Log 1: Timestamp = 1000 ms, Tag = \"error\"</li>\r\n    <li>Log 2: Timestamp = 2000 ms, Tag = \"warning\"</li>\r\n    <li>Log 3: Timestamp = 3000 ms, Tag = \"error\"</li>\r\n    <li>Log 4: Timestamp = 4001 ms, Tag = \"warning\"</li>\r\n</ul>\r\n<p>Let's trace the process:</p>\r\n<ul>\r\n    <li>\r\n        <strong>Initial State:</strong> Buffer is empty. Total transmitted logs = 0.\r\n    </li>\r\n    <li>\r\n        <strong>Log 1 (Timestamp 1000 ms, Tag \"error\") arrives:</strong>\r\n        <ul>\r\n            <li>Buffer before arrival: <code>[]</code>. Buffer is not full.</li>\r\n            <li>Add Log 1. Buffer becomes: <code>[Log 1]</code>.</li>\r\n            <li><strong>Transmission Check:</strong> The current log tag is \"error\". The transmission window for Log 1 (timestamp 1000) is <code>[1000 - 2000, 1000] = [-1000, 1000]</code>.</li>\r\n            <li>Logs in buffer with tag \"error\" and timestamp within <code>[-1000, 1000]</code>: <code>Log 1</code> (timestamp 1000).</li>\r\n            <li><strong>Transmitted:</strong> <code>Log 1</code>. Total transmitted logs: 1.</li>\r\n        </ul>\r\n    </li>\r\n    <li>\r\n        <strong>Log 2 (Timestamp 2000 ms, Tag \"warning\") arrives:</strong>\r\n        <ul>\r\n            <li>Buffer before arrival: <code>[Log 1]</code>. Buffer is not full.</li>\r\n            <li>Add Log 2. Buffer becomes: <code>[Log 1, Log 2]</code>.</li>\r\n            <li><strong>Transmission Check:</strong> The current log tag is \"warning\". The transmission window for Log 2 (timestamp 2000) is <code>[2000 - 2000, 2000] = [0, 2000]</code>.</li>\r\n            <li>Logs in buffer with tag \"warning\" and timestamp within <code>[0, 2000]</code>: <code>Log 2</code> (timestamp 2000).</li>\r\n            <li><strong>Transmitted:</strong> <code>Log 2</code>. Total transmitted logs: 1 + 1 = 2.</li>\r\n        </ul>\r\n    </li>\r\n    <li>\r\n        <strong>Log 3 (Timestamp 3000 ms, Tag \"error\") arrives:</strong>\r\n        <ul>\r\n            <li>Buffer before arrival: <code>[Log 1, Log 2]</code>. Buffer is not full.</li>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <vector>\n#include <string>\n#include <numeric>\n#include <deque>\n\nclass Solution {\npublic:\n    long long getTotalTransmittedLogs(const std::vector<int>& logTimestamp,\n                                      const std::vector<std::string>& logTag,\n                                      int bufferCapacity,\n                                      int transmissionWindow) {\n        // TODO: Implement the solution logic here\n        return 0;\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    int n;\n    // Assuming the number of logs is provided first, though not explicitly stated.\n    // This is a common pattern for vector inputs.\n    // If logTimestamp and logTag are read until EOF, this part needs adjustment.\n    // Based on the example, we can infer the number of logs.\n    // Let's assume a fixed input format for the boilerplate:\n    // N\n    // timestamp_1 tag_1\n    // ...\n    // timestamp_N tag_N\n    // bufferCapacity\n    // transmissionWindow\n    \n    // The example input is given as arrays, so we'll simulate reading them.\n    // A more robust competitive programming setup would read N first.\n    // Let's assume N is implicitly the size of the provided vectors.\n    // For a runnable boilerplate, we need to read N.\n    \n    // Let's assume the number of logs is the first line of input.\n    int num_logs;\n    // A simple way to read until we have all logs, if N is not given, is not standard.\n    // Let's stick to the N-first format.\n    // Example:\n    // 4\n    // 1000 error\n    // 2000 warning\n    // 3000 error\n    // 4001 warning\n    // 3\n    // 2000\n    \n    // Let's assume N is not given and we read until we can't. This is less likely.\n    // The most reasonable assumption for a boilerplate is that N is given.\n    \n    // Let's assume the input format is:\n    // N\n    // timestamp_1 tag_1\n    // ...\n    // timestamp_N tag_N\n    // bufferCapacity transmissionWindow\n    \n    int log_count;\n    std::cin >> log_count;\n    \n    std::vector<int> logTimestamp(log_count);\n    std::vector<std::string> logTag(log_count);\n    \n    for (int i = 0; i < log_count; ++i) {\n        std::cin >> logTimestamp[i] >> logTag[i];\n    }\n    \n    int bufferCapacity;\n    std::cin >> bufferCapacity;\n    \n    int transmissionWindow;\n    std::cin >> transmissionWindow;\n    \n    Solution solution;\n    long long result = solution.getTotalTransmittedLogs(logTimestamp, logTag, bufferCapacity, transmissionWindow);\n    \n    std::cout << result << std::endl;\n    \n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "ibm_13oct",
        "company_id": 635
    },
    {
        "id": 1800,
        "title": "Minimum Transformation Cost",
        "problem_statement": "<h1>Minimum Transformation Cost</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>Given two strings <code>s</code> and <code>t</code>, determine the minimum total cost required to transform <code>s</code> into <code>t</code> using the following operation any number of times, including zero:</p>\r\n<ul>\r\n    <li>Select an index <code>i</code> such that <code>0 <= i < length of s</code>.</li>\r\n    <li>Remove the character at index <code>i</code>.</li>\r\n    <li>Concatenate the remaining characters in order.</li>\r\n    <li>The step costs <code>i</code> units.</li>\r\n</ul>\r\n<p>If the transformation is not possible, return <code>-1</code>.</p>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input: s = \"abcec\", t = \"aba\"\r\nOutput: 6</code></pre>\r\n<p><strong>Explanation:</strong> The underlined character is removed in the step.</p>\r\n<p>Transformation Steps</p>\r\n<pre><code class='language-text'>Step | s before | Step (0-based indexing) | Cost | s after\r\n-----|----------|-------------------------|------|--------\r\n0    | abcec    | Choose the index i = 3  | 3    | abec\r\n1    | abec     | Choose the index i = 3  | 3    | abe</code></pre>\r\n\r\n<h3>Example 2:</h3>\r\n<pre><code class='language-text'>Input: s = \"abcde\", t = \"acf\"\r\nOutput: -1</code></pre>\r\n<p><strong>Explanation:</strong> It is not possible to match the 'f' in t.</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>1 <= length of s and t <= 10^5</code></li>\r\n    <li><code>Strings s and t contain only lowercase English letters.</code></li>\r\n</ul>\r\n\r\n<pre><code class='language-javascript'>long getMinimumCost(string s, string t) {\r\n    // Complete the 'getMinimumCost' function below.\r\n    // The function is expected to return a LONG_INTEGER.\r\n    // The function accepts the following parameters:\r\n    //  1. STRING s\r\n    //  2. STRING t\r\n}</code></pre>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nclass Solution {\npublic:\n    long long getMinimumCost(std::string s, std::string t) {\n        // Core logic to be implemented here\n        return 0;\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n    std::string s;\n    std::cin >> s;\n    std::string t;\n    std::cin >> t;\n\n    Solution sol;\n    long long result = sol.getMinimumCost(s, t);\n\n    std::cout << result << std::endl;\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "ibm_13oct",
        "company_id": 635
    }
]