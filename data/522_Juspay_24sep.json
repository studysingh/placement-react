[
    {
        "id": 1494,
        "title": "Locking the tree of space",
        "problem_statement": "<h1>Locking the tree of space</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>You have a world map represented as an M-Ary tree. An example tree structure is shown below:</p>\r\n<ul>\r\n    <li>World (root)\r\n        <ul>\r\n            <li>Asia\r\n                <ul>\r\n                    <li>India\r\n                        <ul>\r\n                            <li>KA\r\n                                <ul>\r\n                                    <li>BLR</li>\r\n                                </ul>\r\n                            </li>\r\n                            <li>MP</li>\r\n                            <li>TN</li>\r\n                        </ul>\r\n                    </li>\r\n                    <li>China</li>\r\n                </ul>\r\n            </li>\r\n            <li>Africa</li>\r\n        </ul>\r\n    </li>\r\n</ul>\r\n<p>For a complete 3-ary tree, <code>m = 3</code>, and <code>N = 121</code> represents the number of nodes.</p>\r\n<p>You need to define three operations on this tree. For each operation, <code>X</code> is the name of a node in the tree (which is unique) and <code>uid</code> is the user ID who is performing the operation.</p>\r\n\r\n<h3>1. Lock(X, uid)</h3>\r\n<p>Lock takes an exclusive access on the subtree rooted at <code>X</code>. It is formally defined as follows:</p>\r\n<p>Once <code>lock(X, uid)</code> succeeds, then:</p>\r\n<ul>\r\n    <li><code>lock(A, anyUserid)</code> should fail (returns <code>false</code>), where <code>A</code> is a descendent of <code>X</code>.</li>\r\n    <li><code>lock(B, anyUserid)</code> should fail (returns <code>false</code>), where <code>X</code> is a descendent of <code>B</code> (i.e., <code>B</code> is an ancestor of <code>X</code>).</li>\r\n    <li>A Lock operation cannot be performed on a node which is already locked, i.e., <code>lock(X, anyUserid)</code> should fail (returns <code>false</code>).</li>\r\n</ul>\r\n\r\n<h3>2. Unlock(X, uid)</h3>\r\n<ul>\r\n    <li>Unlock reverts what was done by the Lock operation. It can only be called on the same node on which user <code>uid</code> had called a Lock before. Returns <code>true</code> if it is successful.</li>\r\n</ul>\r\n\r\n<h3>3. UpgradeLock(X, uid)</h3>\r\n<ul>\r\n    <li>It helps the user <code>uid</code> upgrade their lock to an ancestor node. It is only possible if the node <code>X</code> already has locked descendants and all of them are only locked by the same user <code>uid</code>. Upgrade should fail if there is any node which is a descendant of <code>X</code> that is locked by a different user. A successful Upgrade will <code>Lock</code> the node <code>X</code>. The <code>UpgradeLock</code> call shouldn't violate the consistency model that <code>Lock</code>/<code>Unlock</code> functions require.</li>\r\n</ul>\r\n\r\n<h2>Input Format</h2>\r\n<p>The input format is as follows:</p>\r\n<ul>\r\n    <li>The first line contains the <strong>number</strong> of Nodes in the tree (N).</li>\r\n    <li>The second line contains the <strong>number</strong> of children per node (value m in m-ary Tree).</li>\r\n    <li>The third line contains the <strong>number</strong> of queries (Q).</li>\r\n    <li>The next N lines contain the <strong>NodeName</strong> (string) in the m-Ary tree.</li>\r\n    <li>The next Q lines contain queries, each in the format: <strong>OperationType NodeName UserId</strong></li>\r\n</ul>\r\n<p><strong>OperationType</strong> ->\r\n    <ul>\r\n        <li>1 for Lock</li>\r\n        <li>2 for Unlock</li>\r\n        <li>3 for UpgradeLock</li>\r\n    </ul>\r\n</p>\r\n<p><strong>NodeName</strong> -> Name of any node (unique) in m-Ary Tree.</p>\r\n<p><strong>UserId</strong> -> Integer value representing a unique user.</p>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<p>With the input below, a 2-ary tree with 7 nodes is represented as follows:</p>\r\n<pre><code class='language-text'>World\r\n|     |\r\nAsia  Africa\r\n|  |  |      |\r\nChina India SouthAfrica Egypt</code></pre>\r\n<pre><code class='language-text'>Input:\r\n7\r\n2\r\n5\r\nWorld\r\nAsia\r\nAfrica\r\nChina\r\nIndia\r\nSouthAfrica\r\nEgypt\r\n1 China 9\r\n1 India 9\r\n3 Asia 9\r\n2 India 9\r\n2 Asia 9\r\nOutput:\r\ntrue\r\ntrue\r\ntrue\r\nfalse\r\ntrue</code></pre>\r\n<p><strong>Explanation:</strong></p>\r\n<ul>\r\n    <li><strong>Query 1:</strong> <code>1 China 9</code> -> This operation succeeds as China is initially unlocked.</li>\r\n    <li><strong>Query 2:</strong> <code>1 India 9</code> -> This operation succeeds as none of India's ancestors or descendants are locked.</li>\r\n    <li><strong>Query 3:</strong> <code>3 Asia 9</code> -> This operation succeeds as it's an upgrade operation performed by the same user (uid 9) who has locked descendants (China and India).</li>\r\n    <li><strong>Query 4:</strong> <code>2 India 9</code> -> This operation fails because India is now not locked (it was implicitly unlocked when Asia was locked by the upgrade operation).</li>\r\n    <li><strong>Query 5:</strong> <code>2 Asia 9</code> -> This operation succeeds as Asia was locked by user 9 earlier (refer Query 3).</li>\r\n</ul>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>1 &lt; N &lt;= 5 * 10^5</code></li>\r\n    <li><code>1 &lt; m &lt; 30</code></li>\r\n    <li><code>1 &lt; Q &lt;= 5 * 10^5</code></li>\r\n    <li><code>1 &lt;= length of NodeName &lt; 20</code></li>\r\n</ul>\r\n\r\n<h2>Additional Notes</h2>\r\n<ul>\r\n    <li>The tree is always <strong>fully balanced</strong>.</li>\r\n    <li>Optimize the time complexity for the operations:\r\n        <ul>\r\n            <li>Lock - <code>O(log_m N)</code></li>\r\n            <li>Unlock - <code>O(log_m N)</code></li>\r\n            <li>UpgradeLock - <code>O(numberOfLockedNodes * log_m N)</code></li>\r\n        </ul>\r\n    </li>\r\n    <li>A Lock operation on an already locked node should fail.</li>\r\n    <li>Once <code>UpgradeLock(X, uid)</code> succeeds on <code>X</code>, it is equivalent to <code>X</code> being locked by <code>uid</code>. Therefore, subsequent <code>Lock</code> operations on <code>X</code> or its ancestors/descendants (as per the <code>Lock</code> definition) should fail, and <code>Unlock(X, uid)</code> should work.</li>\r\n    <li>An Upgrade lock operation on a node having no locked descendants should fail, and an upgrade lock on an already locked node should also fail.</li>\r\n</ul>\r\n\r\n<h2>Limits</h2>\r\n<ul>\r\n    <li>Time Limit: 0.6 seconds for each input file</li>\r\n    <li>Memory Limit: 256 MB</li>\r\n    <li>Source Limit: 1024 KB</li>\r\n</ul>\r\n\r\n<h2>Scoring</h2>\r\n<p>Score is assigned if any testcase passes.</p>",
        "google_doc_link": null,
        "solution_code": null,
        "company_name": "Juspay_24sep",
        "company_id": 522
    }
]