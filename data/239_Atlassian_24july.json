[
    {
        "id": 754,
        "title": "Round-Robin Load Balancing",
        "problem_statement": "<h1>Round-Robin Load Balancing</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>Implement a prototype round-robin load-balancing algorithm for <code>n</code> servers numbered 1 to <code>n</code>, handling <code>m</code> requests.</p>\r\n<p>Each request <code>i</code> arrives at time <code>arrival[i]</code> and takes <code>burstTime[i]</code> to execute. The load balancer assigns each request to the available server with the lowest index. A server becomes unavailable from the arrival time until completion (<code>arrival[i] + burstTime[i]</code>).</p>\r\n<p>If multiple requests arrive simultaneously, they are processed in order of their original indices. If no server is available when a request arrives, it is dropped (-1).</p>\r\n<p>For each request, return the 1-based index of the server that processes it or -1 if dropped.</p>\r\n\r\n<h3>Function Description</h3>\r\n<p>Complete the function <code>getServerIndex</code> in the editor with the following parameter(s):</p>\r\n<ul>\r\n    <li><code>int n</code>: the number of servers</li>\r\n    <li><code>int arrival[m]</code>: the arrival time of requests</li>\r\n    <li><code>int burstTime[m]</code>: the burst time of requests</li>\r\n</ul>\r\n<p>Returns</p>\r\n<ul>\r\n    <li><code>int[m]</code>: the 1-based index of the servers the requests are assigned to, or -1 if no server is available</li>\r\n</ul>\r\n<pre><code class='language-cpp'>vector<int> getServerIndex(int n, vector<int> arrival, vector<int> burstTime) {\r\n\r\n}</code></pre>\r\n\r\n<h2>Examples</h2>\r\n\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input:\r\nn = 3\r\nm = 5\r\narrival = [2, 4, 1, 8, 9]\r\nburstTime = [7, 9, 2, 4, 5]\r\nOutput: [2, 1, 1, 3, 2]</code></pre>\r\n<p><strong>Explanation:</strong> The requests are processed as follows:</p>\r\n<ul>\r\n    <li>Request with original index 2 arrives at time 1, burst time 2. Assigned to Server 1. Server 1 busy until 1 + 2 = 3. Output: 1</li>\r\n    <li>Request with original index 0 arrives at time 2, burst time 7. Assigned to Server 2. Server 2 busy until 2 + 7 = 9. Output: 2</li>\r\n    <li>Request with original index 1 arrives at time 4, burst time 9. Assigned to Server 1 (free at 3). Server 1 busy until 4 + 9 = 13. Output: 1</li>\r\n    <li>Request with original index 3 arrives at time 8, burst time 4. Assigned to Server 3. Server 3 busy until 8 + 4 = 12. Output: 3</li>\r\n    <li>Request with original index 4 arrives at time 9, burst time 5. Assigned to Server 2 (free at 9). Server 2 busy until 9 + 5 = 14. Output: 2</li>\r\n</ul>\r\n<p>The final assignment order (based on original request indices) is [2, 1, 1, 3, 2].</p>\r\n\r\n<h3>Example 2:</h3>\r\n<pre><code class='language-text'>Input:\r\nn = 4\r\narrival = [3, 5, 1, 6, 8]\r\nburstTime = [9, 2, 10, 4, 5]\r\nOutput: [2, 3, 1, 4, 2]</code></pre>\r\n<p><strong>Explanation:</strong>\r\n<ul>\r\n    <li>The requests arrive in order [3, 1, 2, 4, 5] (referring to their original 1-based indices after sorting by arrival time, then by original index).</li>\r\n    <li>The third request (original index 2, arrival 1, burst 10) is assigned to server 1 and it remains busy until time 11 (1+10).</li>\r\n    <li>The first request (original index 0, arrival 3, burst 9) is assigned to server 2 which remains busy until 12 (3+9).</li>\r\n    <li>The second request (original index 1, arrival 5, burst 2) is assigned to server 3 which remains busy until 7 (5+2).</li>\r\n    <li>The fourth request (original index 3, arrival 6, burst 4) is assigned to server 4 which remains busy until 10 (6+4).</li>\r\n    <li>When the fifth request (original index 4, arrival 8, burst 5) arrives, the third server is free (at time 7) and the request is assigned to it. Server 3 remains busy until 13 (8+5).</li>\r\n</ul>\r\n</p>\r\n\r\n<h3>Example 3:</h3>\r\n<pre><code class='language-text'>Input:\r\nn = 2\r\narrival = [2, 2, 2, 3]\r\nburstTime = [1, 3, 1, 2]\r\nOutput: [1, 2, -1, 1]</code></pre>\r\n<p><strong>Explanation:</strong>\r\n<ul>\r\n    <li>The first three requests arrive at the same time (time 2).</li>\r\n    <li>The requests are picked in order (by original index) and the first two requests are assigned to server 1 and server 2, respectively.\r\n        <ul>\r\n            <li>Request 0 (arrival 2, burst 1) to Server 1. Server 1 busy until 2+1=3.</li>\r\n            <li>Request 1 (arrival 2, burst 3) to Server 2. Server 2 busy until 2+3=5.</li>\r\n        </ul>\r\n    </li>\r\n    <li>Since no server is available to process the third request (original index 2, arrival 2, burst 1) at time 2, it is dropped.</li>\r\n    <li>Finally, the first server becomes free at 3 and can take up the last request (original index 3, arrival 3, burst 2). Server 1 busy until 3+2=5.</li>\r\n</ul>\r\n</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>1 <= n <= 10<sup>5</sup></code></li>\r\n    <li><code>1 <= m <= 10<sup>5</sup></code></li>\r\n    <li><code>1 <= arrival[i] <= 10<sup>9</sup></code></li>\r\n    <li><code>1 <= burstTime[i] <= 10<sup>9</sup></code></li>\r\n</ul>",
        "google_doc_link": null,
        "solution_code": null,
        "company_name": "Atlassian_24july",
        "company_id": 239
    },
    {
        "id": 756,
        "title": "Get Process Time",
        "problem_statement": "<h1>Get Process Time</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>Consider a dual-core processor where each core has its own process queue. There are n processes, and the time required to process the ith process is represented by time[i] (1 <= i <= n). A latch determines which core processes each task. Initially, the first core holds the latch. If the latch is with core c (where c is either 1 or 2) and process i needs to be assigned, one of the following actions must occur:</p>\r\n<ol>\r\n    <li>Process i is assigned to core c, and the latch passes to the other core.</li>\r\n    <li>Process i is assigned to the other core, and core c retains the latch.</li>\r\n</ol>\r\n<p>Each core aims to maximize the total sum of processing times for its assigned tasks. The core holding the latch decides how each process is assigned to maximize its total processing time.</p>\r\n<p>Determine the sum of processing times for tasks assigned to the first and second cores when both cores operate optimally. Return an array of two integers where the first integer is the sum of processing times for the first core, and the second integer is the sum for the second core.</p>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input: n = 5, time = [10, 21, 10, 21, 10]\r\nOutput: [41, 31]</code></pre>\r\n<p><strong>Explanation:</strong></p>\r\n<p>A possible assignment:</p>\r\n<ul>\r\n    <li>Latch 1, Process 1 (time 10) assigned to 2nd core, New Latch 1.</li>\r\n    <li>Latch 1, Process 2 (time 21) assigned to 1st core, New Latch 2.</li>\r\n    <li>Latch 2, Process 3 (time 10) assigned to 1st core, New Latch 2.</li>\r\n    <li>Latch 2, Process 4 (time 21) assigned to 2nd core, New Latch 1.</li>\r\n    <li>Latch 1, Process 5 (time 10) assigned to 2nd core, New Latch 1.</li>\r\n</ul>\r\n<p>Hence, the total time of processes for the first core is (21 + 10 + 21) = 52, and the total time of processes for the second core is (10 + 10) = 20. The given assignment is not optimal, as for the fourth process, the second core assigned the process with process time = 21 to core 1 and got the fifth process with process time = 10, which is not an optimal move by core 2.</p>\r\n<p>An optimal assignment is shown:</p>\r\n<ul>\r\n    <li>Latch 1, Process 1 (time 10) assigned to 2nd core, New Latch 1.</li>\r\n    <li>Latch 1, Process 2 (time 21) assigned to 1st core, New Latch 2.</li>\r\n    <li>Latch 2, Process 3 (time 10) assigned to 1st core, New Latch 2.</li>\r\n    <li>Latch 2, Process 4 (time 21) assigned to 2nd core, New Latch 1.</li>\r\n    <li>Latch 1, Process 5 (time 10) assigned to 1st core, New Latch 2.</li>\r\n</ul>\r\n<p>The optimal move by the second core is to assign the fourth process to itself and the fifth process to core 1. Hence, the total time of processes for the first core is (10 + 21 + 10) = 41, and for the second core, it is (10 + 21) = 31. Return the answer array, [41, 31].</p>\r\n\r\n<h3>Sample Case 0:</h3>\r\n<pre><code class='language-text'>Input: n = 4, time = [10, 10, 10, 10]\r\nOutput:\r\n20\r\n20</code></pre>\r\n<p><strong>Explanation:</strong> One optimal assignment is:</p>\r\n<ul>\r\n    <li>Latch 1, Process 1 (time 10) assigned to 1st core, New Latch 2.</li>\r\n    <li>Latch 2, Process 2 (time 10) assigned to 2nd core, New Latch 1.</li>\r\n    <li>Latch 1, Process 3 (time 10) assigned to 1st core, New Latch 2.</li>\r\n    <li>Latch 2, Process 4 (time 10) assigned to 2nd core, New Latch 1.</li>\r\n</ul>\r\n<p>The total time of processes for both cores is 20.</p>\r\n\r\n<h3>Sample Case 1:</h3>\r\n<pre><code class='language-text'>Input: n = 2, time = [5, 3]\r\nOutput:\r\n5\r\n3</code></pre>\r\n<p><strong>Explanation:</strong> The first core will take process 1, and the latch is given to the second core. Then the second core takes process 2.</p>\r\n\r\n<h2>Function Description</h2>\r\n<p>Complete the function `getProcessTime` in the editor with the following parameters:</p>\r\n<pre><code class='language-javascript'>int time[n]: the processing time required for each process</code></pre>\r\n<p><strong>Returns:</strong></p>\r\n<pre><code class='language-javascript'>long[2]: the sums of the processing times of the first and second cores</code></pre>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>1 &lt;= n &lt;= 10^5</code></li>\r\n    <li><code>1 &lt;= time[i] &lt;= 10^9</code></li>\r\n</ul>",
        "google_doc_link": null,
        "solution_code": null,
        "company_name": "Atlassian_24july",
        "company_id": 239
    }
]