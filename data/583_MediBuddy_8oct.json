[
    {
        "id": 1672,
        "title": "First Word",
        "problem_statement": "```html\r\n<h1>First Word</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>You are playing a word game called \"First Word\" with your family. Each player receives a string S of length N.</p>\r\n<p>The goal of the game is to minimize your score by rearranging the string. The rearrangement is done using the following operation, which you may apply any number of times:</p>\r\n<ul>\r\n    <li>From the first K characters of the string, choose one letter, remove it from its position, and append it to the end of the string.</li>\r\n</ul>\r\n<p>After rearranging the String S, you need to calculate the points using the following formula:</p>\r\n<ul>\r\n    <li>Points = Σ<sub>i=0</sub><sup>N-1</sup> Position(S[i]) * (N - i) - 1 (indexing starts from 0)</li>\r\n    <li>Where Position[x] is the index of S in English alphabets (a=1, b=2, c=3, ..., y=25, z=26).</li>\r\n</ul>\r\n<p>It is not necessary to rearrange the string S if you are getting the minimum points using the current sequence of S. You can perform the above operation any number of times.</p>\r\n<p>Return the minimum number of points you can get after rearranging the given string S.</p>\r\n\r\n<h3>Function Description</h3>\r\n<p>Complete the <code>solve()</code> function. This function takes the following 3 arguments and returns the minimum number of points you can get after rearranging the given string S.</p>\r\n\r\n<h3>Parameters</h3>\r\n<ul>\r\n    <li><strong>N:</strong> Represents the total length of string S.</li>\r\n    <li><strong>K:</strong> Represents the value of K for the given operation.</li>\r\n    <li><strong>S:</strong> Represents the string to be rearranged.</li>\r\n</ul>\r\n\r\n<h3>Input format for custom testing</h3>\r\n<p><strong>Note:</strong> Use this input format if you are testing against custom input or writing code in a language where we don't provide boilerplate code.</p>\r\n<ul>\r\n    <li>The first line contains an integer N denoting the total length of string S.</li>\r\n    <li>The second line contains an integer K denoting the value of K for the given operation.</li>\r\n    <li>The third line contains a string S denoting the string to be rearranged.</li>\r\n</ul>\r\n\r\n<h3>Output format</h3>\r\n<p>Return an integer representing the minimum number of points you can get after rearranging the given string S.</p>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input:\r\n3\r\n1\r\ncba\r\nOutput:\r\n11</code></pre>\r\n<p><strong>Explanation:</strong></p>\r\n<p><strong>Approach:</strong></p>\r\n<p>K=1, therefore you can take the first character of string S and append it to the end of the string S.</p>\r\n<ul>\r\n    <li>Operation 1 -> S=\"cba\" => select 'c' and append it to the end of S => S=\"bac\"</li>\r\n    <li>Operation 2 -> S=\"bac\" => select 'b' and append it to the end of S => S=\"acb\"</li>\r\n</ul>\r\n<p>Position('a')=1, Position('c')=3, Position('b')=2</p>\r\n<p>According to the problem's scoring formula, for S=\"acb\" (N=3), the points are calculated as:</p>\r\n<p>Points = Σ<sub>i=0</sub><sup>N-1</sup> Position(S[i]) * (N - i)</p>\r\n<p>Points = (Position('a') * (3 - 0)) + (Position('c') * (3 - 1)) + (Position('b') * (3 - 2))</p>\r\n<p>Points = (1 * 3) + (3 * 2) + (2 * 1) = 3 + 6 + 2 = 11</p>\r\n<p><em>(Note: The general formula provided in the problem description includes a \"-1\" at the end, i.e., <code>Σ Position(S[i]) * (N - i) - 1</code>. However, the sample output of 11 is achieved by the sum part <code>Σ Position(S[i]) * (N - i)</code>, implying the \"-1\" might be a typo in the description.)</em></p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>1 &lt;= N &lt;= 1000</code></li>\r\n    <li><code>1 &lt;= K &lt;= N</code></li>\r\n    <li><code>S consists of lowercase English letters.</code></li>\r\n</ul>\r\n```",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <vector>\n#include <string>\n#include <numeric>\n#include <algorithm>\n\nclass Solution {\npublic:\n    long long solve(int N, int K, std::string S) {\n        // Core logic goes here\n        return 0;\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n    int N;\n    std::cin >> N;\n    int K;\n    std::cin >> K;\n    std::string S;\n    std::cin >> S;\n\n    Solution solution;\n    long long result = solution.solve(N, K, S);\n    std::cout << result << std::endl;\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "MediBuddy_8oct",
        "company_id": 583
    },
    {
        "id": 1673,
        "title": "Debugging - Maximum Weight Path in Directed Network",
        "problem_statement": "<h1>Debugging - Maximum Weight Path in Directed Network</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>You have a buggy implementation for the following problem in the <code>longestPathInDAG</code> function. The current solution does not pass test cases due to errors in the code. Your job is to locate and correct all bugs to make it work for all test cases.</p>\r\n\r\n<h3>Statement</h3>\r\n<p>You have a <strong>Directed Acyclic Network</strong> with N nodes and M connections. Each connection has a value attached to it. You must find the maximum weight path from any node to any other node in the network. The path can go through several nodes, but it must follow the direction of the network connections.</p>\r\n<p>You can assume that the network is directed and has no loops. Your job is to find the total weight of the maximum path.</p>\r\n\r\n<h3>Function Description</h3>\r\n<p>You need to complete the function <code>longestPathInDAG</code>.</p>\r\n<p><strong>Parameters:</strong></p>\r\n<ul>\r\n    <li>N: An integer showing the number of nodes in the network.</li>\r\n    <li>M: An integer showing the number of connections in the network.</li>\r\n    <li>edges: A list of M tuples, where each tuple has three numbers u, v, and w showing a connection from node u to node v with...</li>\r\n</ul>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nclass Solution {\npublic:\n    /**\n     * @param N An integer showing the number of nodes in the network.\n     * @param M An integer showing the number of connections in the network.\n     * @param edges A list of M tuples, where each tuple has three numbers u, v, and w\n     *              showing a connection from node u to node v with weight w.\n     * @return The total weight of the maximum path.\n     */\n    long long longestPathInDAG(int N, int M, const std::vector<std::vector<int>>& edges) {\n        // Core logic to find the longest path in a Directed Acyclic Graph (DAG)\n        // will be implemented here.\n        // The path can start and end at any node.\n        return 0;\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    int N, M;\n    std::cin >> N >> M;\n\n    std::vector<std::vector<int>> edges(M, std::vector<int>(3));\n    for (int i = 0; i < M; ++i) {\n        std::cin >> edges[i][0] >> edges[i][1] >> edges[i][2];\n    }\n\n    Solution sol;\n    long long result = sol.longestPathInDAG(N, M, edges);\n\n    std::cout << result << std::endl;\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "MediBuddy_8oct",
        "company_id": 583
    },
    {
        "id": 1674,
        "title": "Longest Path in Network",
        "problem_statement": "<h1>Longest Path in Network</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>You need to complete the function `longestPathInDAG()`.</p>\r\n\r\n<p><strong>Parameters:</strong></p>\r\n<ul>\r\n    <li>N: An integer showing the number of nodes in the network.</li>\r\n    <li>M: An integer showing the number of connections in the network.</li>\r\n    <li>edges: A list of M tuples, where each tuple has three numbers u, v, and w showing a connection from node u to node v with value w.</li>\r\n</ul>\r\n\r\n<p><strong>Return:</strong></p>\r\n<p>A single number showing the total weight of the maximum path in the network. If no path exists, return 0.</p>\r\n\r\n<p><strong>Input Format:</strong></p>\r\n<ul>\r\n    <li>The first line has a number N, showing the number of nodes in the network.</li>\r\n    <li>The second line has a number M, showing the number of connections in the network.</li>\r\n    <li>The next M lines have three space-separated numbers u, v, and w showing a connection from node u to node v with value w.</li>\r\n</ul>\r\n\r\n<p><strong>Output Format:</strong></p>\r\n<p>A single number showing the total weight of the maximum path in the network. If no path exists, return 0.</p>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input:\r\n4\r\n5\r\n1 2 5\r\n2 3 10\r\n1 3 15\r\n3 4 10\r\n2 4 20\r\nOutput:\r\n25</code></pre>\r\n<p><strong>Explanation:</strong> In this graph, the longest path is 1 -> 2 -> 4 with the total weight of 5 + 20 = 25.</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li>1 &lt;= N &lt;= 10<sup>5</sup></li>\r\n    <li>1 &lt;= M &lt;= 10<sup>5</sup></li>\r\n    <li>10<sup>3</sup> &lt;= w &lt;= 10<sup>5</sup></li>\r\n</ul>\r\n\r\n<h2>Note</h2>\r\n<p>Your code must be able to print the sample output from the provided sample input. However, your code is run against multiple hidden test cases. Therefore, your code must pass these hidden test cases to solve the problem statement.</p>\r\n\r\n<p><strong>Limits:</strong></p>\r\n<ul>\r\n    <li>Time Limit: 5.0 sec(s) for each input file</li>\r\n    <li>Memory Limit: 256 MB</li>\r\n    <li>Source Limit: 1024 KB</li>\r\n</ul>\r\n\r\n<p><strong>Scoring:</strong></p>\r\n<p>Score is assigned if any testcase passes.</p>\r\n\r\n<p><strong>Allowed Languages:</strong></p>\r\n<p>Bash, C, C++14, C++17, Clojure, C#, D, Erlang, F#, Go, Groovy, Haskell, Java 8, Java 14, JavaScript(Node.js), Julia, Kotlin, Lisp (SBCL), Lua, Objective-C, OCaml, Octave, Pascal, Perl, PHP, Python, Python 3, Python 3.8, Racket, Ruby, Rust, Scala, Swift, TypeScript, Visual Basic</p>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <tuple>\n\nclass Solution {\npublic:\n    /**\n     * @param N An integer showing the number of nodes in the network.\n     * @param M An integer showing the number of connections in the network.\n     * @param edges A list of M tuples, where each tuple has three numbers u, v, and w\n     *              showing a connection from node u to node v with value w.\n     * @return A single number showing the total weight of the maximum path in the network.\n     */\n    int longestPathInDAG(int N, int M, const std::vector<std::vector<int>>& edges) {\n        // Your implementation for finding the longest path in a DAG goes here.\n        // This typically involves:\n        // 1. Building an adjacency list representation of the graph.\n        // 2. Performing a topological sort of the nodes.\n        // 3. Iterating through the topologically sorted nodes and calculating the\n        //    longest distance to each node using dynamic programming.\n        \n        return 0; // Placeholder return\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    int N;\n    std::cin >> N;\n\n    int M;\n    std::cin >> M;\n\n    std::vector<std::vector<int>> edges(M, std::vector<int>(3));\n    for (int i = 0; i < M; ++i) {\n        std::cin >> edges[i][0] >> edges[i][1] >> edges[i][2];\n    }\n\n    Solution sol;\n    int result = sol.longestPathInDAG(N, M, edges);\n\n    std::cout << result << std::endl;\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "MediBuddy_8oct",
        "company_id": 583
    }
]