[
    {
        "id": 1787,
        "title": "People Aware of Feature",
        "problem_statement": "<h1>People Aware of Feature</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>A new in-app feature launches on day 1 and one early adopter learns about it.</p>\r\n<p>A user who learns the feature on day <code>d</code> starts telling others from day <code>(d + delay)</code> and forgets (stops knowing and stops sharing) from day <code>(d + forgetAfter)</code>.</p>\r\n<p>Each day, every user who is currently in their \"sharing window\" tells exactly one new user (who learns that day).</p>\r\n<p>Given the number of days <code>n</code>, return how many users still know the feature on day <code>n</code>. Since the number can be large, return it modulo 1,000,000,007.</p>\r\n\r\n<h3>Input Format:</h3>\r\n<ul>\r\n    <li>Integer <code>n</code> - total days to simulate</li>\r\n    <li>Integer <code>delay</code> - days after learning when a user starts sharing</li>\r\n    <li>Integer <code>forgetAfter</code> - days after learning when a user forgets</li>\r\n</ul>\r\n\r\n<h3>Output Format:</h3>\r\n<p>Single integer - users who still know the feature on day <code>n</code> (mod 1e9+7)</p>\r\n\r\n<h2>Examples</h2>\r\n\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input: n=6, delay=2, forgetAfter=4\r\nOutput: 5</code></pre>\r\n<p><strong>Explanation:</strong></p>\r\n<ul>\r\n    <li>Day 1: Suppose the first person is named A. (1 person)</li>\r\n    <li>Day 2: A is the only person who knows the secret. (1 person)</li>\r\n    <li>Day 3: A shares the secret with a new person, B. (2 people)</li>\r\n    <li>Day 4: A shares the secret with a new person, C. (3 people)</li>\r\n    <li>Day 5: A forgets the secret, and B shares the secret with a new person, D. (3 people)</li>\r\n    <li>Day 6: B shares the secret with E, and C shares the secret with F. (5 people)</li>\r\n</ul>\r\n\r\n<h3>Example 2:</h3>\r\n<pre><code class='language-text'>Input: n=4, delay=1, forgetAfter=3\r\nOutput: 6</code></pre>\r\n<p><strong>Explanation:</strong> Fast sharing and slower forgetting increase totals.</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>1 &lt;= n &lt;= 1000</code></li>\r\n    <li><code>1 &lt;= delay &lt; forgetAfter &lt;= n</code></li>\r\n</ul>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <vector>\n#include <string>\n#include <numeric>\n#include <algorithm>\n\nclass Solution {\npublic:\n    int peopleAwareOfFeature(int n, int delay, int forgetAfter) {\n        // Core logic goes here\n        return 0; // Placeholder\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    int n;\n    int delay;\n    int forgetAfter;\n\n    std::cin >> n >> delay >> forgetAfter;\n\n    Solution solution;\n    int result = solution.peopleAwareOfFeature(n, delay, forgetAfter);\n\n    std::cout << result << std::endl;\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "Kickdrum_13oct",
        "company_id": 630
    },
    {
        "id": 1788,
        "title": "Wi-Fi Coverage Zone Counter",
        "problem_statement": "<h1>Wi-Fi Coverage Zone Counter</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>A network administrator needs to analyze Wi-Fi coverage in a building represented by a grid. Each cell shows whether there's signal coverage ('T') or no coverage ('O'). Connected coverage areas form a single Wi-Fi zone. Count how many separate Wi-Fi zones exist in the building.</p>\r\n\r\n<h2>Input Format</h2>\r\n<p><strong>Input:</strong></p>\r\n<ul>\r\n    <li>'m' number of rows in the grid</li>\r\n    <li>'n' number of columns in the grid</li>\r\n    <li>A 2D grid where:\r\n        <ul>\r\n            <li>'T' represents areas with Wi-Fi coverage</li>\r\n            <li>'O' represents areas without Wi-Fi coverage</li>\r\n            <li>Adjacent coverage areas (horizontally or vertically) belong to the same zone</li>\r\n        </ul>\r\n    </li>\r\n</ul>\r\n\r\n<h2>Output Format</h2>\r\n<p><strong>Output:</strong> The total number of separate Wi-Fi zones</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li>Grid dimensions: 1 &lt;= m, n &lt;= 300</li>\r\n    <li>Grid contains only 'O' and 'T' characters</li>\r\n</ul>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input:\r\n5\r\n4\r\nTTTO\r\nTTOT\r\nTTOO\r\nOOOO\r\nOOOO\r\nOutput: 1</code></pre>\r\n<p><strong>Explanation:</strong> All 'T's are connected horizontally or vertically, forming one large Wi-Fi zone.</p>\r\n\r\n<h3>Example 2:</h3>\r\n<pre><code class='language-text'>Input:\r\n5\r\n4\r\nTTOO\r\nTTOO\r\nOOTO\r\nOOOT\r\nOOOO\r\nOutput: 3</code></pre>\r\n<p><strong>Explanation:</strong> Zone 1: Top-left connected coverage area (4 cells). (Implies there are 3 distinct zones in total).</p>\r\n\r\n<h3>Example 3:</h3>\r\n<pre><code class='language-text'>Input:\r\n3\r\n5\r\nTOTOT\r\nTTTOT\r\nTTTOT\r\nOutput: 1</code></pre>\r\n<p><strong>Explanation:</strong> All coverage areas are connected through various paths, forming one zone.</p>\r\n\r\n<pre><code class='language-cpp'>#include &lt;bits/stdc++.h&gt;\r\nusing namespace std;\r\n\r\n// Problem: Wi-Fi Coverage Zone Counter\r\nint wifiCoverageZoneCounter(vector&lt;vector&lt;char&gt;&gt; &amp;grid) {\r\n    // Your code here\r\n    return 0;\r\n}\r\n\r\nint main() {\r\n    int m, n;\r\n    cin &gt;&gt; m &gt;&gt; n;\r\n    vector&lt;vector&lt;char&gt;&gt; grid(m, vector&lt;char&gt;(n));\r\n    for (int i = 0; i &lt; m; i++) {\r\n        for (int j = 0; j &lt; n; j++) {\r\n            cin &gt;&gt; grid[i][j];\r\n        }\r\n    }\r\n    cout &lt;&lt; wifiCoverageZoneCounter(grid);\r\n    return 0;\r\n}\r\n</code></pre>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <vector>\n#include <string>\n\nclass Solution {\npublic:\n    /**\n     * @brief Counts the number of separate Wi-Fi zones in a grid.\n     * \n     * @param grid A 2D vector of characters representing the building layout.\n     *             'T' denotes Wi-Fi coverage, 'O' denotes no coverage.\n     * @return The total number of separate Wi-Fi zones.\n     */\n    int wifiCoverageZoneCounter(std::vector<std::vector<char>>& grid) {\n        // Core logic to count connected components of 'T's will go here.\n        // A common approach is to iterate through the grid.\n        // When a 'T' is found, increment a counter and start a traversal (DFS or BFS)\n        // to find all connected 'T's, marking them as visited (e.g., changing them to 'O').\n        return 0;\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    int m, n;\n    std::cin >> m >> n;\n\n    std::vector<std::vector<char>> grid(m, std::vector<char>(n));\n    for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < n; ++j) {\n            std::cin >> grid[i][j];\n        }\n    }\n\n    Solution sol;\n    int result = sol.wifiCoverageZoneCounter(grid);\n\n    std::cout << result << std::endl;\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "Kickdrum_13oct",
        "company_id": 630
    },
    {
        "id": 1789,
        "title": "Design a Class Hierarchy for a Multi-level Parking Lot System",
        "problem_statement": "<h1>Design a Class Hierarchy for a Multi-level Parking Lot System</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>Design a class hierarchy for a Multi-level Parking Lot System.</p>\r\n\r\n<p><strong>Requirements:</strong></p>\r\n<ul>\r\n    <li>Create a class hierarchy showing all <strong>4 pillars of OOPS</strong>.</li>\r\n    <li>Write <strong>ONLY</strong> class names, fields, and method signatures (no implementation needed).</li>\r\n    <li><strong>Your system should handle:</strong>\r\n        <ul>\r\n            <li>Different types of vehicles (Bike, Car, Bus, etc)</li>\r\n            <li>Different types of parking spots (Small, Medium, Large) and facilities</li>\r\n            <li>Entry ticket and payment calculation</li>\r\n        </ul>\r\n    </li>\r\n</ul>\r\n\r\n<h2>Guidelines</h2>\r\n<ul>\r\n    <li><strong>Time is limited</strong> - Focus on demonstrating OOP concepts, not perfect syntax</li>\r\n    <li><strong>Vision over perfection</strong> - We want to see how you think about design, not compile-ready code</li>\r\n    <li><strong>Use any format</strong> - Pseudocode, Java, C++, or even structured English is fine</li>\r\n    <li><strong>Explain your thinking</strong> - Feel free to add comments like \"// This shows inheritance\" or write a line explaining your design choice.</li>\r\n    <li><strong>Don't get stuck on syntax</strong> - If unsure about exact syntax, write what you mean in plain English</li>\r\n    <li><strong>Quality over quantity</strong> - Better to have 4-5 well-designed classes showing all OOP pillars and full-filling the three requirements than 10 classes with no clear structure</li>\r\n</ul>\r\n\r\n<h2>Follow-up</h2>\r\n<p><strong>Remember:</strong> We're evaluating your understanding of OOP concepts, not your memorization of syntax. Show us how these classes relate to each other and why you made these design decisions.</p>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <vector>\n#include <string>\n#include <memory>\n#include <chrono>\n#include <unordered_map>\n\n// --- Class Hierarchy for Parking Lot System ---\n\n// Forward declarations\nclass Vehicle;\nclass ParkingSpot;\nclass Ticket;\n\n// Abstraction: Vehicle is an abstract base class representing the concept of a vehicle.\n// It defines a common interface for all vehicle types.\nclass Vehicle {\nprotected:\n    // Encapsulation: Data members are private/protected to hide internal state.\n    std::string licensePlate;\n\npublic:\n    Vehicle(const std::string& plate) : licensePlate(plate) {}\n    virtual ~Vehicle() = default;\n\n    std::string getLicensePlate() const {\n        return licensePlate;\n    }\n\n    // Polymorphism: This virtual function will be implemented differently by derived classes.\n    virtual std::string getType() const = 0; // Pure virtual function makes Vehicle abstract.\n};\n\n// Inheritance: Bike, Car, and Bus are types of Vehicles. They inherit common properties\n// and behaviors from the Vehicle base class.\nclass Bike : public Vehicle {\npublic:\n    Bike(const std::string& plate) : Vehicle(plate) {}\n    std::string getType() const override {\n        return \"Bike\";\n    }\n};\n\nclass Car : public Vehicle {\npublic:\n    Car(const std::string& plate) : Vehicle(plate) {}\n    std::string getType() const override {\n        return \"Car\";\n    }\n};\n\nclass Bus : public Vehicle {\npublic:\n    Bus(const std::string& plate) : Vehicle(plate) {}\n    std::string getType() const override {\n        return \"Bus\";\n    }\n};\n\n// Abstraction: ParkingSpot is an abstract base class for different spot types.\nclass ParkingSpot {\nprotected:\n    // Encapsulation\n    int spotId;\n    bool isOccupied;\n    std::shared_ptr<Vehicle> parkedVehicle;\n\npublic:\n    ParkingSpot(int id) : spotId(id), isOccupied(false), parkedVehicle(nullptr) {}\n    virtual ~ParkingSpot() = default;\n\n    bool isAvailable() const;\n    void assignVehicle(std::shared_ptr<Vehicle> vehicle);\n    void removeVehicle();\n    int getId() const;\n\n    // Polymorphism: Allows treating all spot types uniformly while getting their specific type.\n    virtual std::string getSpotType() const = 0;\n};\n\n// Inheritance: Specific spot types inherit from the base ParkingSpot class.\nclass SmallSpot : public ParkingSpot {\npublic:\n    SmallSpot(int id) : ParkingSpot(id) {}\n    std::string getSpotType() const override {\n        return \"Small\";\n    }\n};\n\nclass MediumSpot : public ParkingSpot {\npublic:\n    MediumSpot(int id) : ParkingSpot(id) {}\n    std::string getSpotType() const override {\n        return \"Medium\";\n    }\n};\n\nclass LargeSpot : public ParkingSpot {\npublic:\n    LargeSpot(int id) : ParkingSpot(id) {}\n    std::string getSpotType() const override {\n        return \"Large\";\n    }\n};\n\nclass Ticket {\nprivate:\n    // Encapsulation\n    int ticketId;\n    std::chrono::system_clock::time_point entryTime;\n    std::chrono::system_clock::time_point exitTime;\n    std::shared_ptr<Vehicle> vehicle;\n    std::shared_ptr<ParkingSpot> parkingSpot;\n\npublic:\n    Ticket(int id, std::shared_ptr<Vehicle> v, std::shared_ptr<ParkingSpot> spot);\n    void setExitTime(std::chrono::system_clock::time_point time);\n    double calculatePrice() const;\n};\n\n// This class demonstrates Composition, as it is composed of other objects (levels, spots).\nclass ParkingLot {\nprivate:\n    // Encapsulation\n    std::vector<std::vector<std::shared_ptr<ParkingSpot>>> levels;\n    std::unordered_map<std::string, std::shared_ptr<Ticket>> activeTickets;\n    static int ticketCounter;\n\npublic:\n    ParkingLot(int numLevels, int smallSpots, int mediumSpots, int largeSpots);\n    std::shared_ptr<Ticket> issueTicket(std::shared_ptr<Vehicle> vehicle);\n    double processExit(const std::string& licensePlate);\n};\n\n\n// --- Competitive Programming Boilerplate ---\n\nclass Solution {\npublic:\n    /**\n     * In a real competitive programming problem based on this design,\n     * this method would take parsed input and run a simulation.\n     * For example, it might take a list of entry/exit events.\n     */\n    void solve() {\n        // The core logic for this problem is the class design itself.\n        // In a problem with execution, one would instantiate and use the\n        // ParkingLot system here based on the input.\n        // For example:\n        // ParkingLot lot(3, 10, 20, 5);\n        // auto car = std::make_shared<Car>(\"ABC-123\");\n        // lot.issueTicket(car);\n        // ...\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    // The problem statement is a design question, not a typical I/O problem.\n    // This main function serves as a standard competitive programming entry point.\n    // We can assume a single execution for this design problem.\n    // For multiple test cases, the loop can be used.\n    // int t;\n    // std::cin >> t;\n    // while (t--) {\n        Solution solution;\n        \n        // No specific input is defined in the problem, so we call solve() directly.\n        // In a real problem, you would parse input here and pass it to the solve method.\n        solution.solve();\n\n        // The problem does not specify an output.\n        // We print a confirmation message as a placeholder.\n        std::cout << \"Class hierarchy design complete.\" << std::endl;\n    // }\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "Kickdrum_13oct",
        "company_id": 630
    }
]