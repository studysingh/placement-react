[
    {
        "id": 1651,
        "title": "Identify Repeated Scores",
        "problem_statement": "<h1>Identify Repeated Scores</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>During a school sports day event, students recorded their scores. However, some students accidentally recorded the same score multiple times. Your task is to help the event organizer identify all scores that are repeated and determine the indices where each duplicate occurs.</p>\r\n<p>You are given an integer N, representing the number of students, followed by a list of their scores. For each score that is repeated, output the score, followed by the letter 'I', and then the indices where the score appears. If no duplicates are found, return -1.</p>\r\n\r\n<h2>Input Format</h2>\r\n<p>The first line contains an integer N â€“ the number of students.</p>\r\n<p>The next N lines each contain an integer, representing a score recorded by a student.</p>\r\n\r\n<h2>Output Format</h2>\r\n<p>For each score that appears more than once, print the score, followed by the letter 'I', and then the indices where the score appears, separated by spaces. If no scores are repeated, output -1.</p>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input:\r\n5\r\n1\r\n1\r\n2\r\n3\r\n5\r\nOutput:\r\n1 I 0 1</code></pre>\r\n<p><strong>Explanation:</strong> The first line represents the number of students (5), followed by their scores. The scores recorded are: 1, 1, 2, 3, and 5.</p>\r\n<p>The score 1 is repeated twice at indices 0 and 1.</p>\r\n<p>The score 2 is unique and not repeated.</p>\r\n<p>The score 3 is unique and not repeated.</p>\r\n<p>The score 5 is unique and not repeated.</p>\r\n<p>Therefore, the output lists the repeated scores along with the letter 'I' followed by the indices.</p>\r\n\r\n<h3>Example 2:</h3>\r\n<pre><code class='language-text'>Input:\r\n7\r\n100\r\n200\r\n100\r\n300\r\n400\r\n300\r\n500\r\nOutput:\r\n300 I 3 5\r\n100 I 0 2</code></pre>\r\n<p><strong>Explanation:</strong> In the given input, there are 7 students, and their scores are recorded as: 100, 200, 100, 300, 400, 300, and 500. The goal is to identify which scores are repeated and display their corresponding indices.</p>\r\n<p>The score 100 appears twice, once at index 0 and again at index 2. Similarly, the score 300 also appears twice, at indices 3 and 5. Since both 100 and 300 have duplicates, they are listed in the output alongside the indices.</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n<li><code>0 <= N <= 10^3</code></li>\r\n<li><code>0 <= score <= 10^3</code></li>\r\n</ul>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <sstream>\n#include <algorithm>\n\nclass Solution {\npublic:\n    /**\n     * @brief Identifies repeated scores and their indices.\n     * @param scores A vector of integers representing the scores.\n     * @return A vector of strings, where each string represents a repeated score and its indices.\n     *         Returns an empty vector if no scores are repeated.\n     */\n    std::vector<std::string> findRepeatedScores(const std::vector<int>& scores) {\n        // Core logic to find repeated scores and their indices goes here.\n        // The result should be a vector of strings, each formatted as \"score I index1 index2 ...\".\n        // For example: {\"1 I 0 1\", \"300 I 3 5\"}\n        return {};\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    int n;\n    std::cin >> n;\n\n    std::vector<int> scores(n);\n    for (int i = 0; i < n; ++i) {\n        std::cin >> scores[i];\n    }\n\n    Solution sol;\n    std::vector<std::string> result = sol.findRepeatedScores(scores);\n\n    if (result.empty()) {\n        std::cout << -1 << std::endl;\n    } else {\n        for (const auto& line : result) {\n            std::cout << line << std::endl;\n        }\n    }\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "Societe_Generale_7Oct",
        "company_id": 576
    },
    {
        "id": 1653,
        "title": "Cyber Codex Decoding",
        "problem_statement": "<h1>Cyber Codex Decoding</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>In a futuristic world, secret agents use a Cyber Codex to encrypt mission codes. Each encrypted code consists of lowercase letters (a-z), digits (0-9), and unique special symbols, namely '&', '@', and '!'. Used for encoding complex patterns. Your task is to decode these encrypted messages.</p>\r\n\r\n<p>The encryption follows these rules:</p>\r\n<ol>\r\n    <li><strong>Character Mapping:</strong> Each lowercase letter is mapped to a unique lowercase letter in a shuffled alphabet provided as a \"key string.\" This key string is a 26-character string where the Ith character of the key maps to the Ith letter of the English alphabet (e.g., if the key is \"qwerty...\", then 'a' maps to 'q', 'b' maps to 'w', etc.).</li>\r\n    <li><strong>Repetition Indicator (&):</strong> When the symbol '&' appears, it indicates that the next lowercase character should repeat as many times as specified by the digit immediately preceding it (from 0-9).</li>\r\n    <li><strong>Substring Swapper (@):</strong> A substring surrounded by '@' symbols is to be swapped with its reverse. For example, `@abcd@` becomes `dcba` and then mapped accordingly.</li>\r\n    <li><strong>Prefix Modifier (!):</strong> If the '!' symbol appears at the start of the message, the first character (after '!') is modified to uppercase in the output.</li>\r\n</ol>\r\n<p><strong>Note:</strong> The message string contains any combination of lowercase letters (a-z), digits (0-9), and special symbols '&', '@', and '!'. The key length will be 26 characters.</p>\r\n\r\n<h2>Input Format</h2>\r\n<p>The first line consists of a string representing the key for mapping (26 lowercase letters with no duplicates).</p>\r\n<p>The second line consists of an encrypted message containing lowercase letters, digits, &, @, and !.</p>\r\n\r\n<h2>Output Format</h2>\r\n<p>Print the decoded message by following the encryption rules.</p>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input:\r\nqwertyuiopasdfghjklzxcvbnm\r\n!a&7m@cx@\r\nOutput:\r\nQddddddbe</code></pre>\r\n<p><strong>Explanation:</strong></p>\r\n<ul>\r\n    <li><strong>Secret Key:</strong> <code>qwertyuiopasdfghjklzxcvbnm</code> (maps the alphabet to a specific jumbled sequence: a -> q, b -> w, ..., z -> m)</li>\r\n    <li><strong>Encrypted Message:</strong> <code>!a&7m@cx@</code></li>\r\n    <li><strong>Decoding Steps:</strong>\r\n        <ul>\r\n            <li><strong>Prefix Modifier !:</strong> The '!' at the start indicates the first decoded character should be capitalized.</li>\r\n            <li><code>a</code> maps to <code>q</code> (from key mapping).</li>\r\n            <li><code>&7m</code>: The digit '7' precedes '&', indicating the next character 'm' should be repeated 7 times. <code>m</code> maps to <code>d</code>. So, <code>m</code> repeated 7 times becomes <code>ddddddd</code>.</li>\r\n            <li><code>@cx@</code>: The substring between '@' symbols is `cx`.\r\n                <ul>\r\n                    <li>First, reverse `cx` to `xc`.</li>\r\n                    <li>Then, map each character: `x` maps to `b`, `c` maps to `e`.</li>\r\n                    <li>So, `xc` maps to `be`.</li>\r\n                </ul>\r\n            </li>\r\n            <li><strong>Combined Decoded Parts:</strong> <code>Q</code> (from capitalized 'q') + <code>ddddddd</code> + <code>be</code> = <code>Qddddddbe</code>.</li>\r\n        </ul>\r\n    </li>\r\n</ul>\r\n\r\n<h3>Example 2:</h3>\r\n<pre><code class='language-text'>Input:\r\nzyxwutsqrponmlkjihgfedcba\r\n!d&3bo&2f@fox@\r\nOutput:\r\nWyyyluclu</code></pre>\r\n<p><strong>Explanation:</strong></p>\r\n<ul>\r\n    <li><strong>Secret Key:</strong> <code>zyxwutsqrponmlkjihgfedcba</code> (maps each letter to its reverse: a -> z, b -> y, c -> x, ..., z -> a)</li>\r\n    <li><strong>Encrypted Message:</strong> <code>!d&3bo&2f@fox@</code></li>\r\n    <li><strong>Decoding Steps:</strong>\r\n        <ul>\r\n            <li><strong>Prefix Modifier !:</strong> The '!' at the start indicates the first decoded character should be capitalized.</li>\r\n            <li><code>d</code> maps to <code>w</code> (from key mapping).</li>\r\n            <li><code>&3b</code>: The digit '3' precedes '&', indicating the next character 'b' should be repeated 3 times. <code>b</code> maps to <code>y</code>. So, <code>b</code> repeated 3 times becomes <code>yyy</code>.</li>\r\n            <li><code>o</code> maps to <code>l</code> (from key mapping).</li>\r\n            <li><code>&2f</code>: The digit '2' precedes '&', indicating the next character 'f' should be repeated 2 times. <code>f</code> maps to <code>u</code>. So, <code>f</code> repeated 2 times becomes <code>uu</code>.</li>\r\n            <li><code>@fox@</code>: The substring between '@' symbols is `fox`.\r\n                <ul>\r\n                    <li>First, reverse `fox` to `xof`.</li>\r\n                    <li>Then, map each character: `x` maps to `c`, `o` maps to `l`, `f` maps to `u`.</li>\r\n                    <li>So, `xof` maps to `clu`.</li>\r\n                </ul>\r\n            </li>\r\n            <li><strong>Combined Decoded Parts:</strong> <code>W</code> (from capitalized 'w') + <code>yyy</code> + <code>l</code> + <code>uu</code> + <code>clu</code> = <code>Wyyyluclu</code>.</li>\r\n        </ul>\r\n    </li>\r\n</ul>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>1 &lt;= message.length &lt;= 2 * 10^2</code></li>\r\n</ul>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cctype>\n\nclass Solution {\npublic:\n    std::string decodeMessage(const std::string& key, const std::string& message) {\n        // Core logic to decode the message will be implemented here.\n        return \"\";\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    std::string key;\n    std::cin >> key;\n\n    std::string message;\n    std::cin >> message;\n\n    Solution solution;\n    std::string result = solution.decodeMessage(key, message);\n\n    std::cout << result << std::endl;\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "Societe_Generale_7Oct",
        "company_id": 576
    }
]