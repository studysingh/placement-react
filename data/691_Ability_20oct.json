[
    {
        "id": 1952,
        "title": "Robot Path Rectangle",
        "problem_statement": "```html\r\n<h1>Robot Path Rectangle</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>A drawing robot is positioned at point (0, 0) of a coordinate plane, and the string <code>moves</code> describes the path the robot will take.</p>\r\n<p>Each of the string's characters describes a single move made by the robot. Moreover, the robot will make the moves in the exact same order as they appear in the string, starting from position (0, 0).</p>\r\n<p>Assuming the robot has already made some moves from the string, and is currently at point (x, y), if the next character of the string is:</p>\r\n<ul>\r\n    <li><code>^</code> - the robot will move to (x, y + 1);</li>\r\n    <li><code>v</code> - the robot will move to (x, y - 1);</li>\r\n    <li><code>&gt;</code> - the robot will move to (x + 1, y);</li>\r\n    <li><code>&lt;</code> - the robot will move to (x - 1, y);</li>\r\n</ul>\r\n<p>Each time the robot moves, it draws a line between its current position and the point to which it moves.</p>\r\n<p>It is guaranteed that the instructions provided in the string <code>moves</code> will never cause the robot to visit the same point more than once, with the exception of point (0, 0), which might be visited by the robot exactly twice: at the beginning and at the end of the robot's path.</p>\r\n<p>The task is to determine whether, after the robot has completed all moves, the path it drew forms a rectangle.</p>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input: moves = \"^^^v<<<>>>\"\r\nOutput: true</code></pre>\r\n<p><strong>Explanation:</strong> The given sequence of moves forms a closed rectangular path, starting and ending at (0,0), without revisiting any intermediate points.</p>\r\n\r\n<h3>Example 2:</h3>\r\n<pre><code class='language-text'>Input: moves = \"&lt;vvv&gt;^^^\"\r\nOutput: false</code></pre>\r\n<p><strong>Explanation:</strong> The robot's path does not return to the starting point (0,0), therefore it does not form a closed rectangle.</p>\r\n\r\n<h3>Example 3:</h3>\r\n<pre><code class='language-text'>Input: moves = \"&lt;vvv&gt;^^\"\r\nOutput: false</code></pre>\r\n<p><strong>Explanation:</strong> The robot's path does not return to the starting point (0,0) and is two moves short of completing a rectangle.</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li>The length of string <code>moves</code> is within the range [1, 100].</li>\r\n    <li>String <code>moves</code> is made only of the following characters: <code>^</code>, <code>v</code>, <code>&gt;</code>, <code>&lt;</code>.</li>\r\n    <li>The robot never visits the same point twice, except for point (0, 0), which may be visited at the start and end of the robot's path.</li>\r\n</ul>\r\n\r\n<h2>Follow-up</h2>\r\n<p>In your solution, focus on correctness. The performance of your solution will not be the focus.</p>\r\n\r\n<pre><code class='language-csharp'>// you can also use other imports, for example:\r\n// using System.Collections.Generic;\r\n\r\n// you can write to stdout for debugging purposes, e.g.\r\n// Console.WriteLine(\"this is a debug message\");\r\n\r\nclass Solution {\r\n    public bool solution(string moves) {\r\n        // Implement your solution here\r\n    }\r\n}\r\n</code></pre>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nclass Solution {\npublic:\n    bool solution(const std::string& moves) {\n        // Implement your solution here\n        return false;\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    std::string moves;\n    std::getline(std::cin, moves);\n\n    Solution sol;\n    bool result = sol.solution(moves);\n\n    std::cout << std::boolalpha << result << std::endl;\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "Ability_20oct",
        "company_id": 691
    },
    {
        "id": 1953,
        "title": "Longest Frog Jump Distance",
        "problem_statement": "<h1>Longest Frog Jump Distance</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>There are N blocks, numbered from 0 to N-1, arranged in a row. A couple of frogs were sitting together on one block when they had a terrible quarrel. Now they want to jump away from one another so that the distance between them will be as large as possible.</p>\r\n<p>The distance between blocks numbered J and K, where J â‰¤ K, is computed as K - J + 1.</p>\r\n<p>The frogs can only jump up, meaning that they can move from one block to another only if the two blocks are adjacent and the second block is of the same or greater height as the first.</p>\r\n<p>What is the longest distance that they can possibly create between each other, if they also chose to sit on the optimal starting block initially?</p>\r\n<p>Write a function:</p>\r\n<pre><code class='language-javascript'>class Solution {\r\n    public int solution(int[] blocks) {\r\n        // Implement your solution here\r\n    }\r\n}</code></pre>\r\n<p>that, given an array <code>blocks</code> consisting of N integers denoting the heights of the blocks, returns the longest possible distance that two frogs can make between each other starting from one of the blocks.</p>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input: blocks = [2, 6, 8, 5]\r\nOutput: 3</code></pre>\r\n<p><strong>Explanation:</strong> If starting from blocks[0], the first frog can stay where it is and the second frog can jump to blocks[2] (but not to blocks[3]).</p>\r\n\r\n<h3>Example 2:</h3>\r\n<pre><code class='language-text'>Input: blocks = [1, 5, 5, 2, 6]\r\nOutput: 4</code></pre>\r\n<p><strong>Explanation:</strong> If starting from blocks[3], the first frog can jump to blocks[1], but not blocks[0], and the second frog can jump to blocks[4].</p>\r\n\r\n<h3>Example 3:</h3>\r\n<pre><code class='language-text'>Input: blocks = [1, 1]\r\nOutput: 2</code></pre>\r\n<p><strong>Explanation:</strong> If starting from blocks[0], one frog can stay at blocks[0] and the other can jump to blocks[1]. The distance is computed as 1 - 0 + 1 = 2.</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li>N is an integer within the range [2..200,000].</li>\r\n    <li>Each element of array <code>blocks</code> is an integer within the range [1..1,000,000,000].</li>\r\n</ul>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nclass Solution {\npublic:\n    int solve(const std::vector<int>& blocks) {\n        // Implement your solution here\n        return 0;\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    int n;\n    // Assuming the number of blocks N is provided first, which is standard.\n    // If the input is just the list of numbers, this part needs adjustment.\n    // For example, reading numbers until end-of-line or end-of-file.\n    // Based on typical competitive programming formats, N is usually given.\n    // Let's assume N is not given and we read until there's no more input.\n    // A simpler approach for boilerplate is to assume N is given. Let's stick to that.\n    // The problem statement is from a platform where you only fill the function,\n    // so input format is ambiguous. Let's create a standard competitive programming main.\n    // Let's assume N is not given and we read the line.\n    // No, that's too complex. The simplest standard is N followed by N elements.\n    // Let's assume N is the size of the input array.\n    // The problem statement implies the array is the only input.\n    // Let's just read the numbers into a vector.\n    // A simple way is to read one by one.\n    \n    // Let's assume the first number is N, as it's the most common format.\n    // If N is not given, the user can easily remove the `std::cin >> n;` line.\n    // The problem constraints say N is an integer, implying it's an input.\n    \n    // Let's assume the input is just a single line of space-separated integers.\n    // This is less common but possible.\n    // Let's go with the most robust and standard approach: read N, then N elements.\n    // The user can adapt if the format is different.\n    \n    // The problem statement is for a function `solution(int[] blocks)`.\n    // This implies the array/vector is the primary input.\n    // Let's just read the vector.\n    \n    // A common way to handle this ambiguity is to read numbers until EOF.\n    // Let's do that.\n    \n    std::vector<int> blocks;\n    int height;\n    // This loop will read integers from standard input until it can't read any more.\n    // This works for space-separated or newline-separated integers.\n    while (std::cin >> height) {\n        blocks.push_back(height);\n    }\n\n    Solution solution;\n    int result = solution.solve(blocks);\n    std::cout << result << std::endl;\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "Ability_20oct",
        "company_id": 691
    },
    {
        "id": 1954,
        "title": "Allocator",
        "problem_statement": "<h1>Allocator</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>Implement a class <code>Allocator</code> that distributes variable allocations in the computer's memory.</p>\r\n<p>For this task, assume that the computer's memory consists of <strong>N</strong> bytes, addressed <strong>0...N-1</strong>. <strong>N</strong> is a power of 2. The class should provide the following functions:</p>\r\n<ul>\r\n    <li>\r\n        <p><code>Allocator(int N)</code></p>\r\n        <p>Creates an allocator, responsible for <strong>N</strong> bytes of memory. <strong>N</strong> is a power of 2.</p>\r\n    </li>\r\n    <li>\r\n        <p><code>int alloc(int size)</code></p>\r\n        <p>Allocates a variable of <code>size</code> bytes and returns the address of the first allocated byte. The <code>size</code> parameter is always 1, 4 or 8. The variable needs to be allocated <code>size</code> consecutive bytes.</p>\r\n        <p>No byte can be allocated to two variables at once.</p>\r\n        <p>If there is enough consecutive free space, the variable should always be allocated.</p>\r\n        <p>If it is not possible to allocate the variable of the given <code>size</code>, the function should return <strong>-1</strong>.</p>\r\n    </li>\r\n    <li>\r\n        <p><code>void free(int address)</code></p>\r\n        <p>Frees the variable allocated at the given <code>address</code>, which means that all bytes taken by the variable are no longer allocated.</p>\r\n        <p>Assume that <code>address</code> is a value previously returned by the <code>alloc</code> function, and that the variable it points to is currently allocated (it wasn't freed previously). After freeing a variable, the bytes it occupied can be allocated to a new variable.</p>\r\n    </li>\r\n</ul>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<p>For example, consider the following sequence of operations:</p>\r\n<pre><code class='language-text'>| Operation          | Returned Value | Comment                                   |\r\n|--------------------|----------------|-------------------------------------------|\r\n| 1 a = Allocator(8) | -              | Create an allocator for 8 bytes of memory |\r\n| 2 a.alloc(8)       | 0              | Bytes 0-7 are allocated                   |\r\n| 3 a.alloc(1)       | -1             | There is no free byte                     |\r\n| 4 a.free(0)        | -              | Bytes 0-7 are freed                       |\r\n| 5 a.alloc(1)       | 0              | Byte 0 is allocated                       |\r\n| 6 a.alloc(4)       | 1              | Bytes 1-4 are allocated                   |</code></pre>\r\n<p><strong>Explanation:</strong> In this sequence of operations, only 3 <code>alloc</code> operations succeeded (operations 2, 5, and 6). Operation 3 failed as there were not enough consecutive free bytes.</p>\r\n<p>It is worth noting that the allocation strategy in operation 6 (<code>a.alloc(4)</code>) might not be optimal. If the variable of size 4 was placed in bytes 4-7 instead of 1-4 (assuming byte 0 was already taken by <code>a.alloc(1)</code>), it might allow for more successful allocations later.</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li>The memory size <strong>N</strong> for the <code>Allocator</code> is always a power of 2.</li>\r\n    <li>The <code>size</code> parameter for <code>alloc</code> is always 1, 4, or 8.</li>\r\n    <li>The <code>address</code> parameter for <code>free</code> is guaranteed to be a previously returned address from <code>alloc</code> and currently allocated.</li>\r\n    <li>No byte can be allocated to two variables at once.</li>\r\n</ul>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <vector>\n#include <string>\n#include <utility>\n#include <map>\n\nclass Allocator {\npublic:\n    Allocator(int N) {\n        // TODO: Implement constructor to initialize memory of size N.\n    }\n\n    int alloc(int size) {\n        // TODO: Implement allocation logic.\n        // Find a contiguous block of 'size' bytes, mark it as allocated,\n        // and return the starting address.\n        // Return -1 if allocation is not possible.\n        return -1;\n    }\n\n    void free(int address) {\n        // TODO: Implement free logic.\n        // Free the memory block starting at 'address'.\n    }\n\nprivate:\n    // TODO: Add private members to manage the memory state.\n};\n\nclass Solution {\npublic:\n    /**\n     * This method should process the sequence of operations on the Allocator.\n     * @param N The total size of memory for the Allocator.\n     * @param operations A vector of pairs, where each pair contains an operation\n     *                   (\"alloc\" or \"free\") and its integer parameter (size or address).\n     * @return A vector of integers containing the results of all \"alloc\" operations.\n     */\n    std::vector<int> process_operations(int N, const std::vector<std::pair<std::string, int>>& operations) {\n        // The core logic will be implemented here.\n        // This method should create an Allocator instance and process the operations,\n        // collecting the results of 'alloc' calls.\n        return {};\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    // The problem description does not specify a standard input format for the sequence of operations.\n    // We will assume a plausible format for the boilerplate:\n    // First line: N (memory size) and Q (number of operations).\n    // Next Q lines: operation_type parameter (e.g., \"alloc 8\", \"free 0\").\n    \n    int N, Q;\n    std::cin >> N >> Q;\n\n    std::vector<std::pair<std::string, int>> operations(Q);\n    for (int i = 0; i < Q; ++i) {\n        std::cin >> operations[i].first >> operations[i].second;\n    }\n\n    Solution solution;\n    std::vector<int> results = solution.process_operations(N, operations);\n\n    for (int result : results) {\n        std::cout << result << \"\\n\";\n    }\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "Ability_20oct",
        "company_id": 691
    }
]