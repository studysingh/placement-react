[
    {
        "id": 184,
        "title": " Server Management",
        "problem_statement": "<div class=\\\"problem-container\\\">\n    <h1> Server Management</h1>\n    \n    <div class=\\\"problem-description\\\">\n        <p>A company manages a network of <var>n</var> servers to handle incoming requests. Each server can handle a specified number of requests represented by an array, <code>serverCapacity</code>. However, the actual incoming requests for each server, represented by <code>incomingRequests</code>, may exceed the capacity of some servers, leading to potential overload and performance degradation.</p>\n        \n        <p>To optimize load distribution and ensure efficient server utilization, the company plans to double the capacity of any <var>k</var> servers. The task is to determine the maximum total number of requests that can be handled by all the servers after implementing these changes.</p>\n    </div>\n\n    <div class=\\\"input-format\\\">\n        <h3>Function Parameters</h3>\n        <ul>\n            <li><code>int serverCapacity[n]</code>: the capacity of each server</li>\n            <li><code>int incomingRequests[n]</code>: the number of incoming requests for each server</li>\n            <li><code>int k</code>: the number of servers whose capacity is doubled</li>\n        </ul>\n    </div>\n\n    <div class=\\\"output-format\\\">\n        <h3>Returns</h3>\n        <p><code>long</code>: the maximum number of total requests that can be handled by all the servers after modifications</p>\n    </div>\n\n    <div class=\\\"constraints\\\">\n        <h3>Constraints</h3>\n        <ul>\n            <li>1 ≤ k ≤ n ≤ 2 × 10<sup>5</sup></li>\n            <li>1 ≤ serverCapacity[i], incomingRequests[i] ≤ 10<sup>9</sup></li>\n        </ul>\n    </div>\n\n    <div class=\\\"examples\\\">\n        <h3>Example 1</h3>\n        <div class=\\\"example\\\">\n            <pre class=\\\"input\\\">Input:\nn = 4\nserverCapacity = [10, 4, 3, 7]\nincomingRequests = [3, 10, 4, 5]\nk = 2</pre>\n            <pre class=\\\"output\\\">Output:\n20</pre>\n            <div class=\\\"explanation\\\">\n                <p>If the second and third server capacities are doubled, the number of requests served is 3 + 8 + 4 + 5 = 20. There is no way to handle all 10 requests with the second server.</p>\n            </div>\n        </div>\n\n        <h3>Example 2</h3>\n        <div class=\\\"example\\\">\n            <pre class=\\\"input\\\">Input:\nn = 5\nserverCapacity = [12, 4, 8, 8, 10]\nincomingRequests = [15, 5, 14, 13, 19]\nk = 5</pre>\n            <pre class=\\\"output\\\">Output:\n66</pre>\n            <div class=\\\"explanation\\\">\n                <p>The capacity can be doubled for all the servers. After doubling, 2 × serverCapacity[i] > incomingRequests[i] for all servers. Therefore, the maximum number of requests handled is the sum of all incoming requests: 15 + 5 + 14 + 13 + 19 = 66.</p>\n            </div>\n        </div>\n    </div>\n\n    <div class=\\\"function-signature\\\">\n        <h3>Function Signature</h3>\n        <pre class=\\\"code\\\">public static long getMaxRequests(List&lt;Integer&gt; serverCapacity, List&lt;Integer&gt; incomingRequests, int k)</pre>\n    </div>\n</div>",
        "google_doc_link": "https://docs.google.com/document/d/18yPbGSRlGJ4u76rgInEs2eDwHRYNWhCJ1e4HLu-mH54/edit?usp=sharing",
        "solution_code": "public static long getMaxRequests(List<Integer> serverCapacity, List<Integer> incomingRequests, int k) {\\n    int n = serverCapacity.size();\\n    long base = 0;\\n    List<Long> gains = new ArrayList<>();\\n    for (int i = 0; i < n; i++) {\\n        long capacity = serverCapacity.get(i);\\n        long requests = incomingRequests.get(i);\\n        if (requests <= capacity) {\\n            base += requests;\\n        } else {\\n            base += capacity;\\n            long doubledCapacity = 2 * capacity;\\n            long handledWithDouble = Math.min(requests, doubledCapacity);\\n            long gain = handledWithDouble - capacity;\\n            gains.add(gain);\\n        }\\n    }\\n    gains.sort(Collections.reverseOrder());\\n    long totalGain = 0;\\n    for (int i = 0; i < Math.min(k, gains.size()); i++) {\\n        totalGain += gains.get(i);\\n    }\\n    return base + totalGain;\\n}",
        "company_name": "Z Scaler",
        "company_id": 42
    },
    {
        "id": 185,
        "title": "Drop-off Centers",
        "problem_statement": "<div class=\\\"problem-container\\\">\n    <h2>Drop-off Centers</h2>\n    \n    <div class=\\\"problem-description\\\">\n        <p>An e-commerce company wants to contract with local businesses to use their stores as pick-up and drop-off centers for their packages. To reduce expenses, they want to ensure that their drop-off centers are a minimum distance apart from each other.</p>\n        \n        <p>A city has many potential drop-off centers to choose from, represented as nodes on a weighted, undirected graph. The edges on this graph denote roads that connect pdcs, with weights representing the lengths of the roads. Determine how many unique subsets of these companies can be contracted that will satisfy that requirement. Note that locations owned by the same local business must also meet the minimum distance requirement. If they make an agreement with a company, they will have a drop-off center in every location that the company owns.</p>\n    </div>\n\n    <div class=\\\"input-format\\\">\n        <h3>Input Format</h3>\n        <p>The function findCount has the following parameters:</p>\n        <ul>\n            <li><code>int graph_nodes</code>: number of nodes in the graph (potential drop-off centers in the city)</li>\n            <li><code>List&lt;Integer&gt; graph_from[]</code>: an array of integers that represent one endpoint of each edge</li>\n            <li><code>List&lt;Integer&gt; graph_to[]</code>: an array of integers that represent the other endpoint of each edge</li>\n            <li><code>List&lt;Integer&gt; graph_weight[]</code>: an array of integers that represent the weights of all the edges</li>\n            <li><code>int minDistance</code>: the minimum required distance between pdcs</li>\n            <li><code>List&lt;Integer&gt; company[]</code>: an array of integers that represent the company each store belongs to</li>\n        </ul>\n    </div>\n\n    <div class=\\\"output-format\\\">\n        <h3>Return</h3>\n        <p><code>int</code>: the count of valid subsets of companies that may be contracted</p>\n    </div>\n\n    <div class=\\\"constraints\\\">\n        <h3>Constraints</h3>\n        <ul>\n            <li>2 ≤ graph_nodes ≤ 1000</li>\n            <li>1 ≤ n ≤ min(1000, (graph_nodes*(graph_nodes+1)/2)</li>\n            <li>1 ≤ graph_weight[i] ≤ 1000</li>\n            <li>1 ≤ minDistance ≤ 1000</li>\n            <li>1 ≤ companies[i] ≤ 10</li>\n            <li>There are no self-loops and there is at most one edge between any 2 nodes.</li>\n        </ul>\n    </div>\n\n    <div class=\\\"examples\\\">\n        <h3>Sample Case 0</h3>\n        <div class=\\\"example\\\">\n            <pre class=\\\"input\\\">graph_nodes = 3\ngraph_from = [1, 2, 3]\ngraph_to = [2, 3, 1]\nminDistance = 4\ncompanies = [1, 2, 3]</pre>\n            <pre class=\\\"output\\\">4</pre>\n            <div class=\\\"explanation\\\">\n                <p>There are 3 potential drop-off centers to select from, each belonging to a different company. The required minimum distance between any 2 potential drop-off centers is 4 units.</p>\n                <p>Possible combinations include contracting with:</p>\n                <ul>\n                    <li>Company 1, alone</li>\n                    <li>Company 2, alone</li>\n                    <li>Company 3, alone</li>\n                    <li>Companies 1 and 3</li>\n                </ul>\n            </div>\n        </div>\n\n        <h3>Sample Case 1</h3>\n        <div class=\\\"example\\\">\n            <pre class=\\\"input\\\">graph_nodes = 2\ngraph_from = [1]\ngraph_to = [2]\ngraph_weight = [5]\nminDistance = 10",
        "google_doc_link": "https://docs.google.com/document/d/1bO5sYoq0dQlh7cYTmtBxxkZwQiXmxSl0kYuvf3jWIKw/edit?usp=sharing",
        "solution_code": "from collections import deque\\ndef timeOfBuffering(arrivalRate, packets):\\n    buffer = deque()\\n    current = 1\\n    time = 0\\n\\n    for i in range(0, len(packets), arrivalRate):\\n        time += 1\\n\\n        for j in range(i, min(i + arrivalRate, len(packets))):\\n            packet = packets[j]\\n            if packet != current:\\n                buffer.append(packet)\\n\\n        if current in buffer:\\n            buffer.remove(current)\\n        elif current == packets[i]:\\n            pass\\n        else:\\n            return time\\n\\n        current += 1\\n\\n    return -1",
        "company_name": "Z Scaler",
        "company_id": 42
    }
]