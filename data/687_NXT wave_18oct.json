[
    {
        "id": 1941,
        "title": "Dynamic Range Scoring in a Modified Array",
        "problem_statement": "<h1>Dynamic Range Scoring in a Modified Array</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>Given an array of positive integers <strong>nums</strong> (0-indexed) and an integer <strong>k</strong>, your task is to calculate the maximum score from a dynamically modified subarray that must include the element <strong>k</strong>.</p>\r\n\r\n<p>Dynamic Scoring Mechanism:</p>\r\n<ul>\r\n    <li><p>The score of a subarray <strong>(i, j)</strong> is defined as the product of the dynamic minimum of <strong>nums[i]</strong> through <strong>nums[j]</strong> and the cumulative sum of a secondary array <strong>scores</strong>, which is initially all zeros and has the same length as <strong>nums</strong>. The dynamic minimum is the smallest value in the current subarray after applying all modifications up to that point.</p></li>\r\n    <li><p>At each step, you may perform one of the following operations, up to a maximum of <strong>M</strong> times on the subarray <strong>(i, j)</strong>:</p>\r\n        <ul>\r\n            <li><p>i. Increment: Increase the value of one element in the subarray by 1.</p></li>\r\n            <li><p>ii. Decrement: Decrease the value of one element in the subarray by 1, but not below 1.</p></li>\r\n            <li><p>iii. Score Update: For each operation, update the <strong>scores</strong> array at the position of the modified element by 1.</p></li>\r\n        </ul>\r\n    </li>\r\n</ul>\r\n<p>Your objective is to determine the maximum possible score from any valid subarray that includes <strong>k</strong>, after optimally performing up to <strong>M</strong> modifications as described.</p>\r\n\r\n<h2>Input Format</h2>\r\n<ul>\r\n    <li><p>The first line of input consists of space-separated integers containing the length of the array <strong>n</strong>, <strong>k</strong>, and <strong>m</strong> modifications.</p></li>\r\n    <li><p>The second line of input consists of space-separated integers containing the array <strong>nums</strong>.</p></li>\r\n</ul>\r\n\r\n<h2>Output Format</h2>\r\n<ul>\r\n    <li><p>The output should be an integer containing the maximum possible score from any valid subarray.</p></li>\r\n</ul>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<p>Imagine a simpler example to illustrate the concept, as the actual problem would involve larger arrays and more operations.</p>\r\n<pre><code class='language-text'>Input:\r\n3 1 1\r\n3 1 2</code></pre>\r\n<p><strong>Explanation:</strong>\r\nPossible Operations: Increment the element at index 1 once, making the array <code>[3,2,2]</code>.\r\nScore Calculation: The optimal subarray might be <code>(0, 2)</code> with a dynamic minimum of <code>2</code> and a cumulative sum of modified scores <code>scores = [0,1,0]</code> for a total score of <code>2 * (0+1+0) = 2</code>.</p>\r\n<pre><code class='language-text'>Output:\r\n2</code></pre>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>1 &lt;= nums.length &lt;= 10^5</code></li>\r\n    <li><code>1 &lt;= nums[i] &lt;= 10^4</code></li>\r\n    <li><code>0 &lt;= k &lt; nums.length</code></li>\r\n    <li><code>0 &lt;= M &lt;= 100</code></li>\r\n</ul>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <numeric>\n\nclass Solution {\npublic:\n    long long maxScore(int n, int k, int m, const std::vector<int>& nums) {\n        // Core logic to find the maximum score goes here.\n        // This is a placeholder implementation.\n        return 0;\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    int n, k, m;\n    std::cin >> n >> k >> m;\n\n    std::vector<int> nums(n);\n    for (int i = 0; i < n; ++i) {\n        std::cin >> nums[i];\n    }\n\n    Solution solution;\n    long long result = solution.maxScore(n, k, m, nums);\n\n    std::cout << result << std::endl;\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "NXT wave_18oct",
        "company_id": 687
    },
    {
        "id": 1942,
        "title": "Warehouse Exit Finder",
        "problem_statement": "<h1>Warehouse Exit Finder</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>You are managing a large warehouse with numerous aisles and blocked paths. Some paths are blocked due to maintenance work. Your task is to determine the nearest exit for a worker starting from a given position in the grid.</p>\r\n<p>The grid is represented by a 2D array where:</p>\r\n<ul>\r\n    <li><code>#</code> represents a free path.</li>\r\n    <li><code>B</code> represents a blocked path.</li>\r\n    <li>The worker starts from a given position in the grid.</li>\r\n</ul>\r\n<p>An exit is defined as any free path that is located at the boundary of the grid. The worker can move up, down, left or right at each step. Your goal is to find the minimum number of steps required for the worker to reach an exit. If no such path exists, return <code>-1</code>.</p>\r\n<p>Complete the provided function <code>warehouseExitFinder</code> that takes four arguments:</p>\r\n<ul>\r\n    <li><code>m</code>: An integer representing the number of rows in the warehouse grid.</li>\r\n    <li><code>n</code>: An integer representing the number of columns in the warehouse grid.</li>\r\n    <li><code>warehouse</code>: A 2D vector (grid) of characters where <code>#</code> represents open paths and <code>B</code> represents blocked cells.</li>\r\n    <li><code>start</code>: A vector of two integers representing the starting position in the warehouse grid.</li>\r\n</ul>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input: warehouse = [\r\n  [B, B, B, B],\r\n  [B, #, #, B],\r\n  [B, #, B, B],\r\n  [B, #, #, B]\r\n]\r\nstart = (1, 2)\r\nOutput: 2</code></pre>\r\n<p><strong>Explanation:</strong></p>\r\n<ul>\r\n    <li>The worker starts at position <code>(1, 2)</code>.</li>\r\n    <li>They can move left to position <code>(1, 1)</code>.</li>\r\n    <li>Then move left again to position <code>(1, 0)</code>, which is an exit.</li>\r\n    <li>A total of <code>2</code> steps are required.</li>\r\n</ul>\r\n<p><strong>Alternate Path:</strong></p>\r\n<ul>\r\n    <li>The worker starts at position <code>(1, 2)</code>.</li>\r\n    <li>They can move left to position <code>(1, 1)</code>.</li>\r\n    <li>Then move down to position <code>(2, 1)</code>.</li>\r\n    <li>Finally, move down to position <code>(3, 1)</code>, which is an exit.</li>\r\n    <li>A total of <code>3</code> steps are required.</li>\r\n</ul>\r\n<p>The minimum number of steps required to reach an exit is <code>2</code>.</p>\r\n\r\n<h3>Example 2:</h3>\r\n<pre><code class='language-text'>Input: warehouse = [\r\n  [B, B, B, B],\r\n  [B, #, #, B],\r\n  [B, #, B, B],\r\n  [B, #, #, B]\r\n]\r\nstart = (2, 2)\r\nOutput: 1</code></pre>\r\n<p><strong>Explanation:</strong></p>\r\n<ul>\r\n    <li>The worker starts at position <code>(2, 2)</code>.</li>\r\n    <li>They can move down to position <code>(3, 2)</code>, which is an exit.</li>\r\n    <li>A total of <code>1</code> step is required.</li>\r\n</ul>\r\n<p><strong>Alternate Paths:</strong></p>\r\n<ol>\r\n    <li>Starting at position <code>(2, 2)</code>:\r\n        <ul>\r\n            <li>Move up to position <code>(1, 2)</code>, then right to position <code>(1, 3)</code>, which is an exit.</li>\r\n            <li>This path requires <code>2</code> steps.</li>\r\n        </ul>\r\n    </li>\r\n    <li>Starting at position <code>(2, 2)</code>:\r\n        <ul>\r\n            <li>Move left to position <code>(2, 1)</code>, then down to position <code>(3, 1)</code>, which is an exit.</li>\r\n            <li>This path requires <code>2</code> steps.</li>\r\n        </ul>\r\n    </li>\r\n</ol>\r\n<p>The minimum number of steps required to reach an exit is <code>1</code>.</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>1 &lt;= warehouse.length, warehouse[0].length &lt;= 100</code></li>\r\n    <li><code>warehouse[i][j]</code> is either <code>B</code> or <code>#</code>.</li>\r\n    <li><code>start</code> is an integer tuple <code>(startRow, startCol)</code>.</li>\r\n    <li><code>0 &lt;= startRow &lt; warehouse.length</code></li>\r\n    <li><code>0 &lt;= startCol &lt; warehouse[0].length</code></li>\r\n    <li>The starting position will always be an empty cell.</li>\r\n</ul>\r\n\r\n<h2>Input Format</h2>\r\n<ul>\r\n    <li>The first line contains two integers <code>m</code> and <code>n</code>, representing the number of rows and columns in the warehouse grid, respectively.</li>\r\n    <li>The next <code>m</code> lines each contain <code>n</code> space-separated characters representing the warehouse grid.</li>\r\n    <li>The last line contains two integers representing the starting position <code>start[0]</code> (row) and <code>start[1]</code> (column) in the grid.</li>\r\n</ul>\r\n\r\n<h2>Output Format</h2>\r\n<ul>\r\n    <li>The output is a single integer representing the minimum number of steps required to reach an exit of the warehouse from the starting position. If there is no valid path to the edge, output <code>-1</code>.</li>\r\n</ul>\r\n\r\n<h2>Sample Input/Output</h2>\r\n<h3>Sample Input 1:</h3>\r\n<pre><code class='language-text'>4 4\r\nB B B B\r\nB # # B\r\nB # B B\r\nB # # B\r\n1 2</code></pre>\r\n<h3>Sample Output 1:</h3>\r\n<pre><code class='language-text'>2</code></pre>\r\n\r\n<h3>Sample Input 2:</h3>\r\n<pre><code class='language-text'>4 4\r\nB B B B\r\nB # # B\r\nB # B B\r\nB # # B\r\n2 2</code></pre>\r\n<h3>Sample Output 2:</h3>\r\n<pre><code class='language-text'>1</code></pre>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <vector>\n#include <string>\n#include <queue>\n\nclass Solution {\npublic:\n    int warehouseExitFinder(int m, int n, const std::vector<std::vector<char>>& warehouse, const std::vector<int>& start) {\n        // Core logic to find the shortest path to an exit goes here.\n        // This is a classic Breadth-First Search (BFS) problem.\n        // A queue can be used to explore the grid level by level.\n        // A visited array is needed to avoid cycles and redundant computations.\n        // The state in the queue could be a tuple or struct: {row, col, distance}.\n        // The search stops when an exit (a '#' on the boundary) is reached.\n        return -1; // Placeholder\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    int m, n;\n    std::cin >> m >> n;\n\n    std::vector<std::vector<char>> warehouse(m, std::vector<char>(n));\n    for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < n; ++j) {\n            std::cin >> warehouse[i][j];\n        }\n    }\n\n    std::vector<int> start(2);\n    std::cin >> start[0] >> start[1];\n\n    Solution sol;\n    int result = sol.warehouseExitFinder(m, n, warehouse, start);\n\n    std::cout << result << std::endl;\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "NXT wave_18oct",
        "company_id": 687
    },
    {
        "id": 1943,
        "title": "Enhance Consistency in a Sequence of Decisions",
        "problem_statement": "<h1>Enhance Consistency in a Sequence of Decisions</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>Given a 2D matrix <strong>decisionMatrix</strong> of dimensions <strong>n x m</strong>, where each element denotes a decision made. A decision can be <strong>D</strong> (denoting a Desirable outcome) or <strong>U</strong> (denoting an Undesirable outcome). Your task is to maximize the consistency of decisions along any row or column. Consistency is enhanced by transforming <strong>D</strong> to <strong>U</strong> and vice versa. You are allowed a maximum of <strong>K</strong> transformation operations. The transformation ability will be halved for the subsequent operation (rounded down to the nearest whole number).</p>\r\n<p>Additionally, for every row or column, having a higher number of identical decisions contributes more towards an overall score of that row or column. The objective is to maximize the lowest score among all rows and columns.</p>\r\n\r\n<h3>Task Details:</h3>\r\n<ul>\r\n    <li>Transform the decisions in the matrix in such a way that the minimum number of any row or column, containing the longest sequence of identical decisions (<strong>D</strong> or <strong>U</strong>), is maximized.</li>\r\n    <li>After each transformation operation, the maximum number of transformations allowed in the next operation is halved (rounded down).</li>\r\n    <li>You can choose to transform decisions in any row or column, but the goal is to enhance the overall consistency across the matrix rather than concentrating on a single row or column.</li>\r\n</ul>\r\n\r\n<h2>Input format</h2>\r\n<ul>\r\n    <li>The first line of input consists of space separated integers <strong>n</strong>, <strong>m</strong>, and <strong>k</strong> representing the initial maximum number of transformations allowed.</li>\r\n    <li>The next <strong>n</strong> lines of input containing space separated 2D integer matrix <strong>decisionMatrix</strong> containing <strong>n x m</strong> elements, each being either <strong>D</strong> or <strong>U</strong>.</li>\r\n</ul>\r\n\r\n<h2>Output</h2>\r\n<ul>\r\n    <li>The output should be an integer containing the maximum possible minimum score that can be achieved across all rows and columns.</li>\r\n</ul>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input:\r\n3 3 2\r\nD D D\r\nU D U\r\nD U D\r\nOutput: 3</code></pre>\r\n<p><strong>Explanation:</strong> Transforming the center column or the middle row in the first operation maximizes the consecutive decisions. The choice of the second operation depends on the halved transformation ability and should be used to further balance or enhance the consistency across the matrix.</p>\r\n\r\n<h3>Sample Input 1:</h3>\r\n<pre><code class='language-text'>Input:\r\n1 1 1\r\nD\r\nOutput: 1</code></pre>\r\n\r\n<h3>Sample Input 2:</h3>\r\n<pre><code class='language-text'>Input:\r\n2 2 1\r\nD D\r\nU U\r\nOutput: 2</code></pre>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>1 <= n, m <= 100</code></li>\r\n    <li><code>decisionMatrix[i][j]</code> is either <strong>D</strong> or <strong>U</strong></li>\r\n    <li><code>1 <= k <= min(n, m)</code></li>\r\n</ul>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nclass Solution {\npublic:\n    /**\n     * @param n The number of rows in the decision matrix.\n     * @param m The number of columns in the decision matrix.\n     * @param k The initial maximum number of transformations allowed.\n     * @param decisionMatrix The n x m matrix of decisions ('D' or 'U').\n     * @return The maximum possible minimum score that can be achieved.\n     */\n    int solve(int n, int m, int k, const std::vector<std::vector<char>>& decisionMatrix) {\n        // TODO: Implement the core logic for the problem here.\n        // The goal is to maximize the minimum number of identical decisions\n        // in any row or column, using at most k transformations, where the\n        // transformation budget is halved after each operation.\n        return 0;\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    int n, m, k;\n    std::cin >> n >> m >> k;\n\n    std::vector<std::vector<char>> decisionMatrix(n, std::vector<char>(m));\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            std::cin >> decisionMatrix[i][j];\n        }\n    }\n\n    Solution solution;\n    int result = solution.solve(n, m, k, decisionMatrix);\n\n    std::cout << result << std::endl;\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "NXT wave_18oct",
        "company_id": 687
    },
    {
        "id": 1944,
        "title": "The Castle Courtyard",
        "problem_statement": "<h1>The Castle Courtyard</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>You are managing the layout of guards in a castle courtyard. Your task is to place <code>n</code> guards on an <code>n x n</code> chessboard such that no two guards can attack each other. Guards can attack in any direction: horizontally, vertically, and diagonally.</p>\r\n<p>Your task is to find all possible arrangements of the <code>n</code> guards on the <code>n x n</code> chessboard where no two guards are in a position to attack each other. Each arrangement should be represented by a board configuration where each cell is either a guard (<code>G</code>) or an empty space (<code>.</code>).</p>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input: n = 4\r\nOutput:\r\n[\".G..\",\r\n \"...G\",\r\n \"G...\",\r\n \"..G.\"],\r\n[\"..G.\",\r\n \"G...\",\r\n \"...G\",\r\n \".G..\"]</code></pre>\r\n<p><strong>Explanation:</strong>\r\n<ul>\r\n    <li>The first arrangement shows each guard placed in such a way that no two guards can attack each other either horizontally, vertically, or diagonally.</li>\r\n    <li>Similarly, the second arrangement also ensures that all guards are positioned where they cannot attack one another.</li>\r\n    <li>Each guard is in a unique row and column.</li>\r\n</ul>\r\n</p>\r\n\r\n<h3>Example 2:</h3>\r\n<pre><code class='language-text'>Input: n = 1\r\nOutput:\r\n[\"G\"]</code></pre>\r\n<p><strong>Explanation:</strong> With only one square on the chessboard, the single guard is placed without any possibility of attack, as there are no other guards present.</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>1 <= n <= 9</code></li>\r\n</ul>\r\n\r\n<h2>Your Task</h2>\r\n<p>Complete the provided function <code>solveNGuard</code> that takes one argument:</p>\r\n<ul>\r\n    <li><code>n</code>: An integer representing the size of the chessboard and the number of guards to be placed.</li>\r\n</ul>\r\n\r\n<h2>Input Format</h2>\r\n<p>The input contains a single integer <code>n</code> representing the size of the chessboard and the number of guards to be placed.</p>\r\n\r\n<h2>Output Format</h2>\r\n<p>The output should be a list of configurations, each representing a unique way to arrange the <code>n</code> guards on the <code>n x n</code> chessboard. Each configuration is a list of <code>n</code> strings, where each string represents a row of the chessboard. In these strings:</p>\r\n<ul>\r\n    <li>The character <code>G</code> represents a guard.</li>\r\n    <li>The character <code>.</code> represents an empty space.</li>\r\n</ul>\r\n<p>Each string should have exactly <code>n</code> characters, corresponding to the <code>n</code> columns of the chessboard. This way, each configuration provides a visual representation of the entire board with the guards' placements.</p>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <vector>\n#include <string>\n\nclass Solution {\npublic:\n    /**\n     * @brief Finds all distinct solutions to the N-Guards problem.\n     * @param n The size of the chessboard and the number of guards.\n     * @return A vector of boards, where each board is a valid configuration.\n     */\n    std::vector<std::vector<std::string>> solveNGuard(int n) {\n        // The core logic to solve the N-Guards (N-Queens) problem will be implemented here.\n        // This typically involves backtracking.\n        // The function should return all possible board configurations.\n        std::vector<std::vector<std::string>> all_solutions;\n        // Placeholder for the solution logic.\n        return all_solutions;\n    }\n};\n\nint main() {\n    // Fast I/O\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    // Read the size of the chessboard\n    int n;\n    std::cin >> n;\n\n    // Create an instance of the Solution class\n    Solution sol;\n\n    // Get all solutions\n    std::vector<std::vector<std::string>> solutions = sol.solveNGuard(n);\n\n    // Print the solutions\n    // The problem statement shows an example output format like a list of lists.\n    // Here, we will print each board configuration in a more standard, readable format.\n    // Each board is separated by a blank line.\n    for (size_t i = 0; i < solutions.size(); ++i) {\n        const auto& board = solutions[i];\n        for (const std::string& row : board) {\n            std::cout << row << std::endl;\n        }\n        if (i < solutions.size() - 1) {\n            std::cout << std::endl;\n        }\n    }\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "NXT wave_18oct",
        "company_id": 687
    }
]