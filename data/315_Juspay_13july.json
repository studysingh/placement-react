[
    {
        "id": 981,
        "title": "Locking the tree of space",
        "problem_statement": "<h1>Locking the tree of space</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>You are tasked with implementing a system to manage locks on nodes within an M-Ary tree, which represents a world map. The tree nodes are identified by unique names (strings), and operations are performed by users identified by unique integer IDs.</p>\r\n\r\n<p>You need to define three operations:</p>\r\n<ol>\r\n    <li><code>lock(X, uid)</code></li>\r\n    <li><code>unlock(X, uid)</code></li>\r\n    <li><code>upgradeLock(X, uid)</code></li>\r\n</ol>\r\n<p>Where <code>X</code> is the name of a node in the tree, and <code>uid</code> is the user ID performing the operation.</p>\r\n\r\n<h3>Definitions for Operations:</h3>\r\n<h4>Lock(X, uid)</h4>\r\n<p>Lock takes an exclusive access on the subtree rooted at <code>X</code>. It is formally defined like this:</p>\r\n<p>Once <code>lock(X, uid)</code> succeeds, then:</p>\r\n<ul>\r\n    <li><code>lock(A, anyUserId)</code> should fail (returns false), where <code>A</code> is a descendent of <code>X</code>.</li>\r\n    <li><code>lock(B, anyUserId)</code> should fail (returns false), where <code>X</code> is a descendent of <code>B</code>.</li>\r\n    <li>Lock operation cannot be performed on a node which is already locked, i.e., <code>lock(X, anyUserId)</code> should fail (returns false).</li>\r\n</ul>\r\n<p>In summary, a node <code>X</code> can be locked by a user <code>uid</code> only if:</p>\r\n<ol>\r\n    <li>Node <code>X</code> is not currently locked.</li>\r\n    <li>None of <code>X</code>'s ancestors are locked.</li>\r\n    <li>None of <code>X</code>'s descendants are locked.</li>\r\n</ol>\r\n<p>If the lock operation succeeds, it returns <code>true</code>; otherwise, <code>false</code>.</p>\r\n\r\n<h4>Unlock(X, uid)</h4>\r\n<p>Unlocks a node <code>X</code>. This operation succeeds only if node <code>X</code> is currently locked by the same <code>uid</code>. If successful, it returns <code>true</code>; otherwise, <code>false</code>.</p>\r\n\r\n<h4>UpgradeLock(X, uid)</h4>\r\n<p>This operation attempts to upgrade a lock on node <code>X</code>. It succeeds only if:</p>\r\n<ol>\r\n    <li>Node <code>X</code> is not currently locked.</li>\r\n    <li>None of <code>X</code>'s ancestors are locked.</li>\r\n    <li>At least one of <code>X</code>'s descendants is locked.</li>\r\n    <li>All locked descendants of <code>X</code> are locked by the same <code>uid</code>.</li>\r\n</ol>\r\n<p>If the upgrade lock operation succeeds on <code>X</code>, it is equivalent to <code>X</code> being locked by <code>uid</code>, and all its previously locked descendants (which were locked by <code>uid</code>) become unlocked. If successful, it returns <code>true</code>; otherwise, <code>false</code>.</p>\r\n\r\n<h3>Additional Rules:</h3>\r\n<ul>\r\n    <li>The tree is always fully balanced.</li>\r\n    <li>The number of nodes in the tree N is very large. Optimize the time complexity for the algorithms.</li>\r\n</ul>\r\n\r\n<h3>Input Format</h3>\r\n<p>The input describes the tree structure and then a series of queries. The format is as follows:</p>\r\n<ul>\r\n    <li>The first line contains the number of Nodes in the tree (N).</li>\r\n    <li>The second line contains the number of children per node (value m in m-ary Tree).</li>\r\n    <li>The third line contains the number of queries (Q).</li>\r\n    <li>Next N lines contain the NodeName (string) in the m-Ary Tree. The order of these names implicitly defines the tree structure (e.g., in a breadth-first manner or a pre-order traversal, as shown in the example).</li>\r\n    <li>Next Q lines contain queries, which are in the format: <code>OperationType NodeName UserId</code></li>\r\n    <ul>\r\n        <li><strong>OperationType</strong>:\r\n            <ul>\r\n                <li><code>1</code> for Lock</li>\r\n                <li><code>2</code> for Unlock</li>\r\n                <li><code>3</code> for UpgradeLock</li>\r\n            </ul>\r\n        </li>\r\n        <li><strong>NodeName</strong>: Name of any node (unique) in m-Ary Tree.</li>\r\n        <li><strong>UserId</strong>: Integer value representing a unique user.</li>\r\n    </ul>\r\n</ul>\r\n\r\n<p>For example, with the input <code>N=7</code>, <code>m=2</code>, and the node names <code>World, Asia, Africa, China, India, SouthAfrica, Egypt</code>, the tree represents a 2-ary tree with 7 nodes as follows:</p>\r\n<pre><code class='language-text'>        World\r\n       /     \\\r\n     Asia   Africa\r\n    /  \\    /  \\\r\nChina India SouthAfrica Egypt</code></pre>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input:\r\n7\r\n2\r\n5\r\nWorld\r\nAsia\r\nAfrica\r\nChina\r\nIndia\r\nSouthAfrica\r\nEgypt\r\n1 China 9\r\n1 India 9\r\n3 Asia 9\r\n2 India 9\r\n2 Asia 9\r\nOutput:\r\ntrue\r\ntrue\r\ntrue\r\nfalse\r\ntrue</code></pre>\r\n<p><strong>Explanation:</strong></p>\r\n<ul>\r\n    <li><strong>Query 1: 1 China 9</strong><br>\r\n        This operation is successful as initially China is unlocked. Output: <code>true</code>.</li>\r\n    <li><strong>Query 2: 1 India 9</strong><br>\r\n        This should be successful as none of ancestors and descendants of India are locked. Output: <code>true</code>.</li>\r\n    <li><strong>Query 3: 3 Asia 9</strong><br>\r\n        This also should be successful as Asia is not locked, none of its ancestors are locked, and its descendants (China and India) are locked by the same user (9). Upon success, Asia becomes locked by user 9, and China and India become unlocked. Output: <code>true</code>.</li>\r\n    <li><strong>Query 4: 2 India 9</strong><br>\r\n        This should fail as India is now not locked (it was unlocked by the successful <code>upgradeLock</code> on Asia in Query 3). Output: <code>false</code>.</li>\r\n    <li><strong>Query 5: 2 Asia 9</strong><br>\r\n        This should be successful as Asia was locked by user 9 in Query 3. Output: <code>true</code>.</li>\r\n</ul>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>1 &lt; N &lt; 5 * 10^5</code></li>\r\n    <li><code>1 &lt; m &lt; 30</code></li>\r\n    <li><code>1 &lt; Q &lt; 5 * 10^5</code></li>\r\n    <li><code>1 &lt; length of NodeName &lt; 20</code></li>\r\n</ul>\r\n\r\n<h3>Time Complexity Requirements:</h3>\r\n<ul>\r\n    <li>Lock - <code>O(log_m N)</code></li>\r\n    <li>Unlock - <code>O(log_m N)</code></li>\r\n    <li>UpgradeLock - <code>O(numberOfLockedNodes * log_m N)</code></li>\r\n</ul>\r\n\r\n<h3>Limits:</h3>\r\n<ul>\r\n    <li>Time Limit: 0.6 sec(s) for each input file</li>\r\n    <li>Memory Limit: 256 MB</li>\r\n    <li>Source Limit: 1024 KB</li>\r\n</ul>",
        "google_doc_link": null,
        "solution_code": null,
        "company_name": "Juspay_13july",
        "company_id": 315
    }
]