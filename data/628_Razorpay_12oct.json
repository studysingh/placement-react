[
    {
        "id": 1778,
        "title": "Optimal Candy Collection",
        "problem_statement": "<h1>Optimal Candy Collection</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>Given a tree of N nodes and N - 1 edges rooted at node 1, with exactly one candy placed at each node. Let's say the cost of the candy placed on the iᵗʰ node is Aᵢ. You have K amount of money. Now, you will choose exactly one node (say, u) and will start buying the candies placed on the path from node u to the root until you run out of money, that is, first, you will buy the candy placed at node u, then the candy placed at the ancestor of u, then its ancestor and so on until you run out of money or you reach root node. Also, you cannot skip over a node without buying the candy placed at that node.</p>\r\n<p>Calculate the maximum number of candies in a given amount of money you can buy by choosing exactly one starting node.</p>\r\n\r\n<p><strong>Notes</strong></p>\r\n<ul>\r\n    <li>A graph is connected if, for each pair of nodes u and v, there exists a path between these two nodes in the graph.</li>\r\n    <li>A tree is a connected graph with N nodes and N - 1 edges.</li>\r\n</ul>\r\n\r\n<p><strong>Function description</strong></p>\r\n<p>Complete the solve function. This function takes the following 4 parameters and returns an integer.</p>\r\n\r\n<p><strong>Parameters:</strong></p>\r\n<ul>\r\n    <li><code>N</code>: Represents the number of nodes in the tree.</li>\r\n    <li><code>K</code>: Represents the amount of money you have.</li>\r\n    <li><code>A</code>: Represents the cost of candies placed on nodes.</li>\r\n    <li><code>Edges</code>: Represents a 2D array representing the edges (u, v) in the tree.</li>\r\n</ul>\r\n\r\n<p><strong>Input format for custom testing</strong></p>\r\n<p><strong>Note:</strong> Use this input format if you are testing against custom input or writing code in a language where we don't provide boilerplate code.</p>\r\n<ul>\r\n    <li>The first line contains T, which represents the number of test cases.</li>\r\n    <li>For each Test case:\r\n        <ul>\r\n            <li>The first line contains an integer N denoting the number of nodes in the tree.</li>\r\n            <li>The second line contains an integer K denoting the amount of money you have.</li>\r\n            <li>The next line contains N space-separated integers denoting the cost of the candy placed at the iᵗʰ node.</li>\r\n            <li>The next N-1 lines contain two space-separated integers u and v denoting that there is an edge between u and v.</li>\r\n        </ul>\r\n    </li>\r\n</ul>\r\n\r\n<p><strong>Output format</strong></p>\r\n<p>For each test case in a new line, return the maximum number of candies you can buy in the given amount of money by choosing exactly one starting node.</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>1 &lt;= T &lt;= 10</code></li>\r\n    <li><code>1 &lt;= N &lt;= 2 * 10<sup>5</sup></code></li>\r\n    <li><code>1 &lt;= u, v &lt;= N</code></li>\r\n    <li><code>1 &lt;= A[i] &lt;= 10<sup>9</sup></code></li>\r\n    <li><code>1 &lt;= K &lt;= 10<sup>18</sup></code></li>\r\n</ul>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input:\r\n2\r\n6\r\n10\r\n4 12 3 2 5 3\r\n1 2\r\n1 3\r\n2 4\r\n2 5\r\n3 6\r\n3\r\n5\r\n3 2 4\r\n1 2\r\n2 3\r\nOutput:\r\n3\r\n2</code></pre>\r\n<p><strong>Explanation:</strong></p>\r\n<p>The first line contains the number of test cases, T = 2.</p>\r\n<p><strong>The first test case:</strong></p>\r\n<p><strong>Given:</strong></p>\r\n<ul>\r\n    <li><code>N = 6</code></li>\r\n    <li><code>K = 10</code></li>\r\n    <li><code>A = [4, 12, 3, 2, 5, 3]</code> (Costs for nodes 1 to 6 respectively)</li>\r\n    <li><code>Edges = [[1, 2], [1, 3], [2, 4], [2, 5], [3, 6]]</code></li>\r\n</ul>\r\n<p>Let's start from each node and find out how many candies we can buy:</p>\r\n<ul>\r\n    <li><strong>For node 1 (cost 4):</strong> You can buy the candy at node 1. Money left: 10 - 4 = 6. Total candies bought = 1.</li>\r\n    <li><strong>For node 2 (cost 12):</strong> You cannot buy the candy at node 2 as 10 &lt; 12. Total candies bought = 0.</li>\r\n    <li><strong>For node 3 (cost 3):</strong>\r\n        <ul>\r\n            <li>Buy candy at node 3 (cost 3). Money left: 10 - 3 = 7. Candies = 1.</li>\r\n            <li>Move to its ancestor, node 1 (cost 4). Buy candy at node 1. Money left: 7 - 4 = 3. Candies = 2.</li>\r\n        </ul>\r\n        Total candies bought = 2.\r\n    </li>\r\n    <li><strong>For node 4 (cost 2):</strong>\r\n        <ul>\r\n            <li>Buy candy at node 4 (cost 2). Money left: 10 - 2 = 8. Candies = 1.</li>\r\n            <li>Move to its ancestor, node 2 (cost 12). Cannot buy as 8 &lt; 12.</li>\r\n        </ul>\r\n        Total candies bought = 1.\r\n    </li>\r\n    <li><strong>For node 5 (cost 5):</strong>\r\n        <ul>\r\n            <li>Buy candy at node 5 (cost 5). Money left: 10 - 5 = 5. Candies = 1.</li>\r\n            <li>Move to its ancestor, node 2 (cost 12). Cannot buy as 5 &lt; 12.</li>\r\n        </ul>\r\n        Total candies bought = 1.\r\n    </li>\r\n    <li><strong>For node 6 (cost 3):</strong>\r\n        <ul>\r\n            <li>Buy candy at node 6 (cost 3). Money left: 10 - 3 = 7. Candies = 1.</li>\r\n            <li>Move to its ancestor, node 3 (cost 3). Buy candy at node 3. Money left: 7 - 3 = 4. Candies = 2.</li>\r\n            <li>Move to its ancestor, node 1 (cost 4). Buy candy at node 1. Money left: 4 - 4 = 0. Candies = 3.</li>\r\n        </ul>\r\n        Total candies bought = 3.\r\n    </li>\r\n</ul>\r\n<p>Therefore, if started from node 6, you can buy the maximum number of candies which is 3 in this case.</p>\r\n\r\n<p><strong>The second test case:</strong></p>\r\n<p><strong>Given:</strong></p>\r\n<ul>\r\n    <li><code>N = 3</code></li>\r\n    <li><code>K = 5</code></li>\r\n    <li><code>A = [3, 2, 4]</code> (Costs for nodes 1 to 3 respectively)</li>\r\n    <li><code>Edges = [[1, 2], [2, 3]]</code></li>\r\n</ul>\r\n<p>Let's start from each node and find out how many candies we can buy:</p>\r\n<ul>\r\n    <li><strong>For node 1 (cost 3):</strong> You can buy the candy at node 1. Money left: 5 - 3 = 2. Total candies bought = 1.</li>\r\n    <li><strong>For node 2 (cost 2):</strong>\r\n        <ul>\r\n            <li>Buy candy at node 2 (cost 2). Money left: 5 - 2 = 3. Candies = 1.</li>\r\n            <li>Move to its ancestor, node 1 (cost 3). Buy candy at node 1. Money left: 3 - 3 = 0. Candies = 2.</li>\r\n        </ul>\r\n        Total candies bought = 2.\r\n    </li>\r\n    <li><strong>For node 3 (cost 4):</strong>\r\n        <ul>\r\n            <li>Buy candy at node 3 (cost 4). Money left: 5 - 4 = 1. Candies = 1.</li>\r\n            <li>Move to its ancestor, node 2 (cost 2). Cannot buy as 1 &lt; 2.</li>\r\n        </ul>\r\n        Total candies bought = 1.\r\n    </li>\r\n</ul>\r\n<p>Therefore, if started from node 2, then you can buy the maximum number of candies which is 2 in this case.</p>\r\n\r\n<p><strong>Note:</strong> Your code must be able to print the sample output from the provided sample input. However, your code is run against multiple hidden test cases. Therefore, your code must pass these hidden test cases to solve the problem statement.</p>\r\n\r\n<p><strong>Limits:</strong></p>\r\n<ul>\r\n    <li>Time Limit: 2.0 sec(s) for each input file</li>\r\n    <li>Memory Limit: 256 MB</li>\r\n    <li>Source Limit: 1024 KB</li>\r\n</ul>\r\n\r\n<p><strong>Scoring:</strong></p>\r\n<p>Score is assigned if any testcase passes.</p>\r\n\r\n<p><strong>Allowed Languages:</strong></p>\r\n<p>Bash, C, C#, C++, C++17, Clojure, C#, D, Erlang, F#, Go, Groovy, Haskell, Java 8, Java 14, JavaScript (Node.js), Julia, Kotlin, Lisp (SBCL), Lua, Objective-C, OCaml, Octave, Pascal, Perl, PHP, Python, Python 3, Python 3.8, Racket, Ruby, Rust, Scala, Swift, TypeScript, Visual Basic</p>\r\n\r\n<p><strong>Function Signature:</strong></p>\r\n<pre><code class='language-cpp'>int solve(int N, long long K, vector&lt;int&gt; A, vector&lt;vector&lt;int&gt;&gt; Edges)</code></pre>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nclass Solution {\npublic:\n    int solve(int N, long long K, std::vector<int> A, std::vector<std::vector<int>> Edges) {\n        // Core logic to find the maximum number of candies goes here.\n        return 0;\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n    int t;\n    std::cin >> t;\n    while (t--) {\n        int N;\n        std::cin >> N;\n        long long K;\n        std::cin >> K;\n        std::vector<int> A(N);\n        for (int i = 0; i < N; ++i) {\n            std::cin >> A[i];\n        }\n        std::vector<std::vector<int>> Edges(N - 1, std::vector<int>(2));\n        for (int i = 0; i < N - 1; ++i) {\n            std::cin >> Edges[i][0] >> Edges[i][1];\n        }\n\n        Solution sol;\n        int result = sol.solve(N, K, A, Edges);\n        std::cout << result << std::endl;\n    }\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "Razorpay_12oct",
        "company_id": 628
    },
    {
        "id": 1779,
        "title": "Optimized Cache Hit Counter",
        "problem_statement": "<h1>Optimized Cache Hit Counter</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>You are tasked with simulating a cache memory system with a fixed capacity. The system processes a sequence of memory access requests. For each request, it either results in a cache hit (if the item is already in the cache) or a cache miss (if the item is not in the cache and needs to be loaded).</p>\r\n<p>You need to implement a simulation using the Least Recently Used (LRU) eviction policy. When the cache reaches its capacity and a new item needs to be inserted, the least recently used item should be removed to make room.</p>\r\n<p>Due to a high frequency of memory access requests (up to 10<sup>5</sup>), your implementation must be optimized for performance, and choosing the right data structures (e.g., HashMap + Doubly Linked List or OrderedDict) is critical.</p>\r\n<p><strong>Function Description:</strong><br>\r\nImplement the function <code>simulateCacheAccess</code>. The function takes the cache capacity <code>C</code> and a list of memory accesses <code>accesses</code>. It should return the total number of cache hits and cache misses as a space-separated string.</p>\r\n<p><strong>Parameters:</strong></p>\r\n<ul>\r\n    <li><code>C</code>: An integer representing the maximum capacity of the cache.</li>\r\n    <li><code>N</code>: An integer representing the number of memory accesses.</li>\r\n    <li><code>accesses</code>: A list of integers representing memory addresses accessed sequentially.</li>\r\n</ul>\r\n<p><strong>Return:</strong><br>\r\nReturn two space-separated integers: total hits and total misses.</p>\r\n<p><strong>Input Format:</strong></p>\r\n<ul>\r\n    <li>The first line contains an integer <code>C</code>.</li>\r\n    <li>The second line contains an integer <code>N</code>, the number of memory accesses.</li>\r\n    <li>The third line contains <code>N</code> space-separated integers, representing memory addresses.</li>\r\n</ul>\r\n<p><strong>Output Format:</strong><br>\r\nReturn two integers separated by a space: total hits and total misses.</p>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input:\r\n3\r\n10\r\n1 2 3 1 4 5 2 1 3 4</code></pre>\r\n<pre><code class='language-text'>Output:\r\n1 9</code></pre>\r\n<p><strong>Explanation:</strong></p>\r\n<ul>\r\n    <li>Hits: Only 1 hit (on second access to 1)</li>\r\n    <li>All others are misses, with evictions when cache is full</li>\r\n</ul>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>1 &lt;= C &lt;= 10<sup>4</sup></code></li>\r\n    <li><code>1 &lt;= N &lt;= 10<sup>5</sup></code></li>\r\n    <li><code>0 &lt;= memory address &lt;= 10<sup>9</sup></code></li>\r\n</ul>\r\n\r\n<p><strong>Note:</strong><br>\r\nYour code must be able to print the sample output from the provided sample input. However, your code is run against multiple hidden test cases. Therefore, your code must pass these hidden test cases to solve the problem statement.</p>\r\n<p><strong>Limits:</strong><br>\r\nTime Limit: 5.0 sec(s) for each input file<br>\r\nMemory Limit: 256 MB<br>\r\nSource Limit: 1024 KB</p>\r\n<p><strong>Scoring:</strong><br>\r\nScore is assigned if any testcase passes</p>\r\n\r\n<p><strong>Function Signature:</strong></p>\r\n<pre><code class='language-javascript'>vector&lt;int&gt; simulateCacheAccess(int C, int N, vector&lt;int&gt; accesses)</code></pre>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <vector>\n#include <string>\n#include <list>\n#include <unordered_map>\n\nclass Solution {\npublic:\n    /**\n     * @brief Simulates an LRU cache and counts hits and misses.\n     * @param C The capacity of the cache.\n     * @param N The number of memory accesses.\n     * @param accesses A list of memory addresses accessed sequentially.\n     * @return A vector of two integers: {total_hits, total_misses}.\n     */\n    std::vector<int> simulateCacheAccess(int C, int N, const std::vector<int>& accesses) {\n        // Core logic to simulate LRU cache and count hits/misses goes here.\n        // Placeholder implementation:\n        int hits = 0;\n        int misses = 0;\n\n        // The problem suggests an optimized implementation, for example,\n        // using a hash map and a doubly linked list.\n        // std::list<int> lru_list;\n        // std::unordered_map<int, std::list<int>::iterator> cache_map;\n\n        // for (int addr : accesses) {\n        //     // Your logic here\n        // }\n\n        return {hits, misses};\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    int C;\n    std::cin >> C;\n\n    int N;\n    std::cin >> N;\n\n    std::vector<int> accesses(N);\n    for (int i = 0; i < N; ++i) {\n        std::cin >> accesses[i];\n    }\n\n    Solution sol;\n    std::vector<int> result = sol.simulateCacheAccess(C, N, accesses);\n\n    if (result.size() == 2) {\n        std::cout << result[0] << \" \" << result[1] << std::endl;\n    }\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "Razorpay_12oct",
        "company_id": 628
    },
    {
        "id": 1780,
        "title": "Special Numbers",
        "problem_statement": "<h1>Special Numbers</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>A special number is a number in which:</p>\r\n<ul>\r\n    <li>Prime valued indices consist of prime digits</li>\r\n    <li>Non-prime valued indices consist of non-prime digits</li>\r\n</ul>\r\n<p>By indices in a number, we refer to the position of a digit from the left of the number. For example, 534 consists of 5 at index 1, 3 at index 2, and 4 at index 3.</p>\r\n<p><strong>Note:</strong></p>\r\n<ul>\r\n    <li>Prime valued indices are: 2, 3, 5, 7, etc.</li>\r\n    <li>Non-prime valued indices are: 1, 4, 6, 8, etc.</li>\r\n</ul>\r\n<p>You are given three numbers named N, M, and K. Your task is to find out how many N-digit special numbers can be formed that leave a remainder K when divided by M. Since the answer can be very large, print it by taking modulo with 1000000007.</p>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input: N = 3, M = 4, K = 2\r\nOutput: 5</code></pre>\r\n<p><strong>Explanation:</strong> If N = 3, M = 4, K = 2, then there exist only 5 such 3-digit special numbers: 122, 422, 622, 822, 922. All these numbers leave a remainder 2 when divided by 4 and also follow the rules that prime valued indices have prime digits and non-prime valued indices consist of non-prime digits.</p>\r\n\r\n<h2>Function Description</h2>\r\n<p>Complete the `specialNumber` function provided in the editor. The function takes the following 3 parameters and returns the required answer.</p>\r\n<ul>\r\n    <li><strong>N:</strong> Represents the count of digits allowed in special numbers</li>\r\n    <li><strong>M:</strong> Represents the value of M</li>\r\n    <li><strong>K:</strong> Represents the remainder of special number with M</li>\r\n</ul>\r\n\r\n<h2>Input Format</h2>\r\n<ul>\r\n    <li>First line: T (Number of test cases)</li>\r\n    <li>Each of the next T lines: N, M, and K (Three space-separated integers)</li>\r\n</ul>\r\n\r\n<h2>Output Format</h2>\r\n<p>Print the required answer for each test case in a new line.</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>1 &le; T &le; 20</code></li>\r\n    <li><code>1 &le; N &le; 500</code></li>\r\n    <li><code>1 &le; M &le; 500</code></li>\r\n    <li><code>0 &le; K &lt; M</code></li>\r\n</ul>\r\n\r\n<h2>Sample Input</h2>\r\n<pre><code class='language-text'>1\r\n2 2 0</code></pre>\r\n\r\n<h2>Sample Output</h2>\r\n<pre><code class='language-text'>5</code></pre>\r\n\r\n<h2>Explanation</h2>\r\n<p><strong>Input:</strong></p>\r\n<ul>\r\n    <li><code>N = 2</code></li>\r\n    <li><code>M = 2</code></li>\r\n    <li><code>K = 0</code></li>\r\n</ul>\r\n<p>There are 5 possible special numbers: 12, 42, 62, 82, 92.</p>\r\n\r\n<h2>Note</h2>\r\n<p>Your code must be able to print the sample output from the provided sample input. However, your code is run against multiple hidden test cases. Therefore, your code must pass these hidden test cases to solve the problem statement.</p>\r\n\r\n<h3>Limits</h3>\r\n<ul>\r\n    <li>Time Limit: 1.0 sec(s) for each input file</li>\r\n    <li>Memory Limit: 256 MB</li>\r\n    <li>Source Limit: 1024 KB</li>\r\n</ul>\r\n\r\n<h3>Scoring</h3>\r\n<p>Score is assigned if any testcase passes</p>\r\n\r\n<h3>Allowed Languages</h3>\r\n<p>Bash, C, C++14, C++17, Clojure, C#, D, Erlang, F#, Go, Groovy, Haskell, Java 8, Java 14, Java 17, JavaScript(Node.js), Julia, Kotlin, Lisp (SBCL), Lua, Objective-C, OCaml, Octave, Pascal, Perl, PHP, Python, Python 3, Python 3.8, Racket, Ruby, Rust, Scala, Swift, TypeScript, Visual Basic</p>\r\n\r\n<h2>Provided Function Signature (C++)</h2>\r\n<pre><code class='language-cpp'>long long specialNumber (int N, int M, int K) {\r\n    // Write your code here\r\n}\r\n\r\nint main() {\r\n    ios::sync_with_stdio(0);\r\n    cin.tie(0);\r\n    int T;\r\n    cin >> T;\r\n    for (int t_i = 0; t_i < T; t_i++) {\r\n        int N;\r\n        cin >> N;\r\n        int M;\r\n        cin >> M;\r\n        int K;\r\n        cin >> K;\r\n        long long out_ = specialNumber(N, M, K);\r\n        cout << out_;\r\n        cout << \"\\n\";\r\n    }\r\n}</code></pre>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <vector>\n#include <string>\n\nclass Solution {\npublic:\n    long long specialNumber(int N, int M, int K) {\n        // Core logic to solve the problem will be implemented here.\n        // This is a dynamic programming problem.\n        // State could be dp[index][remainder] = count of special numbers of length 'index'\n        // with remainder 'remainder' when divided by M.\n        return 0; // Placeholder\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    int T;\n    std::cin >> T;\n    while (T--) {\n        int N, M, K;\n        std::cin >> N >> M >> K;\n\n        Solution sol;\n        long long result = sol.specialNumber(N, M, K);\n        std::cout << result << \"\\n\";\n    }\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "Razorpay_12oct",
        "company_id": 628
    }
]