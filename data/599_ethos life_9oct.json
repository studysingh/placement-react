[
    {
        "id": 1710,
        "title": "Efficient Scaling",
        "problem_statement": "<h1>Efficient Scaling</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>A data processing pipeline consists of n services connected in series where the output of service i serves as input to service i+1. Each service has varying latency, and the throughput of the i<sup>th</sup> service is represented by throughput[i] in messages per minute.</p>\r\n<p>Each service can be scaled up independently. Scaling up the i<sup>th</sup> service one unit of time costs scalingCost[i], and after scaling up x times, the service can process throughput[i] * (1 + x) messages per minute.</p>\r\n<p>Given throughput and scalingCost arrays of size n, and a budget value, determine the optimal scaling configuration to maximize the throughput of the final service. Return the maximum throughput possible.</p>\r\n<p>Complete the function `getMaximumThroughput` in the editor below.</p>\r\n<p>`getMaximumThroughput` has the following parameters:</p>\r\n<ul>\r\n    <li>`int throughput[]`: the throughput generated by each of the n services</li>\r\n    <li>`int scalingCost[]`: the cost of scaling up a service one time</li>\r\n    <li>`int budget`: the available money</li>\r\n</ul>\r\n<p>Returns</p>\r\n<ul>\r\n    <li>`long int`: the maximum value of the throughput generated at the end of the composite service after scaling within the budget</li>\r\n</ul>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<p><strong>Input:</strong> throughput = [4, 2, 7], scalingCost = [3, 5, 6], budget = 32</p>\r\n<p>To maximize the throughput of the final service, an optimal solution is:</p>\r\n<p><strong>Explanation:</strong> When these units are applied in series, they generate a throughput of 10 units, the maximum possible throughput given the budget. Hence the answer is 10.</p>\r\n\r\n<h3>Example 2:</h3>\r\n<pre><code class='language-text'>Input: n = 3\r\nthroughput = [3, 2, 5]\r\nscalingCost = [2, 5, 10]\r\nbudget = 28\r\nOutput: 6</code></pre>\r\n<p><strong>Explanation:</strong> An optimal solution involves scaling Service 0 by 4 times (cost 8, throughput 15), Service 1 by 2 times (cost 10, throughput 6), and Service 2 by 1 time (cost 10, throughput 6). The total cost is 8 + 10 + 10 = 28, which is within the budget. The minimum throughput across all services is min(15, 6, 6) = 6.</p>\r\n\r\n<h3>Example 3:</h3>\r\n<pre><code class='language-text'>Input: n = 4\r\nthroughput = [7, 3, 4, 6]\r\nscalingCost = [2, 5, 4, 3]\r\nbudget = 25\r\nOutput: 9</code></pre>\r\n<p><strong>Explanation:</strong> An optimal solution involves scaling Service 0 by 1 time (cost 2, throughput 14), Service 1 by 2 times (cost 10, throughput 9), Service 2 by 2 times (cost 8, throughput 12), and Service 3 by 1 time (cost 3, throughput 12). The total cost is 2 + 10 + 8 + 3 = 23, which is within the budget. The minimum throughput across all services is min(14, 9, 12, 12) = 9.</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>1 <= n <= 10<sup>5</sup></code></li>\r\n    <li><code>1 <= throughput[i] <= 10<sup>7</sup></code></li>\r\n    <li><code>1 <= scalingCost[i] <= 200</code></li>\r\n    <li><code>1 <= budget <= 10<sup>9</sup></code></li>\r\n    <li>It is guaranteed that the answer, i.e., the maximum throughput value at the end of the n services is <code>&lt;= 10<sup>9</sup></code>.</li>\r\n</ul>\r\n\r\n<h2>Input Format for Custom Testing</h2>\r\n<p>The first line contains an integer, n, the number of elements in throughput.</p>\r\n<p>Each of the next n lines contains an integer, throughput[i].</p>\r\n<p>The next line contains an integer, n, the number of elements in scalingCost.</p>\r\n<p>Each of the next n lines contains an integer, scalingCost[i].</p>\r\n<p>The next line contains an integer, budget.</p>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nclass Solution {\npublic:\n    long long getMaximumThroughput(const std::vector<int>& throughput, const std::vector<int>& scalingCost, int budget) {\n        // Core logic to find the maximum possible throughput goes here.\n        // This is likely a binary search on the answer problem.\n        // For a given target throughput T, we can calculate the minimum cost\n        // to make every service's throughput at least T.\n        // If this cost is within the budget, we try a higher T; otherwise, a lower T.\n        return 0; // Placeholder return\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    int n;\n\n    std::cin >> n;\n    std::vector<int> throughput(n);\n    for (int i = 0; i < n; ++i) {\n        std::cin >> throughput[i];\n    }\n\n    // The custom input format specifies reading n again\n    std::cin >> n;\n    std::vector<int> scalingCost(n);\n    for (int i = 0; i < n; ++i) {\n        std::cin >> scalingCost[i];\n    }\n\n    int budget;\n    std::cin >> budget;\n\n    Solution sol;\n    long long result = sol.getMaximumThroughput(throughput, scalingCost, budget);\n\n    std::cout << result << std::endl;\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "ethos life_9oct",
        "company_id": 599
    },
    {
        "id": 1711,
        "title": "Track Command Position",
        "problem_statement": "<h1>Track Command Position</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>A network contains <code>n</code> nodes, where node 1 is the root node. The network structure is represented as a tree, with each node (except the root) having exactly one parent specified by the array <code>par</code>, where <code>par[i]</code> represents the parent of node <code>i</code> (1-based indexing).</p>\r\n<p>Commands propagate through the network as follows:</p>\r\n<ul>\r\n    <li>A node sends the command to its direct child nodes in ascending order of their indices.</li>\r\n    <li>Each child node propagates the command to its subtree using the same process.</li>\r\n    <li>The propagation stops when all nodes in the subtree have received the command.</li>\r\n</ul>\r\n<p>Given <code>q</code> queries, each query <code>(startNode[i], index[i])</code> asks for the <code>index[i]</code><sup>th</sup> node in the sequence of command propagation starting from node <code>startNode[i]</code>. Return the <code>index[i]</code><sup>th</sup> node or -1 if fewer than <code>index[i]</code> nodes receive the command. Each query is processed independently.</p>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>n = 9\r\npar = [-1, 1, 1, 3, 5, 3, 5, 7]\r\nq = 4\r\nquery = [[1, 5], [7, 2], [9, 2], [3, 6]]</code></pre>\r\n<p><strong>Explanation:</strong>\r\nThe tree structure based on <code>par</code> is:</p>\r\n<p>\r\n    <img src=\"https://i.imgur.com/example1_tree.png\" alt=\"Tree structure for Example 1\">\r\n    <!-- Placeholder for the tree image, as I cannot generate it. In a real scenario, this would be a direct image link. -->\r\n</p>\r\n<p>If node 1 sends a command, the nodes receive it in the following order: <code>[1, 2, 3, 5, 6, 8, 7, 9, 4]</code>.</p>\r\n<p>If node 3 sends a command, the nodes receive it in the following order: <code>[3, 5, 6, 8, 7, 9]</code>.</p>\r\n<p>If node 7 sends a command, the nodes receive it in the following order: <code>[7, 9]</code>.</p>\r\n<p>If node 9 sends a command, the nodes receive it in the following order: <code>[9]</code>.</p>\r\n<p>So, on processing the queries:</p>\r\n<ol>\r\n    <li><code>query[0] = [1, 5]</code>: If node 1 sends a command, the 5<sup>th</sup> node receiving it would be 6.</li>\r\n    <li><code>query[1] = [7, 2]</code>: If node 7 sends a command, the 2<sup>nd</sup> node receiving it would be 9.</li>\r\n    <li><code>query[2] = [9, 2]</code>: If node 9 sends a command, there's no 2<sup>nd</sup> node to receive it.</li>\r\n    <li><code>query[3] = [3, 6]</code>: If node 3 sends a command, the 6<sup>th</sup> node receiving it would be 9.</li>\r\n</ol>\r\n<pre><code class='language-text'>Output: [6, 9, -1, 9]</code></pre>\r\n\r\n<h3>Example 2 (Sample Case 0):</h3>\r\n<pre><code class='language-text'>Input:\r\nn = 5\r\npar = [-1, 1, 1, 2, 2]\r\nq = 2\r\nquery = [[1, 3], [2, 3]]</code></pre>\r\n<p><strong>Explanation:</strong>\r\nThe tree structure based on <code>par</code> is:</p>\r\n<p>\r\n    <img src=\"https://i.imgur.com/example2_tree.png\" alt=\"Tree structure for Example 2\">\r\n    <!-- Placeholder for the tree image -->\r\n</p>\r\n<p>If node 1 sends a command, the nodes receive it in the following order: <code>[1, 2, 4, 5, 3]</code>.</p>\r\n<p>If node 2 sends a command, the nodes receive it in the following order: <code>[2, 4, 5]</code>.</p>\r\n<p>So, on processing the queries:</p>\r\n<ol>\r\n    <li><code>query[0] = [1, 3]</code>: If node 1 sends a command, the 3<sup>rd</sup> node, node 4, receives it.</li>\r\n    <li><code>query[1] = [2, 3]</code>: If node 2 sends a command, the 3<sup>rd</sup> node, node 5, receives it.</li>\r\n</ol>\r\n<pre><code class='language-text'>Output: [4, 5]</code></pre>\r\n\r\n<h3>Example 3 (Sample Case 1):</h3>\r\n<pre><code class='language-text'>Input:\r\nn = 7\r\npar = [-1, 1, 1, 2, 3, 1, 6]\r\nq = 3\r\nquery = [[2, 4], [7, 1], [1, 6]]</code></pre>\r\n<p><strong>Explanation:</strong>\r\nThe tree structure based on <code>par</code> is:</p>\r\n<p>\r\n    <img src=\"https://i.imgur.com/example3_tree.png\" alt=\"Tree structure for Example 3\">\r\n    <!-- Placeholder for the tree image -->\r\n</p>\r\n<p>If node 2 sends a command, the nodes receive it in the following order: <code>[2, 4]</code>.</p>\r\n<p>If node 7 sends a command, the nodes receive it in the following order: <code>[7]</code>.</p>\r\n<p>If node 1 sends a command, the nodes receive it in the following order: <code>[1, 2, 4, 3, 5, 6, 7]</code>.</p>\r\n<p>So, on processing the queries:</p>\r\n<ol>\r\n    <li><code>query[0] = [2, 4]</code>: If node 2 sends a command, there is no 4<sup>th</sup> node to receive it.</li>\r\n    <li><code>query[1] = [7, 1]</code>: If node 7 sends a command, the 1<sup>st</sup> node, node 7, receives it.</li>\r\n    <li><code>query[2] = [1, 6]</code>: If node 1 sends a command, the 6<sup>th</sup> node, node 6, receives it.</li>\r\n</ol>\r\n<pre><code class='language-text'>Output: [-1, 7, 6]</code></pre>\r\n\r\n<h2>Function Description</h2>\r\n<p>Complete the function <code>getAnswersToQueries</code> in the editor with the following parameters:</p>\r\n<p><strong>Parameters:</strong></p>\r\n<ul>\r\n    <li><code>int[] par</code>: Each <code>par[i]</code> represents the parent of the <code>i</code><sup>th</sup> node.</li>\r\n    <li><code>int[][] query</code>: Each <code>query[i]</code> consists of <code>[startNode[i], index[i]]</code>.</li>\r\n</ul>\r\n<p><strong>Returns:</strong></p>\r\n<ul>\r\n    <li><code>int[]</code>: an array of integers of size <code>q</code> representing answers to the queries.</li>\r\n</ul>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>2 <= n <= 10^5</code></li>\r\n    <li><code>1 <= par[i] <= n</code> for all nodes except the root node. <code>par[0] = -1</code></li>\r\n    <li><code>1 <= q <= 2 * 10^5</code></li>\r\n    <li><code>1 <= query[i][0] <= n</code></li>\r\n    <li><code>1 <= query[i][1] <= n</code></li>\r\n</ul>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nclass Solution {\npublic:\n    std::vector<int> getAnswersToQueries(int n, const std::vector<int>& par, const std::vector<std::vector<int>>& query) {\n        // Core logic to be implemented here\n        return {};\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    int n;\n    std::cin >> n;\n\n    std::vector<int> par(n);\n    for (int i = 0; i < n; ++i) {\n        std::cin >> par[i];\n    }\n\n    int q;\n    std::cin >> q;\n\n    std::vector<std::vector<int>> query(q, std::vector<int>(2));\n    for (int i = 0; i < q; ++i) {\n        std::cin >> query[i][0] >> query[i][1];\n    }\n\n    Solution sol;\n    std::vector<int> result = sol.getAnswersToQueries(n, par, query);\n\n    for (size_t i = 0; i < result.size(); ++i) {\n        std::cout << result[i] << (i == result.size() - 1 ? \"\" : \" \");\n    }\n    std::cout << std::endl;\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "ethos life_9oct",
        "company_id": 599
    }
]