[
    {
        "id": 1340,
        "title": "Word Search in a 2D Grid",
        "problem_statement": "```html\r\n<h1>Word Search in a 2D Grid</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>You're developing the core algorithm for a next-generation word puzzle game that combines elements of Scrabble and Boggle. The game is played on a large grid where players must find words from a massive dictionary.</p>\r\n<p>The challenge is to, given a 2D grid of characters and a dictionary of words, find all words from the dictionary that can be formed in the grid.</p>\r\n<p>A word can be formed by a sequence of adjacent letters in the grid. The rules are as follows:</p>\r\n<ul>\r\n    <li>Adjacent cells are connected in 8 directions (horizontally, vertically, and diagonally).</li>\r\n    <li>The same letter cell may not be used more than once in a single word.</li>\r\n</ul>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'><strong>Input:</strong> \r\nboard = [['o','a','a','n'],['e','t','a','e'],['i','h','k','r'],['i','f','l','v']]\r\ndictionary = [\"oath\",\"pea\",\"eat\",\"rain\",\"oat\",\"cat\",\"oath\",\"hike\",\"kite\"]\r\n<strong>Output:</strong> [\"eat\",\"oath\",\"oat\"]</code></pre>\r\n<p><strong>Explanation:</strong>\r\n- \"oath\": o(0,0) -> a(0,1) -> t(1,1) -> h(2,1)\r\n- \"eat\": e(1,0) -> a(0,1) -> t(1,1)\r\n- \"oat\": o(0,0) -> a(0,1) -> t(1,1)\r\nNote: \"hike\" cannot be formed as h(2,1)->i(2,0)->k(2,2) is invalid (i and k are not adjacent).</p>\r\n\r\n<h3>Example 2:</h3>\r\n<pre><code class='language-text'><strong>Input:</strong> \r\nboard = [['a','b','c','e'],['s','f','e','s'],['a','d','e','e']]\r\ndictionary = [\"abceseefs\", \"see\", \"seed\", \"ased\", \"sad\"]\r\n<strong>Output:</strong> [\"abceseefs\", \"abs\", \"sad\", \"see\", \"seed\"]</code></pre>\r\n<p><strong>Explanation:</strong> Requires careful backtracking and comprehensive search to find ALL valid words.</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><strong>Grid Size:</strong> 1 &le; m, n &le; 20 (where m x n &le; 400)</li>\r\n    <li><strong>Dictionary Size:</strong> 1 &le; words.length &le; 100,000</li>\r\n    <li><strong>Word Length:</strong> 1 &le; word.length &le; 20</li>\r\n    <li><strong>Characters:</strong> Only lowercase English letters</li>\r\n    <li><strong>Time Limit:</strong> 2 seconds maximum execution time</li>\r\n    <li><strong>Memory Limit:</strong> Must use optimal space complexity</li>\r\n</ul>\r\n\r\n<h2>Custom I/O Format</h2>\r\n<p>The input should be read from standard input (stdin) and the output should be written to standard output (stdout).</p>\r\n\r\n<h3>Input Format</h3>\r\n<p>The input is structured as follows:</p>\r\n<pre><code class='language-text'>rows cols\r\nboard (rows lines, each with cols space-separated characters)\r\nnum_words\r\ndictionary (num_words lines, each containing one word)</code></pre>\r\n<ul>\r\n    <li><strong>Line 1:</strong> <code>rows cols</code> (dimensions of the character grid)</li>\r\n    <li><strong>Next <code>rows</code> lines:</strong> Each line contains <code>cols</code> space-separated characters for the board.</li>\r\n    <li><strong>Line <code>rows + 2</code>:</strong> <code>num_words</code> (number of dictionary words to search for)</li>\r\n    <li><strong>Next <code>num_words</code> lines:</strong> Each line contains one dictionary word.</li>\r\n</ul>\r\n\r\n<h3>Output Format</h3>\r\n<p>The output should be formatted as follows:</p>\r\n<pre><code class='language-text'>count\r\nfound_word_1\r\nfound_word_2\r\n...\r\nfound_word_n</code></pre>\r\n<ul>\r\n    <li><strong>Line 1:</strong> An integer representing the total number of words found in the grid.</li>\r\n    <li><strong>Following lines:</strong> Each found word on a separate line, sorted alphabetically.</li>\r\n    <li>If no words are found, output only \"0\".</li>\r\n</ul>\r\n\r\n<h3>Sample Custom I/O</h3>\r\n<p><strong>Sample Input:</strong></p>\r\n<pre><code class='language-text'>4 4\r\no a a n\r\ne t a e\r\ni h k r\r\ni f l v\r\n9\r\noath\r\npea\r\neat\r\nrain\r\noat\r\ncat\r\nhike\r\nkite\r\nduplicate</code></pre>\r\n<p><strong>Sample Output:</strong></p>\r\n<pre><code class='language-text'>3\r\neat\r\noat\r\noath</code></pre>\r\n```",
        "google_doc_link": null,
        "solution_code": null,
        "company_name": "Cisco_3sep",
        "company_id": 466
    },
    {
        "id": 1341,
        "title": "Optimal Seed Influencers",
        "problem_statement": "```html\r\n<h1>Optimal Seed Influencers</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>Your team at a leading tech company is launching a cutting-edge networking product. To generate buzz, you're running a targeted social media campaign. You have a limited marketing budget to send premium trial units to a select group of \"seed\" influencers on a professional network. Each potential influencer has a different cost to engage (e.g., the cost of the trial unit or compensation). Furthermore, not all users in the network are equally valuable to the campaign: each user has an associated market value based on their role and influence (e.g., a 'Lead Network Architect' is more valuable than an 'Intern').</p>\r\n<p>Your task is to develop an algorithm that selects the optimal set of seed influencers. The \"optimal set\" is the one that maximizes the total market value of all unique users reached by the campaign, without exceeding the given budget. Influence spreads from the seeds to their friends, their friends-of-friends, and so on, up to a specified depth <strong>d</strong>.</p>\r\n<p>A brute-force approach that checks every possible combination of seeds is computationally infeasible. You will need to devise a more clever heuristic to find a high-quality solution.</p>\r\n\r\n<h3>Input</h3>\r\n<ul>\r\n    <li><strong>connections</strong>: A list of pairs representing the connections between users. User IDs are integers. Example: <code>[[1, 2], [2, 3]]</code>.</li>\r\n    <li><strong>costs</strong>: A dictionary (or map) where keys are integer user IDs and values are their corresponding costs to be selected as a seed. Users not in this map cannot be chosen as seeds. Example: <code>{1: 50, 2: 60}</code>.</li>\r\n    <li><strong>values</strong>: A dictionary (or map) where keys are integer user IDs and values are their market value. Example: <code>{1: 10, 2: 15}</code>.</li>\r\n    <li><strong>budget</strong>: A single integer representing the total available budget for the campaign.</li>\r\n    <li><strong>d</strong>: A single integer representing the maximum connection depth (or degrees of separation) for the campaign's reach. d=1 means only direct friends are reached.</li>\r\n</ul>\r\n\r\n<h3>Input Format</h3>\r\n<p>The input should be read from standard input (stdin) in the following format:</p>\r\n<pre><code class='language-text'>no_of_users\r\nno_of_connections\r\n(connection_pairs, one pair per line: user1 user2)\r\n...\r\nno_of_potential_seeds\r\n(seed_data, one pair per line: user_id cost)\r\n...\r\n(n space-separated values)\r\nbudget\r\ndepth\r\n</code></pre>\r\n\r\n<h3>Detailed Input Format:</h3>\r\n<ul>\r\n    <li>Line 1: <code>n</code> (number of users, users are numbered from 1 to n)</li>\r\n    <li>Line 2: <code>num_connections</code> (number of connections)</li>\r\n    <li>Next <code>num_connections</code> lines: Two integers <code>u v</code> representing a connection between user u and user v.</li>\r\n    <li>Line after connections: <code>num_potential_seeds</code> (number of potential seeds)</li>\r\n    <li>Next <code>num_potential_seeds</code> lines: Two integers <code>user_id cost</code> representing a potential seed and its cost.</li>\r\n    <li>Line after seeds: <code>n</code> space-separated integers representing the value of each user (the i-th value is for user i+1).</li>\r\n    <li>Next line: <code>budget</code> (total available budget).</li>\r\n    <li>Next line: <code>depth</code> (maximum influence depth).</li>\r\n</ul>\r\n\r\n<h3>Output</h3>\r\n<p>A tuple or structure containing three elements:</p>\r\n<ol>\r\n    <li>A list of the integer user IDs chosen as seeds, in the order they were selected.</li>\r\n    <li>The total market value reached by this set of seeds.</li>\r\n    <li>The total cost of the chosen seeds.</li>\r\n</ol>\r\n\r\n<h2>Examples</h2>\r\n\r\n<h3>Example 1: The High-Efficiency Choice</h3>\r\n<p>This example demonstrates a straightforward case where one candidate is clearly the most efficient first choice.</p>\r\n<pre><code class='language-text'><strong>Input:</strong>\r\nconnections: [[1, 2], [1, 3], [4, 5]]\r\ncosts: {1: 50, 4: 60}\r\nvalues: {1: 10, 2: 20, 3: 30, 4: 5, 5: 5}\r\nbudget: 100\r\nd: 1\r\n\r\n<strong>Output:</strong>\r\nChosen Seeds: [1]\r\nTotal Value: 60\r\nTotal Cost: 50\r\n</code></pre>\r\n<p><strong>Explanation:</strong> The algorithm must decide which seed to pick first. Let's analyze the initial efficiency (total_value / cost) of the potential seeds.</p>\r\n<ul>\r\n    <li><strong>Choose Seed 1:</strong> Cost: 50. Reach (d=1): {1, 2, 3}. Value: 10 + 20 + 30 = 60. Efficiency: 60 / 50 = 1.2.</li>\r\n    <li><strong>Choose Seed 4:</strong> Cost: 60. Reach (d=1): {4, 5}. Value: 5 + 5 = 10. Efficiency: 10 / 60 â‰ˆ 0.17.</li>\r\n</ul>\r\n<p>Seed 1 offers the highest value-per-cost. We select User 1. The cost is 50, and the remaining budget is 50. The users reached are now {1, 2, 3}. Next, the algorithm checks if it can add another seed. The only other potential seed (User 4) costs 60, which exceeds the remaining budget of 50. The algorithm stops.</p>\r\n\r\n<h3>Example 2: The Marginal Gain Choice</h3>\r\n<p>This example shows how the algorithm must account for overlapping reach when making its second choice.</p>\r\n<pre><code class='language-text'><strong>Input:</strong>\r\nconnections: [[1, 2], [1, 3], [4, 3], [4, 5]]\r\ncosts: {1: 60, 4: 70}\r\nvalues: {1: 5, 2: 10, 3: 20, 4: 5, 5: 30}\r\nbudget: 150\r\nd: 1\r\n\r\n<strong>Output:</strong>\r\nChosen Seeds: [4, 1]\r\nTotal Value: 70\r\nTotal Cost: 130\r\n</code></pre>\r\n<p><strong>Explanation:</strong></p>\r\n<p><strong>Iteration 1: Find the first seed.</strong></p>\r\n<ul>\r\n    <li><strong>Candidate 1:</strong> Cost=60. Reach={1, 2, 3}. Value=5+10+20=35. Efficiency=35/60 â‰ˆ 0.58.</li>\r\n    <li><strong>Candidate 4:</strong> Cost=70. Reach={3, 4, 5}. Value=20+5+30=55. Efficiency=55/70 â‰ˆ 0.78.</li>\r\n</ul>\r\n<p>Seed 4 is more efficient and is chosen first.</p>\r\n<ul>\r\n    <li><strong>State:</strong> Seeds=[4], Cost=70, Reached={3, 4, 5}, Value=55, Budget Left=80.</li>\r\n</ul>\r\n<p><strong>Iteration 2: Find the second seed.</strong></p>\r\n<p>The only affordable candidate is User 1 (cost 60 â‰¤ budget 80). We calculate its marginal gain.</p>\r\n<ul>\r\n    <li><strong>Candidate 1 (Marginal Gain):</strong>\r\n        <ul>\r\n            <li>Cost: 60.</li>\r\n            <li>Full Reach: {1, 2, 3}.</li>\r\n            <li>New Users added: {1, 2, 3} - {3, 4, 5} = {1, 2}.</li>\r\n            <li>Marginal Value: values[1] + values[2] = 5 + 10 = 15.</li>\r\n            <li>Marginal Efficiency: 15 / 60 = 0.25.</li>\r\n        </ul>\r\n    </li>\r\n</ul>\r\n<p>Since this choice adds positive value and is within budget, we select User 1.</p>\r\n<ul>\r\n    <li><strong>Final State:</strong> Seeds=[4, 1], Cost=70+60=130, Value=55+15=70.</li>\r\n</ul>\r\n```",
        "google_doc_link": null,
        "solution_code": null,
        "company_name": "Cisco_3sep",
        "company_id": 466
    }
]