[
    {
        "id": 1877,
        "title": "Positive Product",
        "problem_statement": "<h1>Positive Product</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>You are given a sequence of n integers and you have to find the maximum length of a segment which gives positive product.</p>\r\n<p>Complete the <code>maxLength</code> function in your editor. It has 1 parameters:</p>\r\n<ol>\r\n    <li>An array, <code>arr</code>, containing n elements of the sequence.</li>\r\n</ol>\r\n<p>It must return an integer denoting the maximum length of a segment which gives positive product.</p>\r\n\r\n<h2>Input Format</h2>\r\n<p>The locked stub code in your editor reads the following input from stdin and passes it to your function:</p>\r\n<p>First line contains number of integers n in the sequence.</p>\r\n<p>Followed by n lines each contains an element.</p>\r\n\r\n<h2>Output Format</h2>\r\n<p>Your function must return an integer denoting the maximum length of a segment which gives positive product. This is printed to stdout by the locked stub code in your editor.</p>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input:\r\n4\r\n1\r\n-2\r\n-3\r\n4\r\nOutput:\r\n4</code></pre>\r\n<p><strong>Explanation:</strong> Here maximum product is 1 x -2 x -3 x 4 = 24.</p>\r\n\r\n<h3>Example 2:</h3>\r\n<pre><code class='language-text'>Input:\r\n2\r\n-3\r\n5\r\nOutput:\r\n1</code></pre>\r\n<p><strong>Explanation:</strong> Here if we multiply both the two numbers then our product will be -3 x 5 = -15. Whether if we take only 5 it will give us maximum product.</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>1 <= n <= 1000</code></li>\r\n    <li>Absolute value of each number is greater than 0 and less than or equal to 1000.</li>\r\n</ul>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <numeric>\n\nclass Solution {\npublic:\n    int maxLength(const std::vector<int>& arr) {\n        // Core logic to find the maximum length of a segment with a positive product.\n        return 0;\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    int n;\n    std::cin >> n;\n\n    std::vector<int> arr(n);\n    for (int i = 0; i < n; ++i) {\n        std::cin >> arr[i];\n    }\n\n    Solution solution;\n    int result = solution.maxLength(arr);\n\n    std::cout << result << std::endl;\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "Arcesium_16oct",
        "company_id": 660
    },
    {
        "id": 1878,
        "title": "Hydrate the nodes",
        "problem_statement": "```html\r\n<h1>Hydrate the nodes</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>There is a tree with n nodes. The tree is rooted at node with number 0. As usually in computer science, the tree grows upside down comparing to trees existing in nature. Apples grow on nodes of this tree. Some of these apples are underhydrated, some are overhydrated, and others are neither. You know that for each overhydrated apple you'll get <code>overhydratedPenalty</code> cents and for every underhydrated you'll get <code>underhydratedPenalty</code> cents.</p>\r\n<p>Now, you want to pour water on exactly one node of the tree. When you pour water on node v, all apples that are in v's subtree, i.e. v itself and all descendants of v, will be hydrated and in consequence, each hydrated apple that was almost underhydrated becomes overhydrated. Moreover, every apple in the whole tree that was almost underhydrated and no water was poured on it gets underhydrated.</p>\r\n<p>Calculate the minimum total penalty you can get from pouring water on exactly one node of the tree.</p>\r\n\r\n<p>Complete the function <code>minimumPouringWaterPenalty</code> the editor below.</p>\r\n<p><code>minimumPouringWaterPenalty</code> has the following parameter(s):</p>\r\n<ul>\r\n    <li>An integer array, <code>parent</code>, of size n, where <code>parent[i]</code> denotes the parent of the <code>i</code>th node.</li>\r\n    <li>An integer array, <code>waterLevel</code>, of size n, where <code>waterLevel[i]</code> denotes the level of the water in the apple on node i. It's either -1, 0 or 1 where -1 stands for almost underhydrated, 0 stands for neither almost underhydrated nor almost overhydrated and 1 stands for almost overhydrated.</li>\r\n    <li>An integer, <code>overhydratedPenalty</code>, denoting the penalty for each overhydrated apple.</li>\r\n    <li>An integer, <code>underhydratedPenalty</code>, denoting the penalty for each underhydrated apple.</li>\r\n</ul>\r\n<p>The function must return the minimum penalty that you can get by pouring water on exactly one node of the tree.</p>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input:\r\n3\r\n-1\r\n0\r\n0\r\n3\r\n0\r\n1\r\n0\r\n1\r\n1\r\nOutput:\r\n0</code></pre>\r\n<p><strong>Explanation:</strong> The best we can do is to pour water on node 2, which is the only underhydrated node and doesn't have any descendants. Thus, it gets hydrated and none of the nodes becomes overhydrated, so the total penalty will be 0.</p>\r\n\r\n<h3>Example 2:</h3>\r\n<pre><code class='language-text'>Input:\r\n3\r\n-1\r\n0\r\n0\r\n3\r\n-1\r\n-1\r\n1\r\n10\r\n15\r\nOutput:\r\n10</code></pre>\r\n\r\n<h3>Example 3:</h3>\r\n<pre><code class='language-text'>Input:\r\n4\r\n-1\r\n0\r\n1\r\n0\r\n4\r\n0\r\n1\r\n0\r\n0\r\n7\r\n2\r\nOutput:\r\n0</code></pre>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>1 &le; n &le; 10<sup>5</sup></code></li>\r\n    <li><code>parent[0] = -1</code></li>\r\n    <li><code>0 &le; parent[i] &le; i</code>, for <code>i &gt; 0</code></li>\r\n    <li><code>waterLevel[i]</code> is either -1, 0 or 1</li>\r\n    <li><code>1 &le; overhydratedPenalty, underhydratedPenalty &le; 10<sup>3</sup></code></li>\r\n</ul>\r\n\r\n<h2>Input Format for Custom Testing</h2>\r\n<p>Input from stdin will be processed as follows and passed to the function.</p>\r\n<p>In the first line, there is a single integer n.</p>\r\n<p>Then, n lines follow. The <code>i</code>th of them contains the value <code>parent[i]</code>.</p>\r\n<p>In the next line, there is a single integer n.</p>\r\n<p>Then, n lines follow. The <code>i</code>th of them contains the value <code>waterLevel[i]</code>.</p>\r\n<p>In the next line, there is a single integer <code>overhydratedPenalty</code>.</p>\r\n<p>In the next line, there is a single integer <code>underhydratedPenalty</code>.</p>\r\n```",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nclass Solution {\npublic:\n    long long minimumPouringWaterPenalty(const std::vector<int>& parent, const std::vector<int>& waterLevel, int overhydratedPenalty, int underhydratedPenalty) {\n        // Core logic goes here\n        return 0;\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    int n;\n    std::cin >> n;\n\n    std::vector<int> parent(n);\n    for (int i = 0; i < n; ++i) {\n        std::cin >> parent[i];\n    }\n\n    int n_again;\n    std::cin >> n_again;\n\n    std::vector<int> waterLevel(n);\n    for (int i = 0; i < n; ++i) {\n        std::cin >> waterLevel[i];\n    }\n\n    int overhydratedPenalty;\n    std::cin >> overhydratedPenalty;\n\n    int underhydratedPenalty;\n    std::cin >> underhydratedPenalty;\n\n    Solution sol;\n    long long result = sol.minimumPouringWaterPenalty(parent, waterLevel, overhydratedPenalty, underhydratedPenalty);\n\n    std::cout << result << std::endl;\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "Arcesium_16oct",
        "company_id": 660
    }
]