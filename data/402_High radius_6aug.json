[
    {
        "id": 1189,
        "title": "Unfair Multiverse",
        "problem_statement": "<h1>Unfair Multiverse</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>One of most bizarre theories in modern era is of \"Multiverse\". It says that there exists not just a single Universe but multiple universes running parallelly! So for every possible outcome of an event, there exists a universe in which it is the ground truth! So maybe you have crush on someone in this universe but there exists another parallel universe where they have crush on you! Ok enough pretext, let's get to problem.</p>\r\n<p>You are God and you represent poverty of N people as an array of N integers. Event is breaking this array into a contagious subarray. For this event there will be N * (N+1) / 2 contagious subarrays possible each of which goes to a multiverse, so every multiverse has a unique subarray representing a population. Let's define unfairness of a subarray as difference between maximum integer and minimum integer. You need to find sum of unfairness of all multiverse.</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li>1 &lt;= N &lt;= 1000000</li>\r\n    <li>0 &lt;= ai &lt; 1000000</li>\r\n</ul>\r\n\r\n<h2>Input</h2>\r\n<p>First line contains an integer N, representing number of integers in original array.</p>\r\n<p>The second line will contain N integers a1, a2,...,aN representing poverty of every person separated by space</p>\r\n\r\n<h2>Output</h2>\r\n<p>Single Integer, which is sum of unfairness across all multiverse.</p>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input:\r\n3\r\n2 3 1\r\nOutput:\r\n5</code></pre>\r\n<p><strong>Explanation:</strong> Here are all possible parallel 6 multiverse with their corresponding subarrays:-</p>\r\n<ul>\r\n    <li>2 - value of unfairness in this universe = 2-2 = 0</li>\r\n    <li>3 - value of unfairness in this universe = 3-3 = 0</li>\r\n    <li>1 - value of unfairness in this universe = 1-1 = 0</li>\r\n    <li>2 3 - value of unfairness in this universe = 3-2 = 1</li>\r\n    <li>3 1 - value of unfairness in this universe = 3-1 = 2</li>\r\n    <li>2 3 1 - value of unfairness in this universe = 3-1 = 2</li>\r\n</ul>\r\n<p>Their sum is 5.</p>",
        "google_doc_link": null,
        "solution_code": null,
        "company_name": "High radius_6aug",
        "company_id": 402
    },
    {
        "id": 1190,
        "title": "Custom HashMap",
        "problem_statement": "<h1>Custom HashMap</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>In this problem, you are tasked with implementing a simplified associative array, commonly known as a hash map. Your implementation will store key-value pairs, where keys are strings and values are 64-bit integers.</p>\r\n<p>You must support three operations:</p>\r\n<ul>\r\n    <li><strong>PUT key value</strong> — Insert a pair (key, value) into the map. If the key already exists, its associated value should be updated to the new value. This operation should not produce any output.</li>\r\n    <li><strong>GET key</strong> — Retrieve the value associated with the given key. If the key exists, print its value. Otherwise, print the string <code>null</code>.</li>\r\n    <li><strong>REMOVE key</strong> — Remove the entry for the given key. If the key existed, print the value that was removed. Otherwise, print the string <code>null</code>.</li>\r\n</ul>\r\n\r\n<h2>Constraints</h2>\r\n<p>Your implementation must adhere to the following specific technical requirements:</p>\r\n<ul>\r\n    <li><strong>Hashing:</strong> You must implement your own hashing function for string keys. You are not allowed to use any built-in hashing functions or library map implementations (e.g., <code>java.util.HashMap</code>).</li>\r\n    <li><strong>Collision Handling:</strong> Collisions must be resolved using the separate chaining method. This means each slot in your hash table's underlying array should be a bucket that can store multiple entries, typically as a linked list.</li>\r\n    <li><strong>Resizing:</strong> Your hash map must support automatic resizing (also known as rehashing). The rules for resizing are:\r\n        <ul>\r\n            <li>The map must start with an initial capacity of at least 16.</li>\r\n            <li>The capacity of the map's underlying array must always be a power of two.</li>\r\n            <li>A load factor threshold of 0.75 must be maintained. The load factor is defined as the number of entries divided by the capacity (<code>size / capacity</code>).</li>\r\n            <li>When adding a new element causes the load factor to exceed 0.75, the capacity must be doubled. All existing entries must be re-hashed and placed into the new, larger array.</li>\r\n        </ul>\r\n    </li>\r\n    <li><strong>Allowed Structures:</strong> You may only use primitive arrays and your own custom classes/structs. The use of standard library collections like <code>ArrayList</code>, <code>LinkedList</code>, etc., is forbidden.</li>\r\n    <li><strong>Hash Function:</strong> A simple and effective string hashing algorithm is the polynomial rolling hash. For a string <code>S</code> of length <code>n</code>, the hash value <code>H(S)</code> is calculated as:\r\n        <p>H(S) = &sum;<sub>i=0</sub><sup>n-1</sup> S[i] &middot; p<sup>i</sup></p>\r\n        <p>Here, <code>S[i]</code> is the ASCII value of the character at index <code>i</code>, and <code>p</code> is a small prime number (e.g., 31 or 37). Be mindful of potential integer overflows during this calculation.</p>\r\n    </li>\r\n    <li><strong>Index Calculation:</strong> To convert the calculated hash code into a valid array index, the standard method is to use the modulo operator:\r\n        <pre><code class='language-text'>index = hash % capacity</code></pre>\r\n        <p>However, a significant performance optimization is possible when the table's capacity is chosen to be a power of two (e.g., 16, 32, 64, etc.). In this specific case, the computationally expensive modulo operation can be replaced by a much faster bitwise AND operation:</p>\r\n        <pre><code class='language-text'>index = hash & (capacity - 1)</code></pre>\r\n        <p>This is a standard technique used to build high-performance hash tables, as bitwise operations are significantly faster for a CPU to execute than division or modulo operations.</p>\r\n    </li>\r\n</ul>\r\n\r\n<h3>Input</h3>\r\n<p>The first line contains an integer <code>Q</code> (1 &le; <code>Q</code> &le; 200,000)&mdash;the number of operations.</p>\r\n<p>The next <code>Q</code> lines each describe one operation as one of:</p>\r\n<ul>\r\n    <li><code>PUT key value</code></li>\r\n    <li><code>GET key</code></li>\r\n    <li><code>REMOVE key</code></li>\r\n</ul>\r\n<p>Here, <code>key</code> is a non-empty ASCII string, 1 &le; |<code>key</code>| &le; 40, consisting of English letters, digits, and underscores (<code>[A-Za-z0-9_]</code>); <code>value</code> is an integer in <code>[-10<sup>18</sup>, 10<sup>18</sup>]</code>.</p>\r\n\r\n<h3>Output</h3>\r\n<p>Output one line for each operation that produces a result:</p>\r\n<ul>\r\n    <li>For <strong>GET key</strong>: print the associated value, or <code>null</code> if the key is absent.</li>\r\n    <li>For <strong>REMOVE key</strong>: print the removed value, or <code>null</code> if the key did not exist.</li>\r\n    <li>For <strong>PUT</strong> operations: do not produce any output.</li>\r\n</ul>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input:\r\n7\r\nPUT key1 100\r\nPUT key1 200\r\nGET key1\r\nPUT key1 300\r\nGET key1\r\nREMOVE key1\r\nGET key1\r\n\r\nOutput:\r\n200\r\n300\r\n300\r\nnull</code></pre>\r\n<p><strong>Explanation:</strong></p>\r\n<ol>\r\n    <li><strong>PUT key1 100</strong> Insert the key \"key1\" with value 100 into the map. Since it is a new key, no output is produced.</li>\r\n    <li><strong>PUT key1 200</strong> The key \"key1\" already exists, so update its value to 200. No output.</li>\r\n    <li><strong>GET key1</strong> Retrieve the value for \"key1\", which is currently 200. Output: 200</li>\r\n    <li><strong>PUT key1 300</strong> Update the value for \"key1\" to 300. No output.</li>\r\n    <li><strong>GET key1</strong> Output the current value of \"key1\" which is 300. Output: 300</li>\r\n    <li><strong>REMOVE key1</strong> Remove the key \"key1\" from the map and print the removed value. Output: 300</li>\r\n    <li><strong>GET key1</strong> Since \"key1\" was removed, it no longer exists. Output: null</li>\r\n</ol>",
        "google_doc_link": null,
        "solution_code": null,
        "company_name": "High radius_6aug",
        "company_id": 402
    }
]