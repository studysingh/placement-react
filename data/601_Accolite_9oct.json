[
    {
        "id": 1713,
        "title": "Water Fountain",
        "problem_statement": "<h1>Water Fountain</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>You are on a family vacation and visiting a ring road with several water fountains.</p>\r\n<p>Each fountain provides a certain amount of water, represented by the number of water droplets at that fountain.</p>\r\n<p>Additionally, there is a water bottle that you can fill up at each fountain. The amount of water that bottle can hold represents the capacity.</p>\r\n<p>It costs <code>cost[i]</code> for a certain number of water droplets to walk from <code>ith</code> fountain to the <code>[i+1]th</code> fountain.</p>\r\n<p>You begin with the empty water bottle at one of the fountains.</p>\r\n<p>Given two integer arrays <code>'water'</code> and <code>'cost'</code> representing the number of water droplets at each fountain and the cost of traveling between fountains.</p>\r\n<p>Find the starting fountain index where you can fill up the bottle in such a way that you can make a complete round path once in the clockwise direction without running out of water, otherwise return -1.</p>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input: water = [1,2,3,4,5], cost = [3,4,5,1,2]\r\nOutput: 3</code></pre>\r\n<p><strong>Explanation:</strong></p>\r\n<p>Start at fountain 3 (index 3) and fill up with 4 units of water. Your bottle = 0 + 4 = 4</p>\r\n<p>Walk to fountain 4 (index 4). Your bottle = 4 - 1 + 5 = 8</p>\r\n<p>Walk to fountain 0 (index 0). Your bottle = 8 - 2 + 1 = 7</p>\r\n<p>Walk to fountain 1 (index 1). Your bottle = 7 - 3 + 2 = 6</p>\r\n<p>Walk to fountain 2 (index 2). Your bottle = 6 - 4 + 3 = 5</p>\r\n<p>Walk to fountain 3 (index 3). The cost is 5. Your bottle is just enough to travel back to fountain 3.</p>\r\n<p>Therefore, return 3 as the starting index.</p>\r\n\r\n<h3>Example 2:</h3>\r\n<pre><code class='language-text'>Input: water = [2,3,4], cost = [3,4,3]\r\nOutput: -1</code></pre>\r\n<p><strong>Explanation:</strong></p>\r\n<p>You can't start at fountain 0 (index 0) or fountain 1 (index 1), as there is not enough water to travel to the next fountain.</p>\r\n<p>Let's start at fountain 2 (index 2) and fill up with 4 units of water. Your bottle = 0 + 4 = 4</p>\r\n<p>Walk to fountain 0 (index 0). Your bottle = 4 - 3 + 2 = 3</p>\r\n<p>Walk to fountain 1 (index 1). Your bottle = 3 - 4 + 3 = 2</p>\r\n<p>You cannot walk back to fountain 2 (index 2), as it requires 4 units of water but you only have 3.</p>\r\n<p>Therefore, you can't walk around the road once no matter where you start.</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>n == water.length == cost.length</code></li>\r\n    <li><code>1 <= n <= 10^5</code></li>\r\n    <li><code>0 <= water[i], cost <= 10^4</code></li>\r\n</ul>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <vector>\n#include <string>\n#include <numeric>\n\nclass Solution {\npublic:\n    int findStartingFountain(std::vector<int>& water, std::vector<int>& cost) {\n        // Core logic to find the starting fountain index goes here.\n        return -1;\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    // Assuming the input format is:\n    // n\n    // water_1 water_2 ... water_n\n    // cost_1 cost_2 ... cost_n\n    // where n is the number of fountains.\n    \n    int n;\n    // The problem statement implies the size from the arrays, but in competitive programming,\n    // the size is typically given as a separate integer.\n    // We will assume 'n' is not given and infer it from the first line of input.\n    // This is a more complex parsing, so for a boilerplate, let's assume 'n' is given.\n    // Let's read the number of elements for the first array to determine 'n'.\n    // A simple way is to read the first line and count the numbers.\n    // However, the most standard format is to provide 'n' first.\n    // Let's assume the input is just two lines of space-separated integers.\n    // We can read them into vectors until we hit a newline. This is complex.\n    // The most reasonable assumption for a boilerplate is that 'n' is provided.\n    // Let's assume the input format for the examples would be:\n    // Example 1:\n    // 5\n    // 1 2 3 4 5\n    // 3 4 5 1 2\n    // Example 2:\n    // 3\n    // 2 3 4\n    // 3 4 3\n\n    // Let's find n by reading the first vector.\n    // This is not standard. Let's just assume n is given.\n    // The problem statement says `n == water.length == cost.length`.\n    // This `n` must be known to create the arrays.\n    // So, reading `n` first is the only logical way.\n    \n    int n;\n    std::cin >> n;\n\n    std::vector<int> water(n);\n    for (int i = 0; i < n; ++i) {\n        std::cin >> water[i];\n    }\n\n    std::vector<int> cost(n);\n    for (int i = 0; i < n; ++i) {\n        std::cin >> cost[i];\n    }\n\n    Solution solution;\n    int result = solution.findStartingFountain(water, cost);\n\n    std::cout << result << std::endl;\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "Accolite_9oct",
        "company_id": 601
    },
    {
        "id": 1714,
        "title": "Ant's Journey Home",
        "problem_statement": "<h1>Ant's Journey Home</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>Once upon a time, in a forest, there lived a little ant named Andy. Andy's cozy anthill was located at a specific spot along the x-axis, a straight path that stretched through the forest. Andy's home was at position x, and he loved to explore the forest, often wandering far from home. However, as dusk fell, it was time for Andy to return to his snug little anthill. To find his way back, Andy had a unique way of traveling:</p>\r\n<p>He could march forward by exactly \"a\" positions or scurry backward by exactly \"b\" positions.</p>\r\n<p>However, there were a few rules and prohibitions on his journey:</p>\r\n<ul>\r\n    <li>Andy could not scurry backward twice in a row; it made him dizzy and confused.</li>\r\n    <li>Certain positions in the forest were marked as dangerous by large red flags. Andy knew he must avoid these prohibited spots at all costs.</li>\r\n    <li>Andy couldn't scurry to any position beyond the beginning of the forest, marked as position 0. He wasn't a fan of the dark, mysterious areas beyond this starting point.</li>\r\n</ul>\r\n<p>Given these conditions, Andy needed to find the quickest path back to his home. He could even march beyond his home if necessary, as long as he could navigate back to position x.</p>\r\n<p>Given an array of integers <code>prohibited</code>, where <code>prohibited[i]</code> means that Andy cannot jump to the position <code>prohibited[i]</code>, and another array <code>data</code> of size 3 specifies integers <code>a</code>, <code>b</code>, and <code>x</code> respectively, return the least number of steps needed for Andy to reach his home. If there is no possible sequence of jumps that lands Andy on position x, return -1.</p>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input: prohibited = [14, 4, 18, 1, 15], data = [3,15,9]\r\nOutput: 3</code></pre>\r\n<p><strong>Explanation:</strong></p>\r\n<p>Andy the ant starts his journey from position 0 on the x-axis. His goal is to reach his home located at position 9. Andy has the ability to take step forward by 3 positions and backward by 15 positions. However, he cannot take step backward twice in a row, and there are certain positions he must avoid because they are marked as dangerous.</p>\r\n<p>Here's how Andy can successfully reach his home:</p>\r\n<p><strong>Initial Position:</strong> Andy begins at position 0.</p>\r\n<p><strong>First Step:</strong> Andy moves forward by 3 positions. He moves from position 0 to position 3. So far, he took 1 step. Path so far: 0 -> 3</p>\r\n<p><strong>Second Step:</strong> Andy move forward again by 3 positions. He moves from position 3 to position 6. Now, he took a total of 2 steps. Path so far: 0 -> 3 -> 6</p>\r\n<p><strong>Third Step:</strong> Andy took another forward step by 3 positions. He moves from position 6 to position 9. He took now a total of 3 steps. Path so far: 0 -> 3 -> 6 -> 9</p>\r\n<p>Andy successfully reaches his home at position 9 with a total of 3 forward jumps. Throughout his journey, he avoids all prohibited positions and follows the rule of not stepping backward consecutively.</p>\r\n<p>Therefore, the least number of steps required for Andy to reach his home is 3.</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li>Andy cannot scurry backward twice in a row.</li>\r\n    <li>Andy cannot move to any position listed in the <code>prohibited</code> array.</li>\r\n    <li>Andy cannot scurry to any position beyond position 0 (i.e., negative positions).</li>\r\n    <li>The <code>prohibited</code> array contains integers representing positions.</li>\r\n    <li>The <code>data</code> array has a size of 3 and contains integers <code>a</code> (forward step), <code>b</code> (backward step), and <code>x</code> (home position).</li>\r\n</ul>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <vector>\n#include <string>\n#include <queue>\n#include <unordered_set>\n#include <algorithm>\n\nvoid setup_io() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n}\n\nclass Solution {\npublic:\n    int findMinSteps(std::vector<int>& prohibited, int a, int b, int x) {\n        // TODO: Implement the solution logic here\n        return 0;\n    }\n};\n\nint main() {\n    setup_io();\n\n    int n;\n    // Reading the size of the prohibited array.\n    // Assuming the first line of input for prohibited is its size.\n    // This part might need adjustment based on exact input format if it's different.\n    // For example, if the input is just a single line of space-separated numbers,\n    // we would need to read the whole line and parse it.\n    // Let's assume size is given first.\n    std::string line;\n    std::getline(std::cin, line); // Read the line with prohibited numbers\n    std::vector<int> prohibited;\n    if (!line.empty()) {\n        size_t start = 0;\n        size_t end = line.find(',');\n        while (end != std::string::npos) {\n            prohibited.push_back(std::stoi(line.substr(start, end - start)));\n            start = end + 1;\n            end = line.find(',', start);\n        }\n        prohibited.push_back(std::stoi(line.substr(start, end)));\n    }\n\n\n    int a, b, x;\n    std::cin >> a >> b >> x;\n\n    Solution solution;\n    int result = solution.findMinSteps(prohibited, a, b, x);\n\n    std::cout << result << std::endl;\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "Accolite_9oct",
        "company_id": 601
    }
]