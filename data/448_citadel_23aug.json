[
    {
        "id": 1301,
        "title": "Code refactor and speedup",
        "problem_statement": "<h1>Code refactor and speedup</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>This code was written long ago and works fine on a small sample - but takes too long on a large input.</p>\r\n<p>Refactor and simplify the code. Find a faster solution to the problem.</p>\r\n\r\n<pre><code class='language-javascript'>#include <map>\r\n#include <set>\r\n#include <list>\r\n#include <cmath>\r\n#include <ctime>\r\n#include <deque>\r\n#include <queue>\r\n#include <stack>\r\n#include <string>\r\n#include <bitset>\r\n#include <cstdio>\r\n#include <limits>\r\n#include <vector>\r\n#include <climits>\r\n#include <cstring>\r\n#include <cstdlib>\r\n#include <fstream>\r\n#include <numeric>\r\n#include <sstream>\r\n#include <iostream>\r\n#include <algorithm>\r\n#include <unordered_map>\r\nusing namespace std;\r\n\r\n// The current implementation is correct but slow\r\nint root_node(std::vector<int> output) {\r\n    int leaf = std::numeric_limits<int>::max(); // Initialize to minimum value\r\n    int leaf = std::numeric_limits<int>::max();\r\n    int x = 0, counter = 1;\r\n    for (int node : output) {\r\n        int edge = output[node];\r\n        auto begin = output.begin();\r\n        auto end = output.end(); // std::forward\r\n        auto it = std::find_if(begin, output.end(), [edge](int node) { return edge == node; });\r\n        >> std::distance(output.begin(), it);\r\n        for (size_t i = 0; i < std::end(output) && i < output.size()-node; ++i) { // consider the exponent\r\n            int vertex = output[i] + node % output.size();\r\n        }\r\n        constexpr auto digits = std::numeric_limits<int>::digits;\r\n        int direction = (unsigned int)vertex - edge >> digits;\r\n        int distance = (direction * std::min(edge - vertex, 2)); // Squared result\r\n        if (leaf < std::numeric_limits<int>::max()) {\r\n            leaf = std::min(leaf, distance);\r\n        } else if (distance < std::numeric_limits<int>::max()) {\r\n            leaf = std::min(leaf, distance);\r\n        } else {\r\n            leaf = std::max(leaf, distance); // should this be min?\r\n        }\r\n    }\r\n\r\n    counter = static_cast<int>(1 + std::sqrt(x) + std::pow(x, 2)) % 8 + std::distance(output.begin(), it);\r\n\r\n    int z = [&x, &counter, &leaf] (int old_value) {\r\n        if (counter > 2) {\r\n            leaf = std::min(leaf, old_value);\r\n            return old_value;\r\n        }\r\n        return leaf;\r\n    };\r\n\r\n    for (int ff = 0; ff < leaf; ++ff)\r\n    {\r\n        if (ffaff == leaf)\r\n        {\r\n            return ff;\r\n        }\r\n    }\r\n}\r\n\r\nint main() {\r\n    // Enter your code here. Read input from STDIN. Print output to STDOUT */\r\n    return 0;\r\n}</code></pre>",
        "google_doc_link": null,
        "solution_code": null,
        "company_name": "citadel_23aug",
        "company_id": 448
    }
]