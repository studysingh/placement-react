[
    {
        "id": 1606,
        "title": "Optimal Team Size",
        "problem_statement": "<h1>Optimal Team Size</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>There are <code>n</code> developers. The skill level of the <code>i<sup>th</sup></code> developer is given by <code>i</code>, for <code>1 &le; i &le; n</code>. The task is to form a team of developers for a hackathon.</p>\r\n<p>A developer agrees to be on the team only if certain conditions are met. Given two arrays, <code>lowerSkill</code> and <code>higherSkill</code>, the <code>i<sup>th</sup></code> developer will join the team if at most <code>lowerSkill[i]</code> team members have a lower skill level than them, and at most <code>higherSkill[i]</code> team members have a higher skill level than them.</p>\r\n<p>The objective is to select the largest possible team such that every developer on the team agrees with the team composition based on these conditions.</p>\r\n\r\n<h3>Function Description</h3>\r\n<p>Complete the function <code>getOptimalTeamSize</code> in the editor below.</p>\r\n<p><strong>Function Parameters:</strong></p>\r\n<ul>\r\n    <li><code>int lowerSkill[n]</code>: the maximum number of team members in the hackathon whose skill level is lower than the <code>i<sup>th</sup></code> developer</li>\r\n    <li><code>int higherSkill[n]</code>: the maximum number of team members in the hackathon whose skill level is higher than the <code>i<sup>th</sup></code> developer</li>\r\n</ul>\r\n<p><strong>Returns:</strong></p>\r\n<ul>\r\n    <li><code>int</code>: the maximum number of developers on a team</li>\r\n</ul>\r\n\r\n<h2>Examples</h2>\r\n\r\n<h3>Example 1:</h3>\r\n<p>This example is derived from the initial problem description's detailed explanation.</p>\r\n<pre><code class='language-text'>Input: n = 5, lowerSkill = [1, 3, 2, 2, 1], higherSkill = [2, 2, 1, 1, 3]\r\nOutput: 3</code></pre>\r\n<p><strong>Explanation:</strong> It is optimal to select developers with skill levels 1, 3, and 4. For the developer with skill level 1, there are two developers with higher skill levels and <code>higherSkill[1] = 2</code>. For the developer with skill level 3, there is one developer with a lower skill level and one with a higher skill level (<code>lowerSkill[3] = 2</code>, <code>higherSkill[3] = 1</code>). For the developer with skill level 4, there are two developers with lower skill levels. Thus, all three developers are content. Hence, the number of developers selected for the hackathon team will be 3. It can be shown that this is the maximum possible number of developers that can be selected under these conditions.</p>\r\n\r\n<h3>Example 2:</h3>\r\n<pre><code class='language-text'>Input: n = 5, lowerSkill = [0, 4, 2, 3, 3], higherSkill = [0, 1, 3, 2, 4]\r\nOutput: 3</code></pre>\r\n<p><strong>Explanation:</strong> Select developers with skill levels 3, 4, and 5. For the developer with skill level 3, two developers have higher skill levels. For the developer with skill level 4, one developer has a lower skill level and one has a higher skill level. For the developer with skill level 5, two developers have lower skill levels. Thus, all three developers are content.</p>\r\n\r\n<h3>Example 3:</h3>\r\n<pre><code class='language-text'>Input: n = 6, lowerSkill = [3, 4, 2, 1, 2, 5], higherSkill = [1, 3, 4, 5, 3, 5]\r\nOutput: 4</code></pre>\r\n<p><strong>Explanation:</strong> Select developers with skill levels 2, 3, 5, and 6. For the developer with skill level 2, three developers have higher skill levels. For the developer with skill level 3, one developer has a lower skill level and two have higher skill levels. For the developer with skill level 5, two developers have lower skill levels and one has a higher skill level. For the developer with skill level 6, three developers have lower skill levels. Thus, all four developers are content.</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>1 &le; n &le; 2 * 10<sup>5</sup></code></li>\r\n    <li><code>0 &le; lowerSkill[i], higherSkill[i] &lt; n</code></li>\r\n</ul>",
        "google_doc_link": null,
        "solution_code": null,
        "company_name": "citadel_3oct",
        "company_id": 561
    },
    {
        "id": 1607,
        "title": "Find Valid Sizes",
        "problem_statement": "<h1>Find Valid Sizes</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>There are <code>n</code> memory blocks, and the size of the i<sup>th</sup> block is given by the array <code>memoryBlocks[i]</code>, where <code>0 &le; i &lt; n</code>.</p>\r\n<p>The following operation can be performed on <code>memoryBlocks</code> one time:</p>\r\n<ul>\r\n<li>An index <code>x</code> can be selected. The size of <code>memoryBlocks[x]</code> can be increased by 1 unit, but only if <code>memoryBlocks[x]</code> is less than <code>n-1</code>.</li>\r\n</ul>\r\n<p>The smallest integer <code>k</code> not present in <code>memoryBlocks</code> after any number of operations is called a <strong>Valid Size</strong> or the <strong>MEX</strong> (minimum excluded value).</p>\r\n<p>The task is to return an array of all possible <strong>Valid Sizes</strong> that can be achieved using <code>memoryBlocks</code>, sorted in ascending order.</p>\r\n<p><strong>Note:</strong></p>\r\n<ul>\r\n<li>The MEX of <code>memoryBlocks</code> is the smallest non-negative integer not present in the array.</li>\r\n</ul>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input: n = 3, memoryBlocks = [0, 2, 2]\r\nOutput: [0, 1]</code></pre>\r\n<p><strong>Explanation:</strong></p>\r\n<p>If no operation is performed, then the Valid Size is 1.</p>\r\n<p>Selected index x = 0 and increase the size of <code>memoryBlocks[0]</code> by 1, then <code>memoryBlocks</code> becomes <code>[1, 2, 2]</code>. Now the possible Valid Size is 0.</p>\r\n<p>Hence, the answer is <code>[0, 1]</code> which is sorted in ascending order.</p>\r\n\r\n<h3>Example 2:</h3>\r\n<pre><code class='language-text'>Input: n = 3, memoryBlocks = [2, 2, 2]\r\nOutput: [0]</code></pre>\r\n<p><strong>Explanation:</strong></p>\r\n<p>With no operation on <code>memoryBlocks</code>, the possible Valid Size is 0, which is the MEX of <code>memoryBlocks</code>.</p>\r\n<p>There is no set of operations through which the MEX is 1 or higher, hence the only possible Valid Size is 0.</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n<li><code>1 &le; n &le; 10<sup>5</sup></code></li>\r\n<li><code>0 &le; memoryBlocks[i] &lt; n</code></li>\r\n</ul>",
        "google_doc_link": null,
        "solution_code": null,
        "company_name": "citadel_3oct",
        "company_id": 561
    },
    {
        "id": 1608,
        "title": "Minimum Generations for Equal Layers",
        "problem_statement": "<h1>Minimum Generations for Equal Layers</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>A neural network has <code>n</code> layers, where the number of neurons in the <code>i</code>th layer is <code>layer[i]</code>. In each generation, the system adjusts the neurons as follows:</p>\r\n<ul>\r\n    <li>In odd generations: 1 neuron can be added to at most one layer</li>\r\n    <li>In even generations: 2 neurons can be added to at most one layer</li>\r\n</ul>\r\n<p>Find the minimum generation in which all layers can have an equal number of neurons.</p>\r\n\r\n<p>For example, consider <code>n = 4</code> and <code>layer = [1, 1, 2, 4]</code>:</p>\r\n<p><strong>Explanation:</strong> The goal is to make all layers equal to the maximum initial value, which is 4 in this case. We need to increase layers 0, 1, and 2.</p>\r\n<ul>\r\n    <li><strong>Generation 1 (odd):</strong> Add 1 neuron to layer 0. Layers become <code>[2, 1, 2, 4]</code>.</li>\r\n    <li><strong>Generation 2 (even):</strong> Add 2 neurons to layer 0. Layers become <code>[4, 1, 2, 4]</code>.</li>\r\n    <li><strong>Generation 3 (odd):</strong> Add 1 neuron to layer 1. Layers become <code>[4, 2, 2, 4]</code>.</li>\r\n    <li><strong>Generation 4 (even):</strong> Add 2 neurons to layer 1. Layers become <code>[4, 4, 2, 4]</code>.</li>\r\n    <li><strong>Generation 5 (odd):</strong> No layer needs exactly 1 neuron to reach 4 (layer 2 needs 2). So, no layer is chosen. Layers remain <code>[4, 4, 2, 4]</code>.</li>\r\n    <li><strong>Generation 6 (even):</strong> Add 2 neurons to layer 2. Layers become <code>[4, 4, 4, 4]</code>.</li>\r\n</ul>\r\n<p>The 6th generation is the minimum in which all the layers can have an equal number of neurons, i.e., 4.</p>\r\n\r\n<p><strong>Function Description:</strong></p>\r\n<p>Complete the function <code>findMinGeneration</code> in the editor with the following parameters:</p>\r\n<p><code>int layer[n]</code>: the number of neurons in the layers of the network</p>\r\n\r\n<p><strong>Returns:</strong></p>\r\n<p><code>long</code>: the minimum number of generations until all layers can have an equal number of neurons</p>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input: n = 3, layer = [3, 3, 6]\r\nOutput: 4</code></pre>\r\n<p><strong>Explanation:</strong> The goal is to make all layers equal to the maximum initial value, which is 6. We need to increase layers 0 and 1.</p>\r\n<ul>\r\n    <li><strong>Generation 1 (odd):</strong> Add 1 neuron to layer 0. Layers become <code>[4, 3, 6]</code>.</li>\r\n    <li><strong>Generation 2 (even):</strong> Add 2 neurons to layer 0. Layers become <code>[6, 3, 6]</code>.</li>\r\n    <li><strong>Generation 3 (odd):</strong> Add 1 neuron to layer 1. Layers become <code>[6, 4, 6]</code>.</li>\r\n    <li><strong>Generation 4 (even):</strong> Add 2 neurons to layer 1. Layers become <code>[6, 6, 6]</code>.</li>\r\n</ul>\r\n<p>The 4th generation is the minimum in which all the layers can have an equal number of neurons.</p>\r\n\r\n<h3>Example 2:</h3>\r\n<pre><code class='language-text'>Input: n = 4, layer = [2, 2, 3, 5]\r\nOutput: 6</code></pre>\r\n<p><strong>Explanation:</strong> The goal is to make all layers equal to the maximum initial value, which is 5. We need to increase layers 0, 1, and 2.</p>\r\n<ul>\r\n    <li><strong>Generation 1 (odd):</strong> Add 1 neuron to layer 0. Layers become <code>[3, 2, 3, 5]</code>.</li>\r\n    <li><strong>Generation 2 (even):</strong> Add 2 neurons to layer 0. Layers become <code>[5, 2, 3, 5]</code>.</li>\r\n    <li><strong>Generation 3 (odd):</strong> Add 1 neuron to layer 1. Layers become <code>[5, 3, 3, 5]</code>.</li>\r\n    <li><strong>Generation 4 (even):</strong> Add 2 neurons to layer 1. Layers become <code>[5, 5, 3, 5]</code>.</li>\r\n    <li><strong>Generation 5 (odd):</strong> No layer needs exactly 1 neuron to reach 5 (layer 2 needs 2). So, no layer is chosen. Layers remain <code>[5, 5, 3, 5]</code>.</li>\r\n    <li><strong>Generation 6 (even):</strong> Add 2 neurons to layer 2. Layers become <code>[5, 5, 5, 5]</code>.</li>\r\n</ul>\r\n<p>The 6th generation is the minimum in which all the layers can have an equal number of neurons.</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>1 &le; n &le; 10<sup>5</sup></code></li>\r\n    <li><code>1 &le; layer[i] &le; 10<sup>9</sup></code></li>\r\n</ul>",
        "google_doc_link": null,
        "solution_code": null,
        "company_name": "citadel_3oct",
        "company_id": 561
    }
]