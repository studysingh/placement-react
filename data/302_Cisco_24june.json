[
    {
        "id": 954,
        "title": "Shortest Path to Collect All Coins in a Tree",
        "problem_statement": "```html\r\n<h1>Shortest Path to Collect All Coins in a Tree</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>Alex is playing a game in Hackerland and needs to collect coins from various locations. The city is represented as a tree with <code>n</code> vertices labeled from <code>0</code> to <code>n - 1</code>. There is an array called <code>coins</code> of size <code>n</code>, where <code>coins[i]</code> is either <code>0</code> or <code>1</code>, where <code>1</code> means the vertex contains a coin.</p>\r\n<p>Alex must travel along the tree's edges to collect all the coins. The distance between two vertices is the number of edges between them. From any given vertex <code>x</code>, Alex can collect all coins located within a distance of 2 edges from <code>x</code>.</p>\r\n<p>The goal is to find the shortest path that allows Alex to collect all the coins. Alex can choose any vertex, but must start and end at that vertex. The path can traverse the same edge multiple times, and all edges are bidirectional.</p>\r\n<p>Return the number of edges in the shortest path along which Alex can collect all the coins.</p>\r\n<p>Complete the function <code>getMinPath</code> in the editor with the following parameters:</p>\r\n<ul>\r\n    <li><code>int coins[tree_nodes]</code>: an array of <code>tree_nodes</code> integers representing whether a vertex has a coin.</li>\r\n    <li><code>tree_nodes</code>: the number of nodes in the graph.</li>\r\n    <li><code>tree_from[tree_nodes-1]</code>: one node end of each bidirectional edge.</li>\r\n    <li><code>tree_to[tree_nodes-1]</code>: the other node end of each bidirectional edge.</li>\r\n</ul>\r\n<p><strong>Returns:</strong></p>\r\n<ul>\r\n    <li><code>int</code>: the number of edges in the shortest path.</li>\r\n</ul>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input:\r\ntree_nodes = 12\r\ncoins = [1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1]\r\ntree_from = [0, 1, 2, 3, 4, 5, 6, 8, 3, 9, 10]\r\ntree_to = [1, 2, 3, 4, 5, 6, 7, 9, 10, 11]\r\nOutput: 10</code></pre>\r\n<p><strong>Explanation:</strong> The <code>coins</code> array is derived from the explanation. Vertices 0, 3, 6, 8, and 11 contain coins. One optimum path is to start at vertex 3 and traverse 3 -> 2 -> 3 -> 4 -> 5 -> 6 -> 5 -> 4 -> 3 -> 9 -> 3. This path collects coins from vertices 2 (which covers coins at 0 and 3, as they are within 2 edges of vertex 2), 6 (which covers coins at 6 and 8), and 9 (which covers the coin at vertex 11).</p>\r\n<p>The graph structure for this example is:</p>\r\n<p><img src=\"graph_image_placeholder.png\" alt=\"Graph structure for Example 1\"></p>\r\n<p>(Note: The image is a placeholder and would typically be embedded in a real LeetCode problem.)</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>2 &le; tree_nodes &le; 10<sup>5</sup></code></li>\r\n    <li><code>coins[i] = 0</code> or <code>coins[i] = 1</code>, where <code>0 &le; i &lt; tree_nodes</code></li>\r\n    <li><code>0 &le; tree_from[i] &lt; tree_nodes</code> where <code>0 &le; i &lt; tree_nodes - 1</code></li>\r\n    <li><code>0 &le; tree_to[i] &lt; tree_nodes</code> where <code>0 &le; i &lt; tree_nodes - 1</code></li>\r\n</ul>\r\n```",
        "google_doc_link": null,
        "solution_code": null,
        "company_name": "Cisco_24june",
        "company_id": 302
    }
]