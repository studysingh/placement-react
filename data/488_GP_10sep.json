[
    {
        "id": 1398,
        "title": "Cross-Border FX Router",
        "problem_statement": "<h1>Cross-Border FX Router</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>G-P runs global payroll using multi-currency wallets. You start with a base currency B (e.g., USD). You must fund a set of payouts in various currencies. You can convert between currencies using directed FX corridors. Each corridor has:</p>\r\n<ul>\r\n    <li>a rate r (converting x units of source yields r * x units of destination), and</li>\r\n    <li>a flat destination-currency fee f that is deducted per conversion on that corridor.</li>\r\n</ul>\r\n<p>You may chain conversions arbitrarily. Corridors have no capacity limits.</p>\r\n<p>For each payout (Ci, Pi), you must ensure at least Pi units of currency Ci are deliverable after all conversions and corridor fees. Determine the minimum total amount of base currency B you must start with to fulfill all payouts. If any payout currency is unreachable from B, output -1.</p>\r\n\r\n<h3>Key Property</h3>\r\n<p>For a corridor u -> v with (rate=r, fee=f), to arrive at y units in v (after fee), you must depart x units in u such that:</p>\r\n<p>r * x - f >= y => x >= (y + f) / r</p>\r\n<p>This makes the required source amount an affine (linear + constant) function of the required destination amount. Therefore, the minimal base requirement for multiple payouts is the sum of their individual minimal base requirements.</p>\r\n\r\n<h2>Input Format</h2>\r\n<p><code>C E M B</code><br>\r\n<code>&lt;next E lines: corridors&gt; u v r f</code><br>\r\n<code>&lt;next M lines: payouts&gt; Ci Pi</code></p>\r\n<ul>\r\n    <li><strong>C</strong> - number of distinct currencies (1 <= C <= 2e5).</li>\r\n    <li><strong>E</strong> - number of directed corridors (1 <= E <= 2e5).</li>\r\n    <li><strong>M</strong> - number of payouts (1 <= M <= 1e5).</li>\r\n    <li><strong>B</strong> - base currency code (string without spaces, e.g., \"USD\").</li>\r\n    <li><strong>Corridors</strong>: u v r f\r\n        <ul>\r\n            <li>u, v are currency codes (strings without spaces).</li>\r\n            <li>r is a real number (0 < r <= 1e4).</li>\r\n            <li>f is a real number (0 <= f <= 1e9) in currency v.</li>\r\n        </ul>\r\n    </li>\r\n    <li><strong>Payouts</strong>: Ci Pi\r\n        <ul>\r\n            <li>Ci is currency code.</li>\r\n            <li>Pi is a real number (0 <= Pi <= 1e12).</li>\r\n        </ul>\r\n    </li>\r\n</ul>\r\n\r\n<h3>Notes</h3>\r\n<ul>\r\n    <li>Currency codes are arbitrary strings. Assume all codes appearing anywhere are part of the C currencies.</li>\r\n    <li>Real numbers may be integer-formatted or decimal with up to 6 digits after the decimal point.</li>\r\n</ul>\r\n\r\n<h2>Output Format</h2>\r\n<p>A single line:</p>\r\n<ul>\r\n    <li>If every payout currency is reachable from B: print the minimum base amount required in currency B as a decimal (absolute or relative error <= 1e-6).</li>\r\n    <li>Otherwise: print -1.</li>\r\n</ul>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input: 3 2 1\r\nUSD\r\nUSD EUR 0.8 1\r\nUSD EUR 0.75 0\r\nEUR 60\r\nOutput: 76.25000000</code></pre>\r\n<p><strong>Explanation:</strong> The problem input tells us:</p>\r\n<ul>\r\n    <li>We need to pay someone 60 EUR.</li>\r\n    <li>We have USD and need to convert it to EUR.</li>\r\n    <li>We have two different ways to convert USD to EUR:\r\n        <ul>\r\n            <li>Option 1: Exchange rate of 0.8 (meaning 1 USD = 0.8 EUR) with a 1 EUR fee.</li>\r\n            <li>Option 2: Exchange rate of 0.75 (meaning 1 USD = 0.75 EUR) with no fee.</li>\r\n        </ul>\r\n    </li>\r\n</ul>\r\n<p>To figure out how many USD we need, we check both options:</p>\r\n<p><strong>Option 1:</strong></p>\r\n<ul>\r\n    <li>We need 60 EUR plus 1 EUR fee = 61 EUR total.</li>\r\n    <li>Since 1 USD gives us 0.8 EUR, we divide: 61 / 0.8 = 76.25 USD.</li>\r\n</ul>\r\n<p><strong>Option 2:</strong></p>\r\n<ul>\r\n    <li>We need 60 EUR (no fee).</li>\r\n    <li>Since 1 USD gives us 0.75 EUR, we divide: 60 / 0.75 = 80 USD.</li>\r\n</ul>\r\n<p>The answer is 76.25 USD because:</p>\r\n<ul>\r\n    <li>Option 1 needs 76.25 USD.</li>\r\n    <li>Option 2 needs 80 USD.</li>\r\n    <li>We choose the cheaper option (76.25 USD).</li>\r\n</ul>\r\n<p>So even though Option 1 has a fee, its better exchange rate makes it the cheaper choice overall.</p>\r\n\r\n<p><strong>Note:</strong> Your code must be able to print the sample output from the provided sample input. However, your code is run against multiple hidden test cases. Therefore, your code must pass these hidden test cases to solve the problem statement.</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><strong>Time Limit:</strong> 5.0 sec(s) for each input file</li>\r\n    <li><strong>Memory Limit:</strong> 256 MB</li>\r\n    <li><strong>Source Limit:</strong> 1024 KB</li>\r\n</ul>\r\n\r\n<h2>Scoring</h2>\r\n<p>Score is assigned if any testcase passes</p>\r\n\r\n<h2>Allowed Languages</h2>\r\n<p>Bash, C, C++14, C++17, Clojure, C#, D, Erlang, F#, Go, Groovy, Haskell, Java 8, Java 14, Java 17, JavaScript(Node.js), Julia, Kotlin, Lisp (SBCL), Lua, Objective-C, OCaml, Octave, Pascal, Perl, PHP, Python, Python 3, Python 3.8, R(Rscript), Rocket, Ruby, Rust, Scala, Swift, TypeScript, Visual Basic</p>",
        "google_doc_link": null,
        "solution_code": null,
        "company_name": "GP_10sep",
        "company_id": 488
    },
    {
        "id": 1399,
        "title": "Rate Limiter Using Token Bucket Algorithm",
        "problem_statement": "<h1>Rate Limiter Using Token Bucket Algorithm</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>Implement a rate limiter using the Token Bucket algorithm. The rate limiter should control how many requests a user can make within a time period.</p>\r\n<p>The Token Bucket algorithm works as follows:</p>\r\n<ul>\r\n    <li>Each user has a bucket that holds tokens</li>\r\n    <li>Tokens are added to the bucket at a fixed rate</li>\r\n    <li>Each request requires one token</li>\r\n    <li>If a token is available, the request is allowed</li>\r\n    <li>If no token is available, the request is denied</li>\r\n</ul>\r\n<p>Requirements:</p>\r\n<ol>\r\n    <li>Implement a <code>TokenBucket</code> class with:\r\n        <ol>\r\n            <li>Constructor that takes:\r\n                <ol>\r\n                    <li><code>bucket_size</code>: maximum tokens the bucket can hold</li>\r\n                    <li><code>refill_rate</code>: tokens added per second</li>\r\n                </ol>\r\n            </li>\r\n            <li>Method: <code>allow_request(current_time)</code>\r\n                <ol>\r\n                    <li>Returns: boolean (True if request allowed, False if denied)</li>\r\n                    <li>Parameters: <code>current_time</code> (timestamp of the request)</li>\r\n                </ol>\r\n            </li>\r\n        </ol>\r\n    </li>\r\n    <li>The <code>TokenBucket</code> should:\r\n        <ol>\r\n            <li>Start with <code>bucket_size</code> tokens</li>\r\n            <li>Refill tokens based on elapsed time</li>\r\n            <li>Never exceed <code>bucket_size</code> tokens</li>\r\n            <li>Consume one token per request</li>\r\n        </ol>\r\n    </li>\r\n</ol>\r\n\r\n<h2>Input Format</h2>\r\n<ul>\r\n    <li>First line: <code>bucket_size</code> (integer)</li>\r\n    <li>Second line: <code>refill_rate</code> (float)</li>\r\n    <li>Third line: <code>starting_time</code> (float)</li>\r\n    <li>Fourth line: <code>N</code> (integer) - number of timestamps</li>\r\n    <li>Next <code>N</code> lines: <code>timestamps</code> (float)</li>\r\n</ul>\r\n\r\n<h2>Output Format</h2>\r\n<p><code>N</code> lines, each containing \"True\" or \"False\"</p>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input:\r\n5\r\n1.0\r\n5\r\n7\r\n0.0\r\n0.1\r\n0.2\r\n0.3\r\n0.4\r\n0.5\r\nOutput:\r\nTrue\r\nTrue\r\nTrue\r\nTrue\r\nFalse\r\nFalse</code></pre>\r\n<p><strong>Explanation:</strong> Each of first five requests is allowed because there are enough tokens in the bucket. The sixth and seventh request is denied because all the tokens have been used, and not enough time has passed to refill the bucket with a new token.</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>1 &lt;= bucket_size &lt;= 1000</code></li>\r\n    <li><code>0.0 &lt;= refill_rate &lt;= 1000.0</code></li>\r\n    <li><code>0.0 &lt;= timestamps &lt;= 10^9</code></li>\r\n    <li><code>1 &lt;= N &lt;= 1000</code></li>\r\n    <li>Timestamps are in increasing order</li>\r\n</ul>\r\n\r\n<h2>Note</h2>\r\n<p>Your code must be able to print the sample output from the provided sample input. However, your code is run against multiple hidden test cases. Therefore, your code must pass these hidden test cases to solve the problem statement.</p>\r\n\r\n<h3>Limits</h3>\r\n<ul>\r\n    <li>Time Limit: 5.0 sec(s) for each input file</li>\r\n    <li>Memory Limit: 256 MB</li>\r\n    <li>Source Limit: 1024 KB</li>\r\n</ul>\r\n\r\n<h3>Scoring</h3>\r\n<p>Score is assigned if any testcase passes</p>\r\n\r\n<h3>Allowed Languages</h3>\r\n<p>Bash, C, C++14, C++17, Clojure, C#, D, Erlang, F#, Go, Groovy, Haskell, Java 8, Java 14, Java 17, JavaScript(Node.js), Julia, Kotlin, Lisp (SBCL), Lua, Objective-C, OCaml, Octave, Pascal, Perl, PHP, Python, Python 3, Python 3.8, Racket, Ruby, Rust, Scala, Swift, TypeScript, Visual Basic</p>",
        "google_doc_link": null,
        "solution_code": null,
        "company_name": "GP_10sep",
        "company_id": 488
    }
]