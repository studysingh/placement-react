[
    {
        "id": 1675,
        "title": "Maximum Beauty of an Array",
        "problem_statement": "<h1>Maximum Beauty of an Array</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>Choose <code>k</code> non-empty disjoint subarrays from an array <code>arr</code> of <code>n</code> integers. Let <code>sub_sum[i]</code> denote the sum of elements in the <code>i</code><sup>th</sup> subarray. The beauty of <code>arr</code> is <code>1 * sub_sum[1] + 2 * sub_sum[2] + 3 * sub_sum[3] + ... + k * sub_sum[k]</code>. In other words, beauty = summation(<code>i * sub_sum[i]</code>) for <code>1 <= i <= k</code>.</p>\r\n<p>Given <code>arr</code> and <code>k</code>, find the maximum possible beauty of the array. If it is not possible to choose <code>k</code> non-empty disjoint subarrays, return -1.</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n<ul>\r\n    <li>A subarray is a contiguous subsegment of an array.</li>\r\n    <li>It is not necessary to include every element in a subarray.</li>\r\n    <li>The chosen subarrays must be disjoint, i.e., no two subarrays may contain any common index.</li>\r\n    <li>The order of chosen subarrays cannot be changed. If <code>i < j</code>, then the last index of the <code>i</code><sup>th</sup> subarray must be less than the first index of the <code>j</code><sup>th</sup> subarray for each possible pair <code>(i, j)</code>.</li>\r\n</ul>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input: n = 5, arr = [1, 3, -1, -2, 1], k = 4\r\nOutput: 8</code></pre>\r\n<p><strong>Explanation:</strong> Choose the <code>k</code> subarrays as follows (<code>arr[l:r]</code> denotes a subarray inclusive of <code>l</code> and <code>r</code>):</p>\r\n<ul>\r\n    <li>Subarray 1 = <code>arr[1:1] = [1]</code>; <code>sub_sum[1] = 1</code></li>\r\n    <li>Subarray 2 = <code>arr[2:2] = [3]</code>; <code>sub_sum[2] = 3</code></li>\r\n    <li>Subarray 3 = <code>arr[3:3] = [-1]</code>; <code>sub_sum[3] = -1</code></li>\r\n    <li>Subarray 4 = <code>arr[5:5] = [1]</code>; <code>sub_sum[4] = 1</code></li>\r\n</ul>\r\n<p>So, beauty = <code>1 * 1 + 2 * 3 + 3 * -1 + 4 * 1 = 8</code>, the maximum possible. Return 8.</p>\r\n\r\n<h3>Example 2 (Sample Case 0):</h3>\r\n<pre><code class='language-text'>Input:\r\nk = 3\r\narr[] size n = 6\r\narr = [-4, -9, 10, 1, -3, 5]\r\nOutput: 33</code></pre>\r\n<p><strong>Explanation:</strong> Choose <code>[-4], [10, 1], [5]</code>.</p>\r\n<ul>\r\n    <li><code>sub_sum[1] = -4</code></li>\r\n    <li><code>sub_sum[2] = 11</code></li>\r\n    <li><code>sub_sum[3] = 5</code></li>\r\n</ul>\r\n<p>beauty = <code>1 * -4 + 2 * 11 + 3 * 5 = -4 + 22 + 15 = 33</code>.</p>\r\n\r\n<h2>Function Description</h2>\r\n<p>Complete the function <code>getMaximumBeauty</code> in the editor below.</p>\r\n<p><code>getMaximumBeauty</code> has the following parameters:</p>\r\n<ul>\r\n    <li><code>int k</code>: the number of disjoint subarrays to choose</li>\r\n    <li><code>int arr[n]</code>: an array of integers</li>\r\n</ul>\r\n<p><strong>Returns:</strong></p>\r\n<ul>\r\n    <li><code>long_int</code>: the maximum possible beauty of the array, or -1 if it is impossible to select enough subarrays</li>\r\n</ul>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>1 <= k <= 3000</code></li>\r\n    <li><code>1 <= n <= 3000</code></li>\r\n    <li><code>-10<sup>5</sup> <= arr[i] <= 10<sup>5</sup></code></li>\r\n</ul>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <vector>\n#include <string>\n#include <numeric>\n#include <algorithm>\n\nclass Solution {\npublic:\n    /**\n     * @brief Calculates the maximum possible beauty of the array.\n     * \n     * @param k The number of disjoint subarrays to choose.\n     * @param arr The input array of integers.\n     * @return long long The maximum possible beauty, or -1 if impossible.\n     */\n    long long getMaximumBeauty(int k, const std::vector<int>& arr) {\n        // Core logic to solve the problem goes here.\n        // This is a placeholder.\n        return 0;\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    int n;\n    int k;\n    std::cin >> n >> k;\n\n    std::vector<int> arr(n);\n    for (int i = 0; i < n; ++i) {\n        std::cin >> arr[i];\n    }\n\n    Solution solution;\n    long long result = solution.getMaximumBeauty(k, arr);\n\n    std::cout << result << std::endl;\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "Publicis Sapient_8oct",
        "company_id": 584
    },
    {
        "id": 1676,
        "title": "Palindromic Subsequences of Length 5",
        "problem_statement": "<h1>Palindromic Subsequences of Length 5</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>For a string <code>s</code> consisting only of characters '0' and '1', determine the number of subsequences of length 5 that are palindromes. Since the result can be very large, return the answer modulo (10<sup>9</sup> + 7).</p>\r\n\r\n<p><strong>Notes:</strong></p>\r\n<ul>\r\n    <li>A palindrome is a sequence that reads the same backward as forward.</li>\r\n    <li>A subsequence is obtained from the given sequence by deleting zero or more elements without changing the order of the remaining elements.</li>\r\n    <li>Two subsequences are considered different if the indices used to form them are different.</li>\r\n</ul>\r\n\r\n<p>For example, given <code>s = \"0100110\"</code> and using 1-based indexing, some subsequences of length 5 are:</p>\r\n<ul>\r\n    <li>indices (1, 2, 3, 6, 7) -> 01010</li>\r\n    <li>indices (1, 2, 3, 5, 7) -> 01010</li>\r\n    <li>indices (1, 2, 4, 6, 7) -> 01010</li>\r\n    <li>indices (1, 2, 4, 5, 7) -> 01010</li>\r\n    <li>indices (1, 2, 5, 6, 7) -> 01110</li>\r\n</ul>\r\n<p>The value <code>5 modulo (10<sup>9</sup> + 7) = 5</code> refers to the count of these specific subsequences, not necessarily palindromic ones. The problem asks for the count of palindromic subsequences.</p>\r\n\r\n<h3>Function Description</h3>\r\n<p>Complete the function <code>getPalindromesCount</code> in the editor with the following parameter:</p>\r\n<ul>\r\n    <li><code>string s</code>: the binary string</li>\r\n</ul>\r\n<p><strong>Returns:</strong></p>\r\n<ul>\r\n    <li><code>int</code>: the number of subsequences of length 5 which are palindromes, modulo (10<sup>9</sup> + 7)</li>\r\n</ul>\r\n\r\n<h2>Examples</h2>\r\n\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input: s = \"010110\"\r\nOutput: 3</code></pre>\r\n<p><strong>Explanation:</strong> Palindromic subsequences with their indices are:</p>\r\n<ul>\r\n    <li>(1, 2, 3, 4, 6) -> 01010</li>\r\n    <li>(1, 2, 3, 5, 6) -> 01010</li>\r\n    <li>(1, 2, 4, 5, 6) -> 01110</li>\r\n</ul>\r\n\r\n<h3>Example 2:</h3>\r\n<pre><code class='language-text'>Input: s = \"01111\"\r\nOutput: 0</code></pre>\r\n<p><strong>Explanation:</strong> There is no palindrome subsequence of length 5.</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>5 &le; length of s &le; 10<sup>5</sup></code></li>\r\n    <li>All characters in <code>s</code> are either <code>0</code> or <code>1</code>.</li>\r\n</ul>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <string>\n#include <vector>\n\nclass Solution {\npublic:\n    int getPalindromesCount(const std::string& s) {\n        // Your implementation here\n        return 0;\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    std::string s;\n    std::cin >> s;\n\n    Solution solution;\n    int result = solution.getPalindromesCount(s);\n\n    std::cout << result << std::endl;\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "Publicis Sapient_8oct",
        "company_id": 584
    }
]