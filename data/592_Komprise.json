[
    {
        "id": 1694,
        "title": "City population",
        "problem_statement": "<h1>City population</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>Given a city network in the form of a tree. There are N cities and each city has a Unique ID (integer from 1 to N). There exists a unique path between each pair of cities. Steve and Toddler are observing the city network. To make the task interesting, Bob gives the population of each city.</p>\r\n<p>Bob asks queries from Steve:</p>\r\n<p>Bob gives Steve two cities U and V (may or may not be the same) and an integer W. Steve needs to tell the number of cities that have a population at most W on the path from U to V.</p>\r\n\r\n<p><strong>Function description</strong></p>\r\n<p>Complete the solve function. This function takes the following 5 parameters and returns an array of size Q representing the answer to each query:</p>\r\n<ul>\r\n    <li><code>N</code>: Represents the number of cities</li>\r\n    <li><code>population</code>: Represents an array of sizes of N, denoting the population of cities</li>\r\n    <li><code>road</code>: Represents N-1 arrays, each array represents a road as given in the problem statement</li>\r\n    <li><code>Q</code>: Represents the number of queries</li>\r\n    <li><code>cities</code>: Represents Q arrays, each array represents a query as defined in the problem statement</li>\r\n</ul>\r\n\r\n<p>Here's the initial function signature provided:</p>\r\n<pre><code class='language-c'>#include &lt;stdio.h&gt;\r\nint city_population (int N, int* population, int Q, int** cities, int* out_n) {\r\n    // Write your code here\r\n    // Assign the size of the array to be returned to out_n variable\r\n    // *out_n = array_size;\r\n    *out_n = 1;\r\n    int *res = (int*)malloc(*out_n * sizeof(int));\r\n    return res;\r\n}</code></pre>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nclass Solution {\npublic:\n    std::vector<int> solve(int N, const std::vector<int>& population, const std::vector<std::vector<int>>& adj, int Q, const std::vector<std::vector<int>>& queries) {\n        // TODO: Implement the solution logic here\n        std::vector<int> results(Q);\n        return results;\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    int N;\n    std::cin >> N;\n\n    std::vector<int> population(N);\n    for (int i = 0; i < N; ++i) {\n        std::cin >> population[i];\n    }\n\n    std::vector<std::vector<int>> adj(N + 1);\n    for (int i = 0; i < N - 1; ++i) {\n        int u, v;\n        std::cin >> u >> v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    int Q;\n    std::cin >> Q;\n\n    std::vector<std::vector<int>> queries(Q, std::vector<int>(3));\n    for (int i = 0; i < Q; ++i) {\n        std::cin >> queries[i][0] >> queries[i][1] >> queries[i][2]; // U, V, W\n    }\n\n    Solution solution;\n    std::vector<int> results = solution.solve(N, population, adj, Q, queries);\n\n    for (size_t i = 0; i < results.size(); ++i) {\n        std::cout << results[i] << \"\\n\";\n    }\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "Komprise",
        "company_id": 592
    },
    {
        "id": 1695,
        "title": "Break the node",
        "problem_statement": "<h1>Break the node</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>In a game played by Alice and Bob, they are given a connected undirected graph with n nodes and m edges. Each node has a sweetness value denoted by an array w. The game proceeds as follows:</p>\r\n<ol>\r\n    <li>Alice's turn: Alice can choose to break a node. Breaking a node causes all edges connected to that node to vanish.</li>\r\n    <li>Bob's turn: Bob selects a connected component that contains some or all nodes from the remaining graph.</li>\r\n    <li>Alice's turn: If there are any remaining connected components, Alice can select one.</li>\r\n</ol>\r\n<p>The game ends in three steps, and both players aim to maximize their score by collecting the maximum possible sweetness value. They are not trying to minimize each other's scores.</p>\r\n<p>The task is to find the maximum score for Alice and Bob respectively, assuming both players play the game optimally.</p>\r\n\r\n<h2>Notes</h2>\r\n<ul>\r\n    <li>1-based indexing is followed.</li>\r\n    <li>A connected component is the maximal set of nodes in which any two nodes of that component are connected to each other by one or more paths.</li>\r\n    <li>The sweetness value of a connected component is the sum of the sweetness value of all the nodes in that connected component. If there are no connected components, assume the sum equals 0.</li>\r\n</ul>\r\n\r\n<h2>Function Description</h2>\r\n<p>Complete the solve function. This function takes the following 4 parameters and returns an array of answers:</p>\r\n<ul>\r\n    <li><strong>n:</strong> Represents the size of array w</li>\r\n    <li><strong>m:</strong> Represents the size of array edges</li>\r\n    <li><strong>w:</strong> Represents the array of sweetness values of each node</li>\r\n    <li><strong>edges:</strong> Represents a 2-D array denoting the edges of the graph</li>\r\n</ul>\r\n\r\n<h2>Input format for custom testing</h2>\r\n<p><strong>Note:</strong> Use this input format if you are testing against custom input or writing code in a language where we don't provide boilerplate code.</p>\r\n<ul>\r\n    <li>The first line contains T, which represents the number of test cases.</li>\r\n</ul>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <vector>\n#include <numeric>\n#include <string>\n#include <algorithm>\n\nclass Solution {\npublic:\n    std::vector<long long> solve(int n, int m, const std::vector<long long>& w, const std::vector<std::vector<int>>& edges) {\n        // Core logic to solve the problem goes here.\n        // This function should return a vector of two long longs:\n        // result[0] = Alice's maximum score\n        // result[1] = Bob's maximum score\n        \n        return {0, 0}; \n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n    int t;\n    std::cin >> t;\n    while (t--) {\n        int n, m;\n        std::cin >> n >> m;\n        \n        // Problem uses 1-based indexing for nodes.\n        // We use a vector of size n+1 to accommodate this easily.\n        std::vector<long long> w(n + 1);\n        for (int i = 1; i <= n; ++i) {\n            std::cin >> w[i];\n        }\n        \n        std::vector<std::vector<int>> edges(m, std::vector<int>(2));\n        for (int i = 0; i < m; ++i) {\n            std::cin >> edges[i][0] >> edges[i][1];\n        }\n        \n        Solution solution;\n        std::vector<long long> result = solution.solve(n, m, w, edges);\n        \n        std::cout << result[0] << \" \" << result[1] << \"\\n\";\n    }\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "Komprise",
        "company_id": 592
    },
    {
        "id": 1696,
        "title": "A remainder problem",
        "problem_statement": "<h1>A remainder problem</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>Assume that you are working on a project that involves processing large numbers represented as strings. You are given a large number N in the form of a string, an integer K, and Q queries.</p>\r\n<p>For each query, you need to determine if there exist subsequences of N that satisfy a specific condition. The condition is that when the digits of N are concatenated without changing the relative ordering, and the resulting number is divided by K, it leaves a remainder of X.</p>\r\n<p><strong>Function description</strong></p>\r\n<p>Complete the `solve_queries` function. This function takes the following 4 parameters and returns the list of strings:</p>\r\n<ul>\r\n    <li><code>N</code>: Represents the given integer value in the form of a string</li>\r\n    <li><code>K</code>: Represents the number to which a subsequence of N must be divided</li>\r\n    <li><code>Q</code>: Represents the size of the query array</li>\r\n    <li><code>queries</code>: Represents the elements X in the array</li>\r\n</ul>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input:\r\n174 9 3\r\n0\r\n1\r\n2\r\nOutput:\r\nNO\r\nYES\r\nYES</code></pre>\r\n<p><strong>Explanation:</strong></p>\r\n<p><strong>Given:</strong></p>\r\n<ul>\r\n    <li><code>N = \"174\"</code></li>\r\n    <li><code>K = 9</code></li>\r\n    <li><code>Q = 3</code></li>\r\n    <li><code>queries = [0, 1, 2]</code></li>\r\n</ul>\r\n<p><strong>Approach:</strong></p>\r\n<ul>\r\n    <li>The subsequences of 174 are 1, 7, 4, 17, 14, 74, and 174.</li>\r\n    <li>For remainder 0, no subsequence of 174 exists when divided by 9 gives remainder 0. Hence answer to 1st query is \"NO\".</li>\r\n    <li>For remainder 1, we can divide subsequence 1 by 9. Hence answer to 2nd query is \"YES\".</li>\r\n    <li>For remainder 2, we can divide subsequence 74 by 9.</li>\r\n</ul>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>0 &lt;= X &lt; K-1</code> (where X is an element from <code>queries</code>)</li>\r\n</ul>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <vector>\n#include <string>\n\nclass Solution {\npublic:\n    std::vector<std::string> solve_queries(const std::string& N, int K, int Q, const std::vector<int>& queries) {\n        // Your solution logic goes here\n        return {};\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    std::string N;\n    std::cin >> N;\n\n    int K;\n    std::cin >> K;\n\n    int Q;\n    std::cin >> Q;\n\n    std::vector<int> queries(Q);\n    for (int i = 0; i < Q; ++i) {\n        std::cin >> queries[i];\n    }\n\n    Solution sol;\n    std::vector<std::string> results = sol.solve_queries(N, K, Q, queries);\n\n    for (const auto& res : results) {\n        std::cout << res << std::endl;\n    }\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "Komprise",
        "company_id": 592
    },
    {
        "id": 1697,
        "title": "Cleaning house",
        "problem_statement": "<h1>Cleaning house</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>The floor of your house is created by tiles of a square shape. Each tile is denoted as cells and the house is composed of N cells in a straight line. The details of each cell or tile are given in a string with:</p>\r\n<ul>\r\n    <li>A cell that contains food is denoted by F</li>\r\n    <li>A dirty cell is denoted by D</li>\r\n    <li>An empty cell is denoted by a hyphen (-)</li>\r\n</ul>\r\n<p>Your task is to group all food into consecutive cells while following these rules:</p>\r\n<ul>\r\n    <li>Moving food from one cell to an adjacent cell costs x coins (food in a cell can be moved to an adjacent cell only if the adjacent cell is empty).</li>\r\n    <li>Cleaning a dirty cell to make it an empty cell costs y coins.</li>\r\n</ul>\r\n<p>Given Q queries where each query contains the values of x and y. Find the minimum number of coins that are required to group all the food cells into consecutive cells.</p>\r\n\r\n<h3>Function description</h3>\r\n<p>Complete the solve function. This function takes the following 4 parameters and returns the answer to each query.</p>\r\n<ul>\r\n    <li>N: Represents the size of the tile's string</li>\r\n    <li>Q: Represents the number of queries.</li>\r\n    <li>S: Represents the tile's string.</li>\r\n    <li>queries: Represents the vector of queries where each vector contains x and y cost of shifting, and cost of removing dirt</li>\r\n</ul>\r\n\r\n<h3>Input format for custom testing</h3>\r\n<p><strong>Note:</strong> Use this input format if you are testing against custom input or writing code in a language where we don't provide boilerplate code.</p>\r\n<ul>\r\n    <li>The first line contains two space-separated integers N and Q.</li>\r\n    <li>The second line contains the string of length N denoting the map of the house.</li>\r\n    <li>The next Q lines contain two space-separated integers x and y.</li>\r\n</ul>\r\n\r\n<h3>Output format</h3>\r\n<p>For each query, print the minimum number of coins that are required to group all food into consecutive cells.</p>\r\n\r\n<h2>Examples</h2>\r\n<h3>Sample Input:</h3>\r\n<pre><code class='language-text'>10 3\r\nF-D-F-D-F-\r\n0 10\r\n1 0\r\n1 1</code></pre>\r\n\r\n<h3>Sample Output:</h3>\r\n<pre><code class='language-text'>10\r\n4\r\n4</code></pre>\r\n\r\n<h3>Explanation:</h3>\r\n<p><strong>Example 1:</strong> For the query [0,10]: The initial scenario is F-D-F-D-F-. We can arrange the food as FFFFF----- or -----FFFFF. The total cost will be 0 + 10 = 10 or 10 + 0 = 10. We can't get less than 10 in any other way.</p>\r\n<p><strong>Example 2:</strong> Cleaning dirty cell D will cost 1. We can arrange the food as ---FFF---. The total cost will be 1 + 1 = 2.</p>\r\n<p><strong>Example 3:</strong> Cleaning dirty cell D will cost 1. We can arrange the food as ---FFF---. The total cost will be 1 + 1 = 2.</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>1 &lt;= N, Q &lt;= 10^5</code></li>\r\n    <li><code>0 &lt;= x, y &lt;= 10^9</code></li>\r\n</ul>\r\n\r\n<h2>Note</h2>\r\n<p>Your code must be able to print the sample output from the provided sample input. However, your code is run against multiple hidden test cases. Therefore, your code must pass those hidden test cases to solve the problem completely.</p>\r\n\r\n<h2>Limits</h2>\r\n<ul>\r\n    <li>Time Limit: 10 secs for each input file</li>\r\n    <li>Memory Limit: 256 MB</li>\r\n    <li>Source Limit: 1024 KB</li>\r\n</ul>\r\n\r\n<h2>Scoring</h2>\r\n<p>Score is assigned if any testcase passes</p>\r\n\r\n<h2>Allowed Languages</h2>\r\n<p>Java 8, Java 14, Java 17, JavaScript/Node.js, Julia, Kotlin, Lisp, Lua, Objective-C, OCaml, Octave, Pascal, Perl, PHP, Python, Python 3, Python 3.8, Racket, Ruby, Rust, Scala, Swift, TypeScript, Visual Basic.</p>\r\n\r\n<h2>Code Template (C++)</h2>\r\n<pre><code class='language-cpp'>#include &lt;bits/stdc++.h&gt;\r\nusing namespace std;\r\n\r\nint solve(int N, int Q, char* S, int** queries, int* out_n) {\r\n    // Write your code here\r\n    // out_n = array_size;\r\n}</code></pre>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nclass Solution {\npublic:\n    long long solve(int N, const std::string& S, long long x, long long y) {\n        // Placeholder for the core logic.\n        // This method should calculate the minimum cost for a single query (x, y).\n        return 0;\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    int N, Q;\n    std::cin >> N >> Q;\n    std::string S;\n    std::cin >> S;\n\n    Solution solution;\n\n    for (int i = 0; i < Q; ++i) {\n        long long x, y;\n        std::cin >> x >> y;\n        long long result = solution.solve(N, S, x, y);\n        std::cout << result << \"\\n\";\n    }\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "Komprise",
        "company_id": 592
    },
    {
        "id": 1698,
        "title": "Large dam",
        "problem_statement": "<h1>Large dam</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>There is a large dam with N unique floodgates, each identified by a unique number from 0 to N-1. The control system of the dam keeps a record of the floodgate operations. A pathway between two floodgates is opened daily, allowing water to flow from one door to another. This operation is recorded in a list of logs, where each log[i] = [day, door_A, door_B] contains a non-negative integer representing the day and the numbers of the two different doors.</p>\r\n<p>A door is considered connected to another door if there is a direct water flow between them or if it shares water flow with another one connected to the second door. Your task is determining the earliest day by which water could flow between every door in the dam, effectively connecting all doors. If there is no such day when all doors are interconnected through water flow, the output should be -1.</p>\r\n<p>Complete the <code>solve()</code> function. The function takes 3 parameters:</p>\r\n<pre><code class='language-javascript'>int solve (int N, int K, vector&lt;vector&lt;int&gt;&gt; logs)</code></pre>\r\n<p>Where:</p>\r\n<ul>\r\n    <li><code>N</code>: The number of unique floodgates (doors).</li>\r\n    <li><code>K</code>: The number of log entries.</li>\r\n    <li><code>logs</code>: A list of log entries, where each entry <code>log[i] = [day, door_A, door_B]</code>.</li>\r\n</ul>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <numeric>\n\nclass Solution {\npublic:\n    int solve(int N, int K, std::vector<std::vector<int>>& logs) {\n        // Core logic goes here\n        return -1;\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    int N, K;\n    std::cin >> N >> K;\n\n    std::vector<std::vector<int>> logs(K, std::vector<int>(3));\n    for (int i = 0; i < K; ++i) {\n        std::cin >> logs[i][0] >> logs[i][1] >> logs[i][2];\n    }\n\n    Solution solution;\n    int result = solution.solve(N, K, logs);\n\n    std::cout << result << std::endl;\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "Komprise",
        "company_id": 592
    }
]