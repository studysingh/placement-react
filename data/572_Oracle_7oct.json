[
    {
        "id": 1638,
        "title": "REST API: Max Profit Event",
        "problem_statement": "<h1>REST API: Max Profit Event</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>Given the name of an event organizer, identify the event that generates the highest profit if it sells out completely.</p>\r\n<p>Use the events database available at the endpoint: <code>https://jsonmock.hackerrank.com/api/events</code>. The results are paginated and can be accessed by adding <code>&amp;page=(num)</code> to the query string, where <code>(num)</code> denotes the page number.</p>\r\n<p>To filter the query by specific fields, append <code>(fieldname)=(value)</code> to the URL. For instance, <code>https://jsonmock.hackerrank.com/api/events?organized_by=anorganizer&amp;page=2</code> will return page 2 of the events organized by the organizer named <code>anorganizer</code>.</p>\r\n<p>The query response from the API includes these fields:</p>\r\n<ul>\r\n    <li><code>page</code>: the current page</li>\r\n    <li><code>per_page</code>: the maximum results per page</li>\r\n    <li><code>total</code>: the total number of records</li>\r\n    <li><code>total_pages</code>: the total number of pages for the query results</li>\r\n    <li><code>data</code>: an array of JSON objects containing event information</li>\r\n</ul>\r\n<p>Each object in the data field includes the following:</p>\r\n<ul>\r\n    <li><code>name</code>: the name of the event</li>\r\n    <li><code>organized_by</code>: the organizer of the event</li>\r\n    <li><code>ticket_prices</code>: an array containing 3 elements denoting prices of different types of tickets (normal, premium, and VIP)</li>\r\n    <li><code>capacity_left</code>: the number of seats left for the event</li>\r\n    <li><code>people_registered</code>: the number of people who registered for the event</li>\r\n    <li><code>other details not relevant to this question</code></li>\r\n</ul>\r\n<p>For example, the record from <code>https://jsonmock.hackerrank.com/api/events</code> includes the following:</p>\r\n<pre><code class='language-text'>{\r\n    \"id\": \"c152291f-dbcf-4f88-9fd9-1eb8e8ab3c4a\",\r\n    \"name\": \"jbirEOTmfU\",\r\n    \"genres\": [\r\n        \"Reggae\",\r\n        \"Electronic\"\r\n    ],\r\n    \"ticket_prices\": [\r\n        23,\r\n        50,\r\n        157\r\n    ],\r\n    \"capacity_left\": 2717,\r\n    \"people_registered\": 168,\r\n    \"duration\": 5,\r\n    \"date\": \"2024-05-11T13:20:42.118Z\",\r\n    \"country\": \"Argentina\",\r\n    \"organized_by\": \"empower integrated markets\",\r\n    \"type\": \"outdoor\"\r\n}</code></pre>\r\n<p>50% of the tickets are normal, 30% are premium, and 20% are VIP. Based on this, find the total profit.</p>\r\n<p>Profit from a particular ticket type is calculated as: sold-out capacity (people registered + capacity left) x price of ticket type x share of seats. Add the results for all 3 ticket types to get the total profit.</p>\r\n<p>For example, if ticket prices are <code>[1,2,3]</code>, <code>people_registered = 10</code>, and <code>capacity_left = 40</code>, then the sold-out capacity is <code>50 (10 + 40)</code>, and the total profit is calculated as follows:</p>\r\n<p><code>(50 &times; 1 &times; 0.5) + (50 &times; 2 &times; 0.3) + (50 &times; 3 &times; 0.2) = 85</code></p>\r\n<p><strong>Note:</strong> Earnings need to be rounded to 2 decimal places before doing comparisons.</p>\r\n<p>Complete the function <code>maxProfit</code> in the editor with the following parameter(s):</p>\r\n<ul>\r\n    <li><code>string organizer</code>: the name of the organizer</li>\r\n</ul>\r\n<p><strong>Returns</strong></p>\r\n<ul>\r\n    <li><code>string</code>: the name of the event by the specified organizer that gives the maximum profit when sold out</li>\r\n</ul>\r\n<p><strong>Note:</strong> Please review the header in the code stub to see available libraries for API requests in the selected language. Required libraries can be imported to solve the question. Check the full list of supported libraries at <a href=\"https://www.hackerrank.com/environment\">https://www.hackerrank.com/environment</a>.</p>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input: empower integrated markets\r\nOutput: UnFpPVACs</code></pre>\r\n<p><strong>Explanation:</strong> The event 'UnFpPVACs' has the greatest profit of all the events organized by \"empower integrated markets.\" The total profit is <code>(87815+225) &times; (0.5 &times; 28 + 0.3 &times; 96 + 0.2 &times; 169) = 6743864</code>.</p>\r\n\r\n<h3>Example 2:</h3>\r\n<pre><code class='language-text'>Input: incentivize cross-media solutions\r\nOutput: XUkxzle</code></pre>\r\n<p><strong>Explanation:</strong> The event 'XUkxzle' has the greatest profit of the events organized by \"incentivize cross-media solutions.\" The total profit is <code>(86495+171) &times; (0.5 &times; 46 + 0.3 &times; 77 + 0.2 &times; 184) = 7184611.4</code>.</p>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <iomanip>\n\n// Note: This problem requires making HTTP requests and parsing JSON.\n// In a typical C++ environment, you would need libraries like libcurl for requests\n// and a JSON library like nlohmann/json. The boilerplate below assumes\n// such libraries are available in the execution environment and focuses on the problem's logical structure.\n\nclass Solution {\npublic:\n    std::string maxProfit(const std::string& organizer) {\n        // Core logic to be implemented here.\n        // This will involve:\n        // 1. Making paginated API calls to the events endpoint, filtering by the organizer.\n        // 2. Parsing the JSON response from each page.\n        // 3. For each event, calculate the potential profit if sold out.\n        // 4. Keep track of the event name with the maximum profit.\n        // 5. Return the name of the event with the highest profit.\n        return \"\";\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    std::string organizer;\n    std::getline(std::cin, organizer);\n\n    Solution solution;\n    std::string result = solution.maxProfit(organizer);\n\n    std::cout << result << std::endl;\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "Oracle_7oct",
        "company_id": 572
    },
    {
        "id": 1639,
        "title": "Process Runtime Consolidation",
        "problem_statement": "<h1>Process Runtime Consolidation</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>You are given log entries for several processes. Each entry has:</p>\r\n<ul>\r\n    <li>the process ID (numbered from 0 to m -1),</li>\r\n    <li>the start time (in seconds), and</li>\r\n    <li>the end time (in seconds).</li>\r\n</ul>\r\n<p>A process can appear in multiple time intervals because it may be paused and resumed. For each process, merge any time ranges that overlap, then add up the total time it was running.</p>\r\n<p>Return an array of size m, where each element represents the total runtime of the corresponding process ID.</p>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input: m = 2 processes, n = 5 log entries, runtimeLogs = [[0, 0, 5], [0, 3, 7], [1, 10, 15], [1, 12, 18], [0, 20, 25]]\r\nOutput: [14, 9]</code></pre>\r\n<p><strong>Explanation:</strong></p>\r\n<pre><code class='language-text'>process ID | Time Intervals           | Merged Intervals | Total Runtime\r\n-----------|--------------------------|------------------|--------------\r\n0          | [0, 5], [3, 7], [20, 25] | [0, 7], [20, 25] | 8 + 6 = 14\r\n1          | [10, 15], [12, 18]       | [10, 18]         | 9</code></pre>\r\n\r\n<h3>Example 2:</h3>\r\n<pre><code class='language-text'>Input: m = 3 processes, n = 3 log entries, runtimeLogs = [[0, 1, 5], [1, 2, 5], [2, 5, 8]]\r\nOutput: [5, 4, 4]</code></pre>\r\n<p><strong>Explanation:</strong></p>\r\n<pre><code class='language-text'>process ID | Log Entries | Merged Intervals | Total Runtime\r\n-----------|-------------|------------------|--------------\r\n0          | [1, 5]      | [1, 5]           | 5\r\n1          | [2, 5]      | [2, 5]           | 4\r\n2          | [5, 8]      | [5, 8]           | 4</code></pre>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>1 &lt;= n, m &lt;= 2 * 10^5</code></li>\r\n    <li><code>0 &lt;= runtimeLogs[i][0] &lt; m</code></li>\r\n    <li><code>0 &lt;= runtimeLogs[i][1] &lt; runtimeLogs[i][2] &lt;= 10^9</code></li>\r\n</ul>\r\n<p><strong>Test Case Input Format:</strong></p>\r\n<p>The first line contains an integer m, the total number of processes.<br>\r\nThe next line contains an integer n, the size of the array runtimeLogs.<br>\r\nThe next line contains the integer 3, the size of the array runtimeLogs[i].<br>\r\nEach of the next n lines contains three integers representing runtimeLogs[i][0], runtimeLogs[i][1], and runtimeLogs[i][2].</p>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <map>\n\nclass Solution {\npublic:\n    std::vector<long long> getTotalRuntimes(int m, const std::vector<std::vector<int>>& runtimeLogs) {\n        // Core logic to be implemented here\n        std::vector<long long> result(m, 0);\n        return result;\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    int m;\n    std::cin >> m;\n\n    int n;\n    std::cin >> n;\n\n    int log_entry_size;\n    std::cin >> log_entry_size;\n\n    std::vector<std::vector<int>> runtimeLogs(n, std::vector<int>(3));\n    for (int i = 0; i < n; ++i) {\n        std::cin >> runtimeLogs[i][0] >> runtimeLogs[i][1] >> runtimeLogs[i][2];\n    }\n\n    Solution solution;\n    std::vector<long long> result = solution.getTotalRuntimes(m, runtimeLogs);\n\n    for (size_t i = 0; i < result.size(); ++i) {\n        std::cout << result[i] << (i == result.size() - 1 ? \"\" : \" \");\n    }\n    std::cout << std::endl;\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "Oracle_7oct",
        "company_id": 572
    },
    {
        "id": 1640,
        "title": "REST API: Finest Food Outlets",
        "problem_statement": "<h1>REST API: Finest Food Outlets</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>Use the HTTP GET method to retrieve information from a database of food outlets. Query <code>https://jsonmock.hackerrank.com/api/food_outlets?city=&lt;city&gt;</code> to find all the records for a city. The query result is paginated. To access additional pages, append <code>&amp;page=&lt;num&gt;</code> to the URL where <code>&lt;num&gt;</code> is the page number.</p>\r\n\r\n<p>The response is a JSON object with the following 5 fields:</p>\r\n<ul>\r\n    <li><code>page</code>: The current page of the results. (Number)</li>\r\n    <li><code>per_page</code>: The maximum number of results returned per page. (Number)</li>\r\n    <li><code>total</code>: The total number of results. (Number)</li>\r\n    <li><code>total_pages</code>: The total number of pages with results. (Number)</li>\r\n    <li><code>data</code>: Either an empty array or an array with a single object that contains the food outlets' records.</li>\r\n</ul>\r\n\r\n<p>In data, each food outlet has the following schema:</p>\r\n<ul>\r\n    <li><code>id</code>: outlet id (Number)</li>\r\n    <li><code>name</code>: The name of the outlet (String)</li>\r\n    <li><code>city</code>: The city in which the outlet is located (String)</li>\r\n    <li><code>estimated_cost</code>: The estimated cost of the food in the particular outlet (Number).</li>\r\n    <li><code>user_rating</code>: An object containing the user ratings for the outlet. The object has the following schema:\r\n        <ul>\r\n            <li><code>average_rating</code>: The average user rating for the outlet (Number)</li>\r\n            <li><code>votes</code>: The number of people who voted for the outlet (Number)</li>\r\n        </ul>\r\n    </li>\r\n</ul>\r\n\r\n<p>Given the city name as <code>city</code> and minimum vote count as <code>votes</code>, filter the results by city name. Find the food outlet with the highest rating and whose vote count is greater than or equal to the required minimum votes. In case of a tie in the rating, return the one with the maximum vote count.</p>\r\n\r\n<h3>Function Description</h3>\r\n<p>Complete the function <code>finestFoodOutlet</code> in the editor with the following parameter(s):</p>\r\n<ul>\r\n    <li><code>string city</code>: name of the city whose outlets have to be filtered</li>\r\n    <li><code>integer votes</code>: number of votes</li>\r\n</ul>\r\n\r\n<h3>Returns</h3>\r\n<p><code>string</code>: the winning restaurant</p>\r\n\r\n<p><strong>Note:</strong> Please review the header in the code stub to see available libraries for API requests in the selected language. Required libraries can be imported in order to solve the question. Check our full list of supported libraries at <a href=\"https://www.hackerrank.com/environment\">https://www.hackerrank.com/environment</a>.</p>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input:\r\nSeattle\r\n500\r\nOutput:\r\nCafe Juanita</code></pre>\r\n<p><strong>Explanation:</strong> In Seattle, results are filtered to those with votes &gt;= 500. There are 4 food outlets whose rating is 4.9. Cafe Juanita has 16203 votes.</p>\r\n\r\n<h3>Example 2:</h3>\r\n<pre><code class='language-text'>Input:\r\nMiami\r\n1000\r\nOutput:\r\nPirates of Grill</code></pre>\r\n<p><strong>Explanation:</strong> In Miami, results are filtered to those with votes &gt;= 1000. There are 5 food outlets whose rating is 4.8. Pirates of Grill has 4879 votes.</p>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\n// Note: For a real-world solution on a platform like HackerRank,\n// you would need to include specific headers for HTTP requests and JSON parsing,\n// which are provided by the platform's environment.\n// For example:\n// #include <nlohmann/json.hpp> // for JSON parsing\n// #include <cpr/cpr.h>         // for HTTP requests\n\nclass Solution {\npublic:\n    /**\n     * @brief Finds the finest food outlet in a given city based on rating and votes.\n     *\n     * @param city The name of the city to search in.\n     * @param votes The minimum number of votes required for an outlet to be considered.\n     * @return The name of the winning food outlet.\n     */\n    std::string finestFoodOutlet(std::string city, int votes) {\n        // The core logic to perform API calls, parse JSON,\n        // and determine the best outlet will be implemented here.\n        // This boilerplate provides the structure for input/output handling.\n        \n        // Placeholder return\n        return \"\";\n    }\n};\n\nint main() {\n    // Fast I/O\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    std::string city;\n    std::getline(std::cin, city);\n\n    int votes;\n    std::cin >> votes;\n\n    Solution solution;\n    std::string result = solution.finestFoodOutlet(city, votes);\n\n    std::cout << result << std::endl;\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "Oracle_7oct",
        "company_id": 572
    },
    {
        "id": 1641,
        "title": "REST API: Best TV Shows in Genre",
        "problem_statement": "<h1>REST API: Best TV Shows in Genre</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>Utilize the HTTP GET method to retrieve details about recent TV shows. Query <code>https://jsonmock.hackerrank.com/api/tvseries</code> to locate all shows within a specific genre. The results are paginated. To access more pages, add <code>?page={num}</code> to the URL where <code>{num}</code> represents the page number.</p>\r\n\r\n<p>The response is a JSON object with the following 5 fields:</p>\r\n<ul>\r\n    <li><code>page</code>: the current page of the results (Number)</li>\r\n    <li><code>per_page</code>: the maximum number of results returned per page (Number)</li>\r\n    <li><code>total</code>: the total number of results (Number)</li>\r\n    <li><code>total_pages</code>: the total number of pages with results (Number)</li>\r\n    <li><code>data</code>: an array of TV series records</li>\r\n</ul>\r\n\r\n<p>Example of a data array object:</p>\r\n<pre><code class='language-text'>{\r\n    \"name\": \"Game of Thrones\",\r\n    \"runtime_of_series\": \"(2011-2019)\",\r\n    \"certificate\": \"TV-MA\",\r\n    \"runtime_of_episodes\": \"57 min\",\r\n    \"genre\": \"Action, Adventure, Drama\",\r\n    \"imdb_rating\": 9.3,\r\n    \"overview\": \"Nine noble families fight for control over the lands of Westeros, while an ancient enemy returns after being dormant for millennia.\",\r\n    \"no_of_votes\": 1773458,\r\n    \"id\": 1\r\n}</code></pre>\r\n\r\n<p>In data, each TV series has the following schema:</p>\r\n<ul>\r\n    <li><code>name</code>: (String)</li>\r\n    <li><code>runtime_of_series</code>: years with a new season (String)</li>\r\n    <li><code>certificate</code>: rating (String)</li>\r\n    <li><code>runtime_of_episodes</code>: average length per episode in minutes (String).</li>\r\n    <li><code>genre</code>: genre (String)</li>\r\n    <li><code>imdb_rating</code>: average viewer rating (Number)</li>\r\n    <li><code>overview</code>: short description (String)</li>\r\n    <li><code>no_of_votes</code>: how many votes were cast at IMDB (Number)</li>\r\n    <li><code>id</code>: unique id (Number)</li>\r\n</ul>\r\n\r\n<p>Given a genre, find the series with the highest <code>imdb_rating</code>. If there is a tie, return the alphabetically lower name.</p>\r\n\r\n<p>Complete the function <code>bestInGenre</code> in the editor with the following parameter:</p>\r\n<ul>\r\n    <li><code>string genre</code>: the genre to search</li>\r\n</ul>\r\n\r\n<p><strong>Return</strong></p>\r\n<p><code>string</code>: the highest-rated show in the genre, with the lowest name alphabetically if there is a tie.</p>\r\n\r\n<p>Note: Please review the header in the code stub to see available libraries for API requests in the selected language. Required libraries can be imported in order to solve the question. Check our full list of supported libraries at <a href=\"https://www.hackerrank.com/environment\">https://www.hackerrank.com/environment</a>.</p>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input: genre = \"Action\"\r\nOutput: \"Game of Thrones\"</code></pre>\r\n<p><strong>Explanation:</strong> The 4 highest-rated shows in the 'Action' genre are shown:</p>\r\n<pre><code class='language-text'>'Game of Thrones', 9.3\r\n'Avatar: The Last Airbender', 9.2\r\n'Hagane no renkinjutsushi', 9.1\r\n'Shingeki no kyojin', 8.9</code></pre>\r\n<p>Among these, 'Game of Thrones' has the highest rating (9.3).</p>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\n// Note: For this specific problem, you would typically need libraries for\n// making HTTP requests (like libcurl) and for parsing JSON (like nlohmann/json).\n// These are usually provided in the HackerRank environment.\n// The boilerplate below sets up the structure as requested, assuming\n// those libraries are available and can be included.\n\nclass Solution {\npublic:\n    /**\n     * @brief Finds the best TV show in a given genre from a paginated API.\n     * \n     * @param genre The genre to search for.\n     * @return std::string The name of the highest-rated show. If there's a tie in rating,\n     *                     the one with the alphabetically smaller name is chosen.\n     */\n    std::string bestInGenre(std::string genre) {\n        // Core logic to fetch data from the API, parse JSON,\n        // and find the best show will go here.\n        return \"\";\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    std::string genre;\n    std::getline(std::cin, genre);\n\n    Solution sol;\n    std::string result = sol.bestInGenre(genre);\n\n    std::cout << result << std::endl;\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "Oracle_7oct",
        "company_id": 572
    },
    {
        "id": 1642,
        "title": "Best Food Outlet",
        "problem_statement": "<h1>Best Food Outlet</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>You need to retrieve information about restaurants from an API. The task involves querying a database of restaurant information using HTTP GET requests to find the restaurant with the highest rating within a specified cost constraint.</p>\r\n<p>The API endpoint is: <code>https://jsonmock.hackerrank.com/api/food_outlets?city=&lt;city&gt;</code> (replace <code>&lt;city&gt;</code>). The response is paginated and can be accessed by appending <code>&amp;page=&lt;num&gt;</code> to the query string (replace <code>&lt;num&gt;</code>).</p>\r\n<p>Each response contains:</p>\r\n<ul>\r\n    <li><code>page</code>: Current page number</li>\r\n    <li><code>per_page</code>: Maximum results per page</li>\r\n    <li><code>total</code>: Total number of results</li>\r\n    <li><code>total_pages</code>: Total number of pages</li>\r\n    <li><code>data</code>: Array of food outlet records</li>\r\n</ul>\r\n<p>Each food outlet record includes:</p>\r\n<ul>\r\n    <li><code>id</code>: Outlet ID</li>\r\n    <li><code>name</code>: Outlet name</li>\r\n    <li><code>city</code>: Location city</li>\r\n    <li><code>estimated_cost</code>: Estimated food cost</li>\r\n    <li><code>user_rating</code>: Object containing <code>average_rating</code> and <code>votes</code></li>\r\n</ul>\r\n<p>Given a city and a maximum cost, find the food outlet in that city with the highest rating whose estimated_cost is at most the given cost. If multiple restaurants tie for the highest rating, return the one with the lowest cost.</p>\r\n<p>Complete the function <code>bestRestaurant</code> in the editor with the following parameter(s):</p>\r\n<ul>\r\n    <li><code>string city</code>: name of the city whose outlets must be filtered</li>\r\n    <li><code>integer cost</code>: the maximum acceptable estimated cost</li>\r\n</ul>\r\n<p><strong>Returns</strong></p>\r\n<ul>\r\n    <li><code>string</code>: the name of the winning food outlet</li>\r\n</ul>\r\n<p><strong>Note:</strong> Please review the header in the code stub to see available libraries for API requests in the selected language. Required libraries can be imported in order to solve the question. Check our full list of supported libraries at <a href=\"https://www.hackerrank.com/environment\">https://www.hackerrank.com/environment</a>.</p>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input:\r\nSeattle\r\n120</code></pre>\r\n<pre><code class='language-text'>Output:\r\nTBC Sky Lounge</code></pre>\r\n<p><strong>Explanation:</strong> In Seattle, results are limited to those where estimated_cost is less than or equal to 120. Truffles and TBC Sky Lounge are both rated 4.7. TBC Sky Lounge has an expected cost of 10 versus Truffles' expected cost of 90.</p>\r\n\r\n<h3>Example 2:</h3>\r\n<pre><code class='language-text'>Input:\r\nMiami\r\n100</code></pre>\r\n<pre><code class='language-text'>Output:\r\nThe Mughal Trail</code></pre>\r\n<p><strong>Explanation:</strong> In Miami, results are limited to those where estimated_cost is less than or equal to 100. For restaurants with a rating of 4.8, the highest in Miami, their names and expected costs are Cafe Wink 70, Cenlis 70, and The Mughal Trail 50.</p>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\n// Note: For a real-world solution on platforms like HackerRank,\n// you would need to include specific libraries for making HTTP requests\n// and parsing JSON, which are provided by the platform's environment.\n// This boilerplate focuses on the logical structure of the solution.\n\nclass Solution {\npublic:\n    /**\n     * @brief Finds the best food outlet in a given city within a specified cost.\n     *\n     * The \"best\" outlet is defined as the one with the highest rating.\n     * If there's a tie in rating, the one with the lower estimated cost is chosen.\n     *\n     * @param city The name of the city to search for food outlets.\n     * @param cost The maximum acceptable estimated cost for a food outlet.\n     * @return The name of the best food outlet.\n     */\n    std::string bestRestaurant(std::string city, int cost) {\n        // The core logic to solve the problem will be implemented here.\n        // This would typically involve:\n        // 1. Making paginated HTTP GET requests to the API endpoint.\n        // 2. Parsing the JSON response from each page.\n        // 3. Iterating through the 'data' array of food outlets.\n        // 4. For each outlet, check if its 'estimated_cost' is within the given 'cost'.\n        // 5. Keep track of the outlet with the highest 'user_rating.average_rating'.\n        // 6. Handle ties by choosing the one with the lower 'estimated_cost'.\n        // 7. Return the 'name' of the final best outlet found.\n\n        // Placeholder return value.\n        return \"\";\n    }\n};\n\nint main() {\n    // Fast I/O\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    std::string city;\n    int cost;\n\n    // Read the input city and cost\n    std::cin >> city >> cost;\n\n    // Create an instance of the Solution class\n    Solution sol;\n\n    // Call the bestRestaurant method with the parsed input\n    std::string result = sol.bestRestaurant(city, cost);\n\n    // Print the result\n    std::cout << result << std::endl;\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "Oracle_7oct",
        "company_id": 572
    }
]