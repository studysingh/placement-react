[
    {
        "id": 1657,
        "title": "Maximal TextScore Substring",
        "problem_statement": "<h1>Maximal TextScore Substring</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>Complete the function <code>calculateScore</code> in the editor below. The function must return a string that denotes the non-empty substring of <code>text</code> having a maximal <code>textScore</code>. If there are multiple such substrings, choose the lexicographically smallest substring.</p>\r\n\r\n<p>For each non-empty substring <code>sub</code> of <code>text</code>, the <code>textScore</code> is calculated as follows:</p>\r\n<ul>\r\n    <li><strong>prefixScore:</strong> The length of the longest prefix of <code>sub</code> that is also a suffix of <code>prefixString</code>.</li>\r\n    <li><strong>suffixScore:</strong> The length of the longest suffix of <code>sub</code> that is also a prefix of <code>suffixString</code>.</li>\r\n    <li><strong>textScore:</strong> <code>prefixScore + suffixScore</code>.</li>\r\n</ul>\r\n\r\n<p>The function <code>calculateScore</code> has the following parameter(s):</p>\r\n<ul>\r\n    <li><code>text</code>: a string</li>\r\n    <li><code>prefixString</code>: a string</li>\r\n    <li><code>suffixString</code>: a string</li>\r\n</ul>\r\n\r\n<p><strong>Input Format for Custom Testing:</strong><br>\r\nInput from stdin will be processed as follows and passed to the function.</p>\r\n<p>The first line contains a string <code>text</code>.<br>\r\nThe next line contains a string <code>prefixString</code>.<br>\r\nThe last line contains a string <code>suffixString</code>.</p>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input:\r\nnothing\r\nbruno\r\ningenious\r\nOutput:\r\nnothing</code></pre>\r\n<p><strong>Explanation:</strong>\r\nGiven <code>text = \"nothing\"</code>, <code>prefixString = \"bruno\"</code>, and <code>suffixString = \"ingenious\"</code>.</p>\r\n<p>Consider the substring <code>sub = \"nothing\"</code>:</p>\r\n<ul>\r\n    <li><strong>prefixScore:</strong> The longest prefix of \"nothing\" that is a suffix of \"bruno\" is \"no\" (length 2). So, <code>prefixScore = 2</code>.</li>\r\n    <li><strong>suffixScore:</strong> The longest suffix of \"nothing\" that is a prefix of \"ingenious\" is \"ing\" (length 3). So, <code>suffixScore = 3</code>.</li>\r\n    <li><strong>textScore:</strong> <code>2 + 3 = 5</code>.</li>\r\n</ul>\r\n<p>This substring \"nothing\" yields the maximal <code>textScore</code> of 5.</p>\r\n\r\n<h3>Example 2:</h3>\r\n<pre><code class='language-text'>Input:\r\nab\r\nb\r\na\r\nOutput:\r\na</code></pre>\r\n<p><strong>Explanation:</strong>\r\nGiven <code>text = \"ab\"</code>, <code>prefixString = \"b\"</code>, and <code>suffixString = \"a\"</code>.<br>\r\nOur possible non-empty substrings are \"a\", \"b\", and \"ab\".</p>\r\n<ul>\r\n    <li><strong>sub = \"a\":</strong>\r\n        <ul>\r\n            <li><strong>prefixScore:</strong> The longest prefix of \"a\" that is a suffix of \"b\" is an empty string. So, <code>prefixScore = 0</code>.</li>\r\n            <li><strong>suffixScore:</strong> The longest suffix of \"a\" that is a prefix of \"a\" is \"a\" (length 1). So, <code>suffixScore = 1</code>.</li>\r\n            <li><strong>textScore:</strong> <code>0 + 1 = 1</code>.</li>\r\n        </ul>\r\n    </li>\r\n    <li><strong>sub = \"b\":</strong>\r\n        <ul>\r\n            <li><strong>prefixScore:</strong> The longest prefix of \"b\" that is a suffix of \"b\" is \"b\" (length 1). So, <code>prefixScore = 1</code>.</li>\r\n            <li><strong>suffixScore:</strong> The longest suffix of \"b\" that is a prefix of \"a\" is an empty string. So, <code>suffixScore = 0</code>.</li>\r\n            <li><strong>textScore:</strong> <code>1 + 0 = 1</code>.</li>\r\n        </ul>\r\n    </li>\r\n    <li><strong>sub = \"ab\":</strong>\r\n        <ul>\r\n            <li><strong>prefixScore:</strong> The longest prefix of \"ab\" that is a suffix of \"b\" is an empty string. So, <code>prefixScore = 0</code>.</li>\r\n            <li><strong>suffixScore:</strong> The longest suffix of \"ab\" that is a prefix of \"a\" is an empty string. So, <code>suffixScore = 0</code>.</li>\r\n            <li><strong>textScore:</strong> <code>0 + 0 = 0</code>.</li>\r\n        </ul>\r\n    </li>\r\n</ul>\r\n<p>Both \"a\" and \"b\" have a maximal <code>textScore</code> of 1. Since \"a\" is lexicographically smaller than \"b\", we return \"a\".</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>text</code>, <code>prefixString</code>, and <code>suffixString</code> contain lowercase English alphabetic letters <code>ascii[a-z]</code> only.</li>\r\n    <li><code>1 &lt;= |text|, |prefixString|, |suffixString| &lt;= 50</code>.</li>\r\n    <li>It is guaranteed that there will always be a substring of <code>text</code> that matches at least one of the following:\r\n        <ul>\r\n            <li>One or more characters at the end of <code>prefixString</code>.</li>\r\n            <li>One or more characters at the beginning of <code>suffixString</code>.</li>\r\n        </ul>\r\n    </li>\r\n</ul>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nclass Solution {\npublic:\n    std::string calculateScore(const std::string& text, const std::string& prefixString, const std::string& suffixString) {\n        // Your implementation here\n        return \"\";\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    std::string text;\n    std::cin >> text;\n\n    std::string prefixString;\n    std::cin >> prefixString;\n\n    std::string suffixString;\n    std::cin >> suffixString;\n\n    Solution solution;\n    std::string result = solution.calculateScore(text, prefixString, suffixString);\n\n    std::cout << result << std::endl;\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "Publicis Sapient",
        "company_id": 579
    },
    {
        "id": 1658,
        "title": "Minimum Swaps for Even-Odd Partition",
        "problem_statement": "<h1>Minimum Swaps for Even-Odd Partition</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>In an array, we can swap the elements at any two indices in a single operation called a move. For example, if our array is <code>a = [17, 4, 8]</code>, we can swap <code>a[0] = 17</code> and <code>a[2] = 8</code> to get <code>a = [8, 4, 17]</code> in a single move. We want to custom-sort an array such that all of the even elements are at the beginning of the array and all of the odd elements are at the end of the array.</p>\r\n<p>For example, if our array is <code>[6, 3, 4, 5]</code>, then the following four arrays are valid custom-sorted arrays:</p>\r\n<ul>\r\n    <li><code>a = [6, 4, 3, 5]</code></li>\r\n    <li><code>a = [4, 6, 3, 5]</code></li>\r\n    <li><code>a = [6, 4, 5, 3]</code></li>\r\n    <li><code>a = [4, 6, 5, 3]</code></li>\r\n</ul>\r\n<p>Complete the function <code>moves</code> in the editor below. The function must return the minimum number of moves it takes to sort an array of integers with all even elements at earlier indexes than any odd element.</p>\r\n<p>The function <code>moves</code> has the following parameter:</p>\r\n<ul>\r\n    <li><code>a[a[0]...a[n-1]]</code>: an array of positive integers</li>\r\n</ul>\r\n<p><strong>Note:</strong> The order of the elements within even or odd does not matter.</p>\r\n\r\n<h3>Input Format for Custom Testing</h3>\r\n<p>Input from stdin will be processed as follows and passed to the function:</p>\r\n<p>The first line contains an integer <code>n</code>, the number of elements in array <code>a</code>.</p>\r\n<p>The next <code>n</code> lines each contain an integer describing <code>a[i]</code> where <code>0 <= i < n</code>.</p>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input:\r\n4\r\n13\r\n10\r\n21\r\n20\r\nOutput: 1</code></pre>\r\n<p><strong>Explanation:</strong> Given <code>a = [13, 10, 21, 20]</code>, we can swap <code>a[0]</code> and <code>a[3]</code> to get the custom-sorted array <code>a = [20, 10, 21, 13]</code> in 1 move.</p>\r\n\r\n<h3>Example 2:</h3>\r\n<pre><code class='language-text'>Input:\r\n5\r\n8\r\n5\r\n11\r\n4\r\n6\r\nOutput: 2</code></pre>\r\n<p><strong>Explanation:</strong> We can perform the following moves on our initial array <code>a = [8, 5, 11, 4, 6]</code>:</p>\r\n<ol>\r\n    <li>Swap <code>a[1]</code> and <code>a[3]</code> to get the array <code>a = [8, 4, 11, 5, 6]</code>.</li>\r\n    <li>Swap <code>a[2]</code> and <code>a[4]</code> to get the array <code>a = [8, 4, 6, 5, 11]</code>.</li>\r\n</ol>\r\n<p>It took two moves to get a valid custom-sorted array. As this value is minimal, the function returns 2.</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>2 <= n <= 10^5</code></li>\r\n    <li><code>1 <= a[i] <= 10^9</code>, where <code>0 <= i < n</code></li>\r\n    <li>It is guaranteed that array <code>a</code> contains at least one even and one odd element.</li>\r\n</ul>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <numeric>\n\nclass Solution {\npublic:\n    /**\n     * @brief Calculates the minimum number of moves to partition the array.\n     * \n     * @param a A vector of positive integers.\n     * @return The minimum number of swaps required.\n     */\n    int moves(std::vector<int>& a) {\n        // Core logic to calculate minimum swaps goes here.\n        // The goal is to move all even numbers to the left part of the array\n        // and all odd numbers to the right part.\n        // This can be solved efficiently using a two-pointer approach.\n        // One pointer starts from the beginning, looking for an odd number.\n        // The other pointer starts from the end, looking for an even number.\n        // When both are found, they are swapped, and the pointers move inward.\n        // The number of such swaps is the minimum required.\n        return 0; // Placeholder return\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    int n;\n    std::cin >> n;\n\n    std::vector<int> a(n);\n    for (int i = 0; i < n; ++i) {\n        std::cin >> a[i];\n    }\n\n    Solution sol;\n    int result = sol.moves(a);\n\n    std::cout << result << std::endl;\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "Publicis Sapient",
        "company_id": 579
    },
    {
        "id": 1659,
        "title": "Knight Dialer",
        "problem_statement": "<h1>Knight Dialer</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>A chess knight moves in a unique way: it can jump two squares vertically and one square horizontally, or two squares horizontally and one square vertically, forming an L-shape.</p>\r\n<p>In this problem, we have a knight on a phone keypad, and it can only stand on numeric cells. Given an integer `n`, the task is to return the number of distinct phone numbers of length `n` that the knight can dial.</p>\r\n<p>You can place the knight on any numeric cell initially, and then the knight must make `n - 1` valid jumps to form a number of length `n`. Each jump must follow the knight's movement rules.</p>\r\n<p>Since the result could be very large, return the answer modulo 10^9 + 7.</p>\r\n\r\n<pre><code class='language-cpp'>#include &lt;bits/stdc++.h&gt;\r\nusing namespace std;\r\n\r\nconst int MOD = 1000000007;\r\n\r\n// Function to return the number of distinct phone numbers the knight can dial\r\nint knightDialer(int n) {\r\n    // Enter your code here\r\n}\r\n\r\n// Driver code\r\nint main() {\r\n    int n; // n: length of the phone number\r\n    // Input the length of the phone number\r\n    cout &lt;&lt; \"Enter the length of the phone number\" &lt;&lt; endl;\r\n    cin &gt;&gt; n;\r\n\r\n    // Output the result of knightDialer function\r\n    cout &lt;&lt; knightDialer(n) &lt;&lt; endl;\r\n\r\n    return 0;\r\n}\r\n</code></pre>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <vector>\n#include <string>\n\nclass Solution {\npublic:\n    int knightDialer(int n) {\n        // Core logic to calculate the number of distinct phone numbers\n        // of length n that the knight can dial.\n        // The result should be modulo 10^9 + 7.\n        return 0; // Placeholder return\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n    int n;\n    std::cin >> n;\n    Solution sol;\n    int result = sol.knightDialer(n);\n    std::cout << result << std::endl;\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "Publicis Sapient",
        "company_id": 579
    },
    {
        "id": 1660,
        "title": "Degree of an Array",
        "problem_statement": "<h1>Degree of an Array</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>Given a non-empty array of non-negative integers <code>nums</code>, the degree of this array is defined as the maximum frequency of any one of its elements. Your task is to find the smallest possible length of a continuous subarray of <code>nums</code>, that has the same degree as <code>nums</code>.</p>\r\n\r\n<pre><code class='language-cpp'>#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\n#include &lt;algorithm&gt;\r\n// Potentially other includes like &lt;map&gt; for frequency counting\r\n\r\n// function to find the smallest length subarray with the same degree as the array\r\nint findShortestSubarray(vector<int>& nums) {\r\n    // Enter your code here\r\n}\r\n\r\nint main() {\r\n    int n;\r\n    // enter the size of the array\r\n    std::cout << \"Enter the size of the array: \";\r\n    std::cin >> n; // input size of the array\r\n\r\n    std::vector<int> nums(n); // Declare the array\r\n    std::cout << \"Enter the array elements: \";\r\n    for (int i = 0; i < n; i++) {\r\n        std::cin >> nums[i]; // input array elements\r\n    }\r\n\r\n    std::cout << findShortestSubarray(nums) << std::endl; // Output the result\r\n\r\n    return 0;\r\n}\r\n</code></pre>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <unordered_map>\n\nclass Solution {\npublic:\n    /**\n     * @brief Finds the smallest possible length of a continuous subarray of nums,\n     * that has the same degree as nums.\n     * @param nums A non-empty vector of non-negative integers.\n     * @return The length of the shortest subarray with the same degree.\n     */\n    int findShortestSubarray(std::vector<int>& nums) {\n        // Core logic to be implemented here.\n        return 0; // Placeholder return\n    }\n};\n\nint main() {\n    // Fast I/O\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    int n;\n    std::cin >> n; // Input size of the array\n\n    std::vector<int> nums(n);\n    for (int i = 0; i < n; ++i) {\n        std::cin >> nums[i]; // Input array elements\n    }\n\n    Solution solution;\n    int result = solution.findShortestSubarray(nums);\n\n    std::cout << result << std::endl;\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "Publicis Sapient",
        "company_id": 579
    }
]