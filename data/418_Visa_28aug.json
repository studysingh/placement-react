[
    {
        "id": 1230,
        "title": "Contiguous Fruit Sections with K Pairs",
        "problem_statement": "<h1>Contiguous Fruit Sections with K Pairs</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>You're an inspector at a large fruit orchard. After harvesting, the fruits are laid out in a long conveyor belt. Your job is to identify sections of the conveyor belt that have a significant number of duplicate fruits. Specifically, you need to count the number of contiguous sections of the belt where you can form at least <code>k</code> pairs of identical fruits based on their position on the belt. Each fruit at a specific position can be part of at most one pair when counting towards the <code>k</code> pairs.</p>\r\n\r\n<p>Your solution should implement the following function:</p>\r\n<pre><code class='language-cpp'>int solution(vector&lt;int&gt; fruits, int k) {\r\n    // ... your code here\r\n}</code></pre>\r\n\r\n<p><strong>Input:</strong></p>\r\n<ul>\r\n    <li><code>fruits</code>: An array of integers representing the sequence of fruits on the conveyor belt.</li>\r\n    <li><code>k</code>: A positive integer representing the minimum number of pairs to count.</li>\r\n</ul>\r\n\r\n<p><strong>Output:</strong></p>\r\n<ul>\r\n    <li>An integer representing the number of contiguous sections which contain at least <code>k</code> pairs of identical fruits.</li>\r\n</ul>\r\n\r\n<p><strong>Execution Time Limit:</strong> 0.5 seconds (cpp)</p>\r\n<p><strong>Memory Limit:</strong> 1 GB</p>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input: fruits = [0, 1, 0, 1, 0], k = 2\r\nOutput: 3</code></pre>\r\n<p><strong>Explanation:</strong> There are 3 contiguous sections where you can find at least k = 2 pairs of identical fruits:</p>\r\n<ul>\r\n    <li><code>fruits[0..3] = [0, 1, 0, 1]</code>: One pair of fruit type 0 (at positions 0 and 2) and one pair of fruit type 1 (at positions 1 and 3).</li>\r\n    <li><code>fruits[1..4] = [1, 0, 1, 0]</code>: One pair of fruit type 1 (at positions 0 and 2 within this section) and one pair of fruit type 0 (at positions 1 and 3 within this section).</li>\r\n    <li><code>fruits[0..4] = [0, 1, 0, 1, 0]</code>: We can form one pair of fruit type 0 (e.g., at indices 0 and 2) and one pair of fruit type 1 (at indices 1 and 3). Note that it is not possible to form both a pair with the 0 at index 0 and the 0 at index 2, and a pair with the 0 at index 2 and the 0 at index 4, at the same time, since each fruit can belong to only one pair.</li>\r\n</ul>\r\n\r\n<h3>Example 2:</h3>\r\n<pre><code class='language-text'>Input: fruits = [2, 2, 2, 2, 2], k = 3\r\nOutput: 1</code></pre>\r\n<p><strong>Explanation:</strong> There is only 1 applicable contiguous section <code>fruits[0..5] = [2, 2, 2, 2, 2]</code>, where you can form at least three pairs of fruit type 2 (e.g., the fruit at position 0 with position 1, position 2 with position 3, and position 4 with position 5).</p>\r\n\r\n<h3>Example 3:</h3>\r\n<pre><code class='language-text'>Input: fruits = [1, 3, 3, 1], k = 1\r\nOutput: 4</code></pre>\r\n<p><strong>Explanation:</strong> There are 4 contiguous sections where you can find at least k = 1 pair of identical fruits:</p>\r\n<ul>\r\n    <li><code>fruits[0..2] = [1, 3, 3]</code> (a pair of fruit type 3 at positions 1 and 2)</li>\r\n    <li><code>fruits[0..3] = [1, 3, 3, 1]</code> (a pair of fruit type 3 at positions 1 and 2)</li>\r\n    <li><code>fruits[1..2] = [3, 3]</code> (a pair of fruit type 3 at positions 0 and 1 within this section)</li>\r\n    <li><code>fruits[1..3] = [3, 3, 1]</code> (a pair of fruit type 3 at positions 0 and 1 within this section)</li>\r\n</ul>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>2 &lt;= fruits.length &lt;= 2000</code></li>\r\n    <li><code>0 &lt;= fruits[i] &lt;= 10^4</code></li>\r\n    <li><code>1 &lt;= k &lt;= fruits.length / 2</code></li>\r\n</ul>",
        "google_doc_link": null,
        "solution_code": null,
        "company_name": "Visa_28aug",
        "company_id": 418
    },
    {
        "id": 1238,
        "title": "Count Power Readings",
        "problem_statement": "<h1>Count Power Readings</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>You are monitoring energy usage in a smart grid system and need to identify specific data patterns in the readings.</p>\r\n<p>Given an array of integers <code>readings</code> representing the energy readings over a period and an integer <code>k</code>, count the readings that are powers of <code>k</code>. In this context, a power of <code>k</code> refers to numbers that can be expressed as <code>k</code> raised to an integer power (e.g., k⁰, k¹, k², etc.).</p>\r\n<p>Note: You are not expected to provide the most optimal solution, but a solution with time complexity not worse than O(readings.length²) will fit within the execution time limit.</p>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input: readings = [2, 4, 7, 8, 16, 32, 120], k = 2\r\nOutput: 5</code></pre>\r\n<p><strong>Explanation:</strong> The numbers in the <code>readings</code> list that are powers of 2 are 2 (2¹), 4 (2²), 8 (2³), 16 (2⁴), and 32 (2⁵). There are 5 such numbers.</p>\r\n\r\n<h3>Example 2:</h3>\r\n<pre><code class='language-text'>Input: readings = [10201, 101, 1030301, 101, 101], k = 101\r\nOutput: 5</code></pre>\r\n<p><strong>Explanation:</strong> All numbers in the <code>readings</code> list are powers of 101: 101 (101¹), 10201 (101²), and 1030301 (101³). Since 101 appears three times, 10201 once, and 1030301 once, all five elements are powers of 101.</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>1 <= readings.length <= 1000</code></li>\r\n    <li><code>2 <= readings[i] <= 10^9</code></li>\r\n    <li><code>2 <= k <= 10^9</code></li>\r\n</ul>",
        "google_doc_link": null,
        "solution_code": null,
        "company_name": "Visa_28aug",
        "company_id": 418
    },
    {
        "id": 1239,
        "title": "Phone Battery Management",
        "problem_statement": "<h1>Phone Battery Management</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>Imagine that your mobile phone is currently out of battery, but you need to use it for <code>t</code> more minutes. Luckily, you have a number of spare batteries that are fully charged, where the <code>i</code>-th battery lets you use the phone for <code>capacity[i]</code> more minutes. After <code>capacity[i]</code> minutes, this battery becomes depleted, and has to be fully recharged for <code>recharge[i]</code> minutes before you can use it again. You use the extra batteries in the given order until each one is fully depleted, and then switch to the next one. If the next battery is still recharging, skip it and try the next one. This process continues cyclically until you are done using your phone after <code>t</code> minutes.</p>\r\n<p>Return the number of full batteries used during the <code>t</code> minutes you need to use your phone. If it is impossible to have the phone working during the entire duration of <code>t</code> minutes - i.e., if at some point all batteries are recharging and unavailable, return <code>-1</code>.</p>\r\n<p><strong>Note:</strong> You are not expected to provide the most optimal solution, but a solution with time complexity not worse than <code>O(t * capacity.length)</code> will fit within the execution time limit.</p>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input: t = 16, capacity = [2, 5, 6], recharge = [12, 1, 4]\r\nOutput: 3</code></pre>\r\n<p><strong>Explanation:</strong></p>\r\n<ul>\r\n<li>At <code>t = 0</code>: At the beginning, the phone is connected to battery 0 with <code>capacity[0] = 2</code>, which lets you use the phone for 2 minutes.</li>\r\n<li>At <code>t = 2</code>: Battery 0 becomes depleted (it will be recharged at <code>t = 2 + recharge[0] = 14</code>), so you switch to battery 1 with <code>capacity[1] = 5</code>, which lets you use the phone for 5 more minutes.</li>\r\n<li>At <code>t = 7</code>: Battery 1 becomes depleted (it will be recharged at <code>t = 7 + recharge[1] = 8</code>), so you switch to battery 2 with <code>capacity[2] = 6</code>, which lets you use the phone for 6 more minutes.</li>\r\n<li>At <code>t = 13</code>: Battery 2 becomes depleted (it will be recharged at <code>t = 13 + recharge[2] = 17</code>), so you try to switch (cyclically) back to battery 0. However, it is still recharging and will not be available until <code>t = 14</code>.</li>\r\n<li>Still at <code>t = 13</code>: Since battery 0 is unavailable, you switch to battery 1, which is already fully recharged with <code>capacity[1] = 5</code>, so you can use the phone for another 5 minutes.</li>\r\n<li>You can continue using battery 1 until <code>t = 16</code>, when you will be done with the phone. So, in total, 3 full batteries have been used.</li>\r\n</ul>\r\n\r\n<h3>Example 2:</h3>\r\n<pre><code class='language-text'>Input: t = 16, capacity = [2, 5, 6], recharge = [12, 8, 4]\r\nOutput: -1</code></pre>\r\n<p><strong>Explanation:</strong></p>\r\n<ul>\r\n<li>At <code>t = 0</code>: At the beginning, the phone is connected to battery 0 with <code>capacity[0] = 2</code>, which lets you use the phone for 2 minutes.</li>\r\n<li>At <code>t = 2</code>: Battery 0 becomes depleted (it will be recharged at <code>t = 2 + recharge[0] = 14</code>), so you switch to battery 1 with <code>capacity[1] = 5</code>, which lets you use the phone for 5 more minutes.</li>\r\n<li>At <code>t = 7</code>: Battery 1 becomes depleted (it will be recharged at <code>t = 7 + recharge[1] = 15</code>), so you switch to battery 2 with <code>capacity[2] = 6</code>, which lets you use the phone for 6 more minutes.</li>\r\n<li>At <code>t = 13</code>: Battery 2 becomes depleted (it will be recharged at <code>t = 13 + recharge[2] = 17</code>), so you try to switch (cyclically) back to battery 0. However, it is still recharging and will not be available until <code>t = 14</code>.</li>\r\n<li>Still at <code>t = 13</code>: You try to switch to battery 1, but it is also still recharging and will not be available until <code>t = 15</code>.</li>\r\n<li>Still at <code>t = 13</code>: You then try to switch to battery 2, but it is also still recharging and will not be available until <code>t = 17</code>.</li>\r\n<li>Still at <code>t = 13</code>: Since all batteries are currently recharging and unavailable, you cannot continue to use the phone, so the answer is <code>-1</code>.</li>\r\n</ul>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n<li><code>1 <= t <= 5000</code></li>\r\n<li><code>1 <= capacity.length <= 100</code></li>\r\n<li><code>1 <= capacity[i] <= 100</code></li>\r\n<li><code>1 <= recharge.length <= 100</code></li>\r\n<li><code>recharge.length = capacity.length</code></li>\r\n<li><code>1 <= recharge[i] <= 100</code></li>\r\n</ul>\r\n\r\n<h2>Input/Output</h2>\r\n<p><strong>Input:</strong></p>\r\n<ul>\r\n<li><code>t</code>: An integer representing the total minutes the phone needs to be used.</li>\r\n<li><code>capacity</code>: An array of integers representing the capacity of batteries - the number of additional minutes that each battery would allow you to use your phone.</li>\r\n<li><code>recharge</code>: An array of integers representing the time (minutes) required to full recharge each battery so they become usable again.</li>\r\n</ul>\r\n<p><strong>Output:</strong></p>\r\n<ul>\r\n<li>An integer: The number of full batteries used to charge the phone for <code>t</code> consecutive minutes. Return <code>-1</code> if it's impossible to keep the phone working for <code>t</code> minutes.</li>\r\n</ul>\r\n\r\n<h2>C++ Syntax Tips</h2>\r\n<pre><code class='language-cpp'>// Prints help message to the console\r\n// Returns a string\r\nstring helloworld(string name) {\r\n    cout &lt;&lt; \"This prints to the console when you Run Tests\" &lt;&lt; endl;\r\n    return \"Hello, \" + name;\r\n}</code></pre>",
        "google_doc_link": null,
        "solution_code": null,
        "company_name": "Visa_28aug",
        "company_id": 418
    },
    {
        "id": 1240,
        "title": "Array Distribution",
        "problem_statement": "<h1>Array Distribution</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>Given an array of integers <code>numbers</code>, distribute all of its integers between two arrays, <code>first</code> and <code>second</code>, based on the following rules:</p>\r\n<ul>\r\n    <li>The first number, <code>numbers[0]</code>, goes to the <code>first</code> array.</li>\r\n    <li>The second number, <code>numbers[1]</code>, goes to the <code>second</code> array.</li>\r\n    <li>Each following number, <code>numbers[i]</code> where <code>i > 1</code>, goes to the array with the higher number of elements that are strictly greater than <code>numbers[i]</code>. In case of a tie, <code>numbers[i]</code> goes to the array with a lower length. If it is still a tie, <code>numbers[i]</code> goes to the <code>first</code> array.</li>\r\n</ul>\r\n<p>Your task is to return a single array - the combination of <code>first</code> and <code>second</code> by appending all elements of <code>second</code> to the end of <code>first</code>.</p>\r\n<p><strong>Note:</strong> You are not expected to provide the most optimal solution, but a solution with time complexity not worse than <code>O(numbers.length^2)</code> will fit within the execution time limit.</p>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input: numbers = [5, 7, 6, 9, 2]\r\nOutput: [5, 9, 2, 7, 6]</code></pre>\r\n<p><strong>Explanation:</strong></p>\r\n<ul>\r\n    <li><code>numbers[0] = 5</code> goes to the <code>first</code> array and <code>numbers[1] = 7</code> goes to the <code>second</code> array. At this point, <code>first = [5]</code> and <code>second = [7]</code>.</li>\r\n    <li>Considering <code>numbers[2] = 6</code>:\r\n        <ul>\r\n            <li>There are 0 elements in the <code>first</code> array that are greater than <code>numbers[2] = 6</code>.</li>\r\n            <li>There is 1 element in the <code>second</code> array that is greater than <code>numbers[2] = 6</code>.</li>\r\n            <li>As 1 > 0, <code>numbers[2]</code> goes to the <code>second</code> array.</li>\r\n            <li>At this point, <code>first = [5]</code> and <code>second = [7, 6]</code>.</li>\r\n        </ul>\r\n    </li>\r\n    <li>Considering <code>numbers[3] = 9</code>:\r\n        <ul>\r\n            <li>There are 0 elements in the <code>first</code> array that are greater than <code>numbers[3] = 9</code>.</li>\r\n            <li>There are 0 elements in the <code>second</code> array that are greater than <code>numbers[3] = 9</code>.</li>\r\n            <li>As 0 = 0, it is a tie, <code>numbers[3]</code> goes to the array with the lowest length, which is the <code>first</code> array.</li>\r\n            <li>At this point, <code>first = [5, 9]</code> and <code>second = [7, 6]</code>.</li>\r\n        </ul>\r\n    </li>\r\n    <li>Considering <code>numbers[4] = 2</code>:\r\n        <ul>\r\n            <li>There are 2 elements in the <code>first</code> array that are greater than <code>numbers[4] = 2</code>.</li>\r\n            <li>There are 2 elements in the <code>second</code> array that are greater than <code>numbers[4] = 2</code>.</li>\r\n            <li>As 2 = 2, it is a tie, <code>numbers[4]</code> should go to the array with the lowest length. As both arrays have equal length (<code>first.length = second.length = 2</code>), <code>numbers[4]</code> goes to the <code>first</code> array.</li>\r\n            <li>At this point, <code>first = [5, 9, 2]</code> and <code>second = [7, 6]</code>.</li>\r\n        </ul>\r\n    </li>\r\n    <li>Appending <code>second</code> to the end of <code>first</code> results in the following array: <code>[5, 9, 2, 7, 6]</code>.</li>\r\n</ul>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>2 <= numbers.length <= 10^4</code></li>\r\n    <li><code>0 <= numbers[i] <= 10^9</code></li>\r\n</ul>",
        "google_doc_link": null,
        "solution_code": null,
        "company_name": "Visa_28aug",
        "company_id": 418
    },
    {
        "id": 1241,
        "title": "Count Contiguous Sections with K Unique Items",
        "problem_statement": "<h1>Count Contiguous Sections with K Unique Items</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>Imagine you are an inventory manager at a warehouse filled with various items represented by an array <code>inventory</code>. The warehouse employs a logistics system that can identify the uniqueness of items within specified sections of the warehouse. Given these sections represented by contiguous subarrays, your task is to determine how many of these sections contain at least <code>k</code> unique types of items.</p>\r\n<p>You are given the following function signature:</p>\r\n<pre><code class='language-cpp'>int solution(vector&lt;int&gt; inventory, int k) {\r\n    // Function body\r\n}</code></pre>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input: inventory = [1, 2, 1, 1], k = 2\r\nOutput: 2</code></pre>\r\n<p><strong>Explanation:</strong> There are 2 sections that satisfy the condition for having at least <code>k = 2</code> unique types of items:</p>\r\n<ul>\r\n    <li><code>inventory[0..1] = [1, 2]</code></li>\r\n    <li><code>inventory[1..2] = [2, 1]</code></li>\r\n</ul>\r\n<p>Note that the section <code>inventory[0..2] = [1, 2, 1]</code> is not counted because it contains the number 1 twice, and thus doesn't have 2 unique items.</p>\r\n\r\n<h3>Example 2:</h3>\r\n<pre><code class='language-text'>Input: inventory = [1, 2, 3, 4, 1], k = 3\r\nOutput: 6</code></pre>\r\n<p><strong>Explanation:</strong> There are 6 sections that contain at least <code>k = 3</code> unique types of items:</p>\r\n<ul>\r\n    <li><code>inventory[0..2] = [1, 2, 3]</code></li>\r\n    <li><code>inventory[0..3] = [1, 2, 3, 4]</code></li>\r\n    <li><code>inventory[0..4] = [1, 2, 3, 4, 1]</code> - even though there are two 1s, it still contains 3 unique items.</li>\r\n    <li><code>inventory[1..3] = [2, 3, 4]</code></li>\r\n    <li><code>inventory[1..4] = [2, 3, 4, 1]</code></li>\r\n    <li><code>inventory[2..4] = [3, 4, 1]</code></li>\r\n</ul>\r\n\r\n<h3>Example 3:</h3>\r\n<pre><code class='language-text'>Input: inventory = [5, 5, 5, 5], k = 2\r\nOutput: 0</code></pre>\r\n<p><strong>Explanation:</strong> No sections contain at least <code>k = 2</code> unique items.</p>\r\n\r\n<h3>Example 4:</h3>\r\n<pre><code class='language-text'>Input: inventory = [5, 5, 5, 5], k = 1\r\nOutput: 4</code></pre>\r\n<p><strong>Explanation:</strong> There are 4 sections satisfying the condition with at least <code>k = 1</code> unique items:</p>\r\n<ul>\r\n    <li><code>inventory[0..0] = [5]</code></li>\r\n    <li><code>inventory[1..1] = [5]</code></li>\r\n    <li><code>inventory[2..2] = [5]</code></li>\r\n    <li><code>inventory[3..3] = [5]</code></li>\r\n</ul>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li>Execution time limit: 0.5 seconds (cpp)</li>\r\n    <li>Memory limit: 1 GB</li>\r\n    <li><strong>Input:</strong> <code>inventory</code> - An array of integers representing the item types in the warehouse.\r\n        <ul>\r\n            <li><code>3 &le; inventory.length &le; 3000</code></li>\r\n            <li><code>0 &le; inventory[i] &le; 10<sup>4</sup></code></li>\r\n        </ul>\r\n    </li>\r\n    <li><strong>Input:</strong> <code>k</code> - The minimum number of unique item types needed in the section.\r\n        <ul>\r\n            <li><code>1 &le; k &le; 3000</code></li>\r\n        </ul>\r\n    </li>\r\n    <li><strong>Output:</strong> Return the number of contiguous sections each containing at least <code>k</code> unique items.</li>\r\n</ul>",
        "google_doc_link": null,
        "solution_code": null,
        "company_name": "Visa_28aug",
        "company_id": 418
    },
    {
        "id": 1242,
        "title": "Count K-Identical Fruit Sections",
        "problem_statement": "<h1>Count K-Identical Fruit Sections</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>You're an inspector at a large fruit orchard. After harvesting, the fruits are laid out in a long conveyor belt. Your job is to identify sections of the conveyor belt that have a significant number of duplicate fruits. Specifically, you need to count the number of contiguous sections of the belt where you can form at least <code>k</code> pairs of identical fruits based on their position on the belt. Each fruit at a specific position can be part of at most one pair when counting towards the <code>k</code> pairs.</p>\r\n<p>The function signature is:</p>\r\n<pre><code class='language-cpp'>int solution(vector&lt;int&gt; fruits, int k) {\r\n    // Implement your solution here\r\n}</code></pre>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input: fruits = [0, 1, 0, 1, 0], k = 2\r\nOutput: 3</code></pre>\r\n<p><strong>Explanation:</strong> There are 3 contiguous sections where you can find at least <code>k = 2</code> pairs of identical fruits:</p>\r\n<ul>\r\n    <li><code>fruits[0..3] = [0, 1, 0, 1]</code>: One pair of fruit type 0 (at positions 0 and 2) and one pair of fruit type 1 (at positions 1 and 3).</li>\r\n    <li><code>fruits[1..4] = [1, 0, 1, 0]</code>: One pair of fruit type 1 (at positions 1 and 3 within this section) and one pair of fruit type 0 (at positions 2 and 4 within this section).</li>\r\n    <li><code>fruits[0..4] = [0, 1, 0, 1, 0]</code>: We can form one pair of fruit type 0 (e.g., at indices 0 and 2) and one pair of fruit type 1 (at indices 1 and 3). Note that it is not possible to form both a pair with the 0 at index 2 and the 0 at index 4, at the same time, since each fruit can belong to only one pair.</li>\r\n</ul>\r\n\r\n<h3>Example 2:</h3>\r\n<pre><code class='language-text'>Input: fruits = [2, 2, 2, 2, 2], k = 3\r\nOutput: 1</code></pre>\r\n<p><strong>Explanation:</strong> There is only 1 applicable contiguous section <code>fruits[0..5] = [2, 2, 2, 2, 2]</code>, where you can form at least three pairs of fruit type 2 (e.g., the fruit at position 0 with position 1, position 2 with position 3, and position 4 with position 5).</p>\r\n\r\n<h3>Example 3:</h3>\r\n<pre><code class='language-text'>Input: fruits = [1, 3, 3, 1], k = 1\r\nOutput: 4</code></pre>\r\n<p><strong>Explanation:</strong> There are 4 contiguous sections where you can find at least <code>k = 1</code> pair of identical fruits:</p>\r\n<ul>\r\n    <li><code>fruits[0..2] = [1, 3, 3]</code>: (a pair of fruit type 3 at positions 1 and 2)</li>\r\n    <li><code>fruits[0..3] = [1, 3, 3, 1]</code>: (a pair of fruit type 3 at positions 1 and 2)</li>\r\n    <li><code>fruits[1..2] = [3, 3]</code>: (a pair of fruit type 3 at positions 0 and 1 within this section)</li>\r\n    <li><code>fruits[1..3] = [3, 3, 1]</code>: (a pair of fruit type 3 at positions 0 and 1 within this section)</li>\r\n</ul>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>2 &le; fruits.length &le; 2000</code></li>\r\n    <li><code>0 &le; fruits[i] &le; 10<sup>4</sup></code></li>\r\n    <li><code>1 &le; k &le; fruits.length / 2</code></li>\r\n</ul>",
        "google_doc_link": null,
        "solution_code": null,
        "company_name": "Visa_28aug",
        "company_id": 418
    }
]