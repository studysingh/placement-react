[
    {
        "id": 1019,
        "title": "Balanced Sum",
        "problem_statement": "<h1>Balanced Sum</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>Given an array of numbers, find the 0-based index of the smallest array element (the pivot) where the sums of all elements to the left and to the right are equal. The array may not be reordered.</p>\r\n<p>Complete the function <code>balancedSum</code> in the editor with the following parameter(s):</p>\r\n<ul>\r\n    <li><code>int arr[n]</code>: an array of integers</li>\r\n</ul>\r\n<p><strong>Returns</strong></p>\r\n<ul>\r\n    <li><code>int</code>: the 0-based index of the pivot</li>\r\n</ul>\r\n\r\n<h2>Examples</h2>\r\n\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input: arr = [1,2,3,4,6]\r\nOutput: 3</code></pre>\r\n<p><strong>Explanation:</strong> The sum of the first three elements is 1 + 2 + 3 = 6. The value of the last element is 6. Using zero-based indexing, <code>arr[3] = 4</code> is the pivot between these two subarrays. The index of the pivot is 3.</p>\r\n\r\n<h3>Example 2:</h3>\r\n<pre><code class='language-text'>Input: arr = [1,2,3,3]\r\nOutput: 2</code></pre>\r\n<p><strong>Explanation:</strong> The sum of the first two elements, 1+2=3. The value of the last element is 3. Using 0-based indexing, <code>arr[2]=3</code> is the pivot between the two subarrays. The index of the pivot is 2.</p>\r\n\r\n<h3>Example 3:</h3>\r\n<pre><code class='language-text'>Input: arr = [1,2,1]\r\nOutput: 1</code></pre>\r\n<p><strong>Explanation:</strong> The first and last elements are equal to 1. Using 0-based indexing, <code>arr[1]=2</code> is the pivot between the two subarrays. The index of the pivot is 1.</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>3 &lt;= n &lt;= 10^5</code></li>\r\n    <li><code>1 &lt;= arr[i] &lt;= 2 * 10^4</code>, where <code>0 &lt;= i &lt; n</code></li>\r\n    <li>It is guaranteed that a solution always exists.</li>\r\n</ul>\r\n\r\n<p>The function signature provided is:</p>\r\n<pre><code class='language-cpp'>int balancedSum(vector&lt;int&gt; arr) {\r\n    \r\n}</code></pre>",
        "google_doc_link": null,
        "solution_code": null,
        "company_name": "JPMC_20july",
        "company_id": 329
    },
    {
        "id": 1020,
        "title": "Minimum Operations to Balance Consignments",
        "problem_statement": "<h1>Minimum Operations to Balance Consignments</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>A shop has <code>n</code> types of items, where the quantity of the <code>i-th</code> item is denoted by <code>quantity[i]</code>. These items are to be shipped in two consignments:</p>\r\n<ul>\r\n    <li>The first consignment contains items <code>[1, 2, ..., j]</code></li>\r\n    <li>The second consignment contains items <code>[j+1, ..., n]</code></li>\r\n</ul>\r\n<p>The value of <code>j</code> can be chosen such that <code>1 <= j < n</code> (1-based indexing), ensuring both consignments are non-empty and all items of the same type are in the same consignment.</p>\r\n<p>The shopkeeper wants to make the total quantities in both consignments equal. To achieve this, they can increase or decrease the quantity of any item type by 1, any number of times. However, the quantity of each item must remain positive.</p>\r\n<p>Find the minimum number of operations required to make the quantities of both consignments equal if the items are split optimally.</p>\r\n\r\n<h2>Function Description</h2>\r\n<p>Complete the function <code>getMinimumOperations</code> in the editor with the following parameters:</p>\r\n<pre><code class='language-cpp'>long getMinimumOperations(vector&lt;int&gt; quantity)</code></pre>\r\n\r\n<h3>Returns:</h3>\r\n<p><code>long int</code>: the minimum number of operations required to make the sums equal in an optimal division.</p>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input: n = 3, quantity = [1, 4, 4]\r\nOutput: 1</code></pre>\r\n<p><strong>Explanation:</strong> The optimal approach is to increase <code>quantity[3]</code> by 1, resulting in <code>quantity = [1, 4, 5]</code>. Then partition at <code>j = 2</code> to get consignments <code>[1, 4]</code> and <code>[5]</code>. The sum of <code>[1, 4]</code> is 5, and the sum of <code>[5]</code> is 5. Both sums are equal. The answer is 1 operation.</p>\r\n\r\n<h3>Sample Case 0:</h3>\r\n<pre><code class='language-text'>Input: n = 5, quantity = [3, 3, 6, 3, 9]\r\nOutput: 0</code></pre>\r\n<p><strong>Explanation:</strong> The optimal division is <code>[3, 3, 6]</code> and <code>[3, 9]</code>. Both partitions have an equal sum of quantities (12), so no operations are required.</p>\r\n\r\n<h3>Sample Case 1:</h3>\r\n<pre><code class='language-text'>Input: n = 3, quantity = [4, 5, 7]\r\nOutput: 2</code></pre>\r\n<p><strong>Explanation:</strong> It is optimal to do the following operations (1-based indexing):</p>\r\n<ul>\r\n    <li>Reduce <code>quantity[1]</code>, quantity is <code>[3, 5, 7]</code>. (1 operation)</li>\r\n    <li>Increase <code>quantity[3]</code>, quantity is <code>[3, 5, 8]</code>. (1 operation)</li>\r\n</ul>\r\n<p>The consignment can be divided as <code>[3, 5]</code> and <code>[8]</code>. Both sums are 8. Total operations = 1 + 1 = 2.</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>2 <= n <= 3 * 10^5</code></li>\r\n    <li><code>1 <= quantity[i] <= 2 * 10^9</code></li>\r\n</ul>",
        "google_doc_link": null,
        "solution_code": null,
        "company_name": "JPMC_20july",
        "company_id": 329
    }
]