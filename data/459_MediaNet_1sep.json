[
    {
        "id": 1321,
        "title": "Root It",
        "problem_statement": "<h1>Root It</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>You are given a tree with A vertices. At each vertex, some number of candies are placed. Vertex i contains B[i] candies, given in the input.</p>\r\n<p>You are also given a 2-D array C which denotes that there is an undirected edge between C[i][0] and C[i][1].</p>\r\n<p>You have to choose a starting vertex in the beginning or a root, and you are only permitted to move from vertex to vertex only if an edge connects them. You are not allowed to visit any visited vertex again.</p>\r\n<p>For every possible selection of the of the tree, you write the value of <strong>Maximum candies you can obtain - Minimum candies you can obtain</strong> using the same root, in your notebook.</p>\r\n<p><strong>Note:</strong> While traversing the tree, you can stop at any vertex you want. In other words, it is not necessary to start from the root and end in a leaf.</p>\r\n<p>You have to tell the maximum of all the values written in the notebook.</p>\r\n\r\n<h2>Input Format</h2>\r\n<p>The first argument is the integer A.</p>\r\n<p>The second argument is an integer array B.</p>\r\n<p>The third argument is an 2D integer array C.</p>\r\n\r\n<h2>Output Format</h2>\r\n<p>Return the maximum integer written on the notebook.</p>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input:\r\nA = 3\r\nB = [3, 1, 1]\r\nC = [[1, 2], [1, 3]]\r\nOutput: 4</code></pre>\r\n<p><strong>Explanation:</strong> The Maximum sum of candies - Minimum sum of candies for each possible selection of root is given below :\r\nRoot as vertex 1 : Max(sum) - Min(sum) = 4 - 3 = 1\r\nRoot as vertex 2 : Max(sum) - Min(sum) = 5 - 1 = 4\r\nRoot as vertex 3 : Max(sum) - Min(sum) = 5 - 1 = 4\r\nTherefore, the maximum among all these values is 4.</p>\r\n\r\n<h3>Example 2:</h3>\r\n<pre><code class='language-text'>Input:\r\nA = 2\r\nB = [10, 20]\r\nC = [[1, 2]]\r\nOutput: 20</code></pre>\r\n<p><strong>Explanation:</strong> Only optimal way is to choose vertex 1 as a root and travese the edge. So Maximum sum - Minimum Sum = 20.</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n<li><code>1 &lt;= A &lt;= 10^3</code></li>\r\n<li><code>1 &lt;= B[i] &lt;= 10^3</code></li>\r\n<li><code>1 &lt;= C[i][0], C[i][1] &lt;= A</code></li>\r\n</ul>",
        "google_doc_link": null,
        "solution_code": null,
        "company_name": "MediaNet_1sep",
        "company_id": 459
    },
    {
        "id": 1322,
        "title": "Orange Tax",
        "problem_statement": "<h1>Orange Tax</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>You live in Orange town. There are a lot of markets around that are connected with roads. These markets sell oranges at some prices. The town is not very well developed and they still use carts to transport goods from one place to the other. The roads connect two markets together and have one attribute associated with them. The attribute is the price to go from one market to the other in an empty cart. The town also has a tax factor, the tax factor is the number by which the price associated with a road needs to be multiplied, so it can go from one market to the other IF you are carrying oranges in your cart. So if a road's original price was 5 coins and tax factor of the town was 6 then in an empty cart it would take 5 coins to travel the road but if the cart contained oranges, it would cost 5 x 6 = 30 coins.</p>\r\n<p>You wonder what would be the cheapest way to buy oranges if you were initially at each market. You can either buy at the market you're at or travel to some other market, buy oranges there, and travel back to the original market.</p>\r\n<p>You are given an integer A denoting the number of total markets in orange town.<br>An integer array B denoting the price of purchasing oranges at each market.<br>A 2-D array C containing the information about the roads where each row contains three values.<br>The first two values denote the market numbers that are bi-directionally connected via a road and the third value is the price.<br>You are also given an integer D, this is the tax factor for the Orange town.</p>\r\n<p>Find and return the required array where each element is the minimum cost to buy oranges at each market such that the starting and ending point is that market.</p>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input:\r\nA = 4\r\nB = [3, 1, 10, 1]\r\nC = [[2, 1, 2], [3, 1, 2], [4, 1, 4], [3, 2, 1], [4, 2, 2], [4, 3, 1]]\r\nD = 1\r\nOutput: [3, 1, 3, 1]</code></pre>\r\n<p><strong>Explanation:</strong> For 1st, 2nd, and 4th market, there is no better way. For the third market, since 3 and 2 are connected with a road that costs only 1. We can use that road to travel to 2 for cost 1 and buy oranges from market 2 for cost 1, and travel back for cost 1 * 1 for a final cost of 3.</p>\r\n\r\n<h3>Example 2:</h3>\r\n<pre><code class='language-text'>Input:\r\nA = 2\r\nB = [1, 3]\r\nC = [[2, 1, 3]]\r\nD = 1\r\nOutput: [1, 3]</code></pre>\r\n<p><strong>Explanation:</strong> 1 and 3 are already their respective minimum costs.</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>2 <= A <= 10^5</code></li>\r\n    <li><code>B.size() == A</code></li>\r\n    <li><code>1 <= B[i] <= 10^9</code></li>\r\n    <li><code>1 <= C.size() <= 2 * 10^5</code></li>\r\n    <li><code>1 <= C[i][0], C[i][1] <= A</code></li>\r\n    <li><code>1 <= C[i][2] <= 10^3</code></li>\r\n    <li><code>1 <= D <= 5</code></li>\r\n</ul>\r\n\r\n<h2>Input Format</h2>\r\n<p>The first argument is the integer A.<br>The second argument is the integer array B.<br>The third argument is the 2-D integer array C.<br>The fourth argument is the integer D.</p>\r\n\r\n<h2>Output Format</h2>\r\n<p>Return an integer array as per the given problem.</p>\r\n\r\n<pre><code class='language-javascript'>vector<int> Solution::solve(int A, vector<int> &B, vector<vector<int>> &C, int D)</code></pre>",
        "google_doc_link": null,
        "solution_code": null,
        "company_name": "MediaNet_1sep",
        "company_id": 459
    },
    {
        "id": 1325,
        "title": "Non-overlapping Subtrees",
        "problem_statement": "<h1>Non-overlapping Subtrees</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>You are given a rooted tree with N vertices labelled from 1 to N with 1 as a root. Each vertex is assigned an integer value given by an array A.</p>\r\n<p>Subtree sum of any vertex v is summation of all the values of the vertices present in the subtree of v including v itself.</p>\r\n<p>Find two <strong>Non-overlapping subtrees</strong> such that Bitwise xor of their subtree sum is maximum, return this <strong>Maximum xor value</strong>.</p>\r\n<p><strong>NOTE:</strong></p>\r\n<ul>\r\n    <li>Two subtrees are said to non-overlapping if they do not have any vertex in common.</li>\r\n    <li>Return 0 if no such subtrees exists.</li>\r\n</ul>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li>2 &lt;= N &lt;= 50000</li>\r\n    <li>1 &lt;= A[i] &lt;= 1000</li>\r\n    <li>1 &lt;= B[i][0], B[i][1] &lt;= N</li>\r\n</ul>\r\n\r\n<h2>Input Format</h2>\r\n<p>First argument is an integer array A of size N denoting the values assigned to the vertices.</p>\r\n<p>Second argument is an 2D integer matrix B of size (N - 1) x 2 where B[i][0], B[i][1] represents an undirected edge between node B[i][0] and B[i][1].</p>\r\n<p><strong>NOTE:</strong></p>\r\n<ul>\r\n    <li>Array A is given to you as 0-indexed but A[0] represents value of node 1 similarly for each i in [0, N-1] A[i] represents value of (i+1)th node.</li>\r\n</ul>\r\n\r\n<h2>Output Format</h2>\r\n<p>Return an integer as described in the problem above.</p>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input:\r\nA = [1, 5]\r\nB = [ [1, 2] ]\r\nOutput: 0</code></pre>\r\n<p><strong>Explanation:</strong> No two non-overlapping subtree exist so we will return 0.</p>\r\n\r\n<h3>Example 2:</h3>\r\n<pre><code class='language-text'>Input:\r\nA = [8, 4, 3]\r\nB = [ [1, 2], [1, 3] ]\r\nOutput: 7</code></pre>\r\n<p><strong>Explanation:</strong>\r\nSubtree of node 2 and node 3 will be our answer.\r\nSubtreeSum(2) = 4\r\nSubtreeSum(3) = 3\r\nans = SubtreeSum(2) ^ SubtreeSum(3) = 4 ^ 3 = 7</p>",
        "google_doc_link": null,
        "solution_code": null,
        "company_name": "MediaNet_1sep",
        "company_id": 459
    }
]