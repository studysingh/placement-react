[
    {
        "id": 1865,
        "title": "Find Number of Retailers",
        "problem_statement": "<h1>Find Number of Retailers</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>You are given a list of retailers' coordinates and a list of cities' coordinates to which deliveries are requested. For each city in the requests list, you need to determine how many retailers can deliver to that city.</p>\r\n<p>A retailer located at <code>(x_r, y_r)</code> can deliver to a city at <code>(x_c, y_c)</code> if and only if <code>x_r &ge; x_c</code> and <code>y_r &ge; y_c</code>.</p>\r\n<p>For example, if we have 3 retailers at (1, 2), (2, 3), and (1, 5):</p>\r\n<ul>\r\n    <li>For a request to city (1, 7), none of the retailers can deliver. (1,2) cannot (2 &lt; 7), (2,3) cannot (3 &lt; 7), (1,5) cannot (5 &lt; 7).</li>\r\n    <li>For a request to city (1, 4), only the retailer at (1, 5) can deliver (since 1 &ge; 1 and 5 &ge; 4). Retailer (1,2) cannot (2 &lt; 4), Retailer (2,3) cannot (3 &lt; 4).</li>\r\n</ul>\r\n<p>Hence, the answer for this example would be <code>[0, 1]</code>.</p>\r\n<p>Complete the function <code>findNumRetailers</code> in the editor below.</p>\r\n<p>The function has the following parameters:</p>\r\n<ul>\r\n    <li><code>int retailers[n][2]</code>: the retailers' coordinates</li>\r\n    <li><code>int requests[q][2]</code>: the coordinates of cities to deliver to</li>\r\n</ul>\r\n<p><strong>Returns</strong></p>\r\n<p><code>int array[q]</code>: the <code>i</code><sup>th</sup> element is the answer to the <code>i</code><sup>th</sup> query</p>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input:\r\n3\r\n2\r\n1 4\r\n2 4\r\n1 5\r\n2\r\n2\r\n2 6\r\n1 4\r\nOutput:\r\n0\r\n3</code></pre>\r\n<p><strong>Explanation:</strong></p>\r\n<ul>\r\n    <li>For the first request, none of the retailers can deliver to the city at the coordinates (2, 6).</li>\r\n    <li>For the second request, all 3 retailers can deliver to the city at the coordinates (1, 4).</li>\r\n</ul>\r\n\r\n<h3>Example 2:</h3>\r\n<pre><code class='language-text'>Input:\r\n2\r\n2\r\n1 8\r\n2 6\r\n2\r\n2\r\n1 7\r\n1 6\r\nOutput:\r\n1\r\n2</code></pre>\r\n<p><strong>Explanation:</strong></p>\r\n<ul>\r\n    <li>For the first request, only the first retailer can deliver to the city at the coordinates (1, 7).</li>\r\n    <li>For the second request, both the retailers can deliver to the city at the coordinates (1, 6).</li>\r\n</ul>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>1 &le; n, q &le; 7.5 * 10<sup>4</sup></code></li>\r\n    <li><code>1 &le; retailers[i][0] &le; 10<sup>9</sup></code></li>\r\n    <li><code>1 &le; retailers[i][1] &le; 100</code></li>\r\n    <li><code>0 &le; requests[i][0] &le; 10<sup>9</sup></code></li>\r\n    <li><code>0 &le; requests[i][1] &le; 100</code></li>\r\n    <li>No two retailers share the same coordinates.</li>\r\n</ul>\r\n\r\n<pre><code class='language-javascript'>vector<int> findNumRetailers(vector<vector<int>> retailers,\r\n                            vector<vector<int>> requests) {\r\n    // Function implementation\r\n}</code></pre>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <vector>\n#include <string>\n\nclass Solution {\npublic:\n    /**\n     * @param retailers A 2D vector where each inner vector contains the [x, y] coordinates of a retailer.\n     * @param requests A 2D vector where each inner vector contains the [x, y] coordinates of a city request.\n     * @return A vector of integers where the i-th element is the number of retailers that can deliver to the i-th city.\n     */\n    std::vector<int> findNumRetailers(const std::vector<std::vector<int>>& retailers, const std::vector<std::vector<int>>& requests) {\n        // Core logic to be implemented here\n        std::vector<int> result(requests.size(), 0);\n        return result;\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    int n, q;\n    std::cin >> n >> q;\n\n    std::vector<std::vector<int>> retailers(n, std::vector<int>(2));\n    for (int i = 0; i < n; ++i) {\n        std::cin >> retailers[i][0] >> retailers[i][1];\n    }\n\n    std::vector<std::vector<int>> requests(q, std::vector<int>(2));\n    for (int i = 0; i < q; ++i) {\n        std::cin >> requests[i][0] >> requests[i][1];\n    }\n\n    Solution sol;\n    std::vector<int> result = sol.findNumRetailers(retailers, requests);\n\n    for (size_t i = 0; i < result.size(); ++i) {\n        std::cout << result[i] << \"\\n\";\n    }\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "Amazon_16oct",
        "company_id": 657
    },
    {
        "id": 1866,
        "title": "Minimum Adjustments for Optimal Binary Stream",
        "problem_statement": "<h1>Minimum Adjustments for Optimal Binary Stream</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>Amazon cloud architects are executing a performance evaluation on a data stream, and the stream's condition is represented by a binary string.</p>\r\n<p>The data stream is considered optimal if the string does not contain '010' or '101' as subsequences. Note that, in general, subsequences are not the same as substrings. A subsequence is a sequence derived from the original string by deleting zero or more elements without changing the order of the remaining elements. For example, subsequences of '101101' include '0', '1', '11', '0111', and '101', but not '000', '101010', or '11100'.</p>\r\n<p>Your goal is to calculate the minimum number of adjustments required to make the binary string optimal.</p>\r\n<p>An adjustment at a specific position in the sequence is defined as flipping the character at that position. For instance, flipping a '0' changes it to '1', and vice versa.</p>\r\n<p>Complete the function `determineMinimumAdjustments` which takes the following arguments:</p>\r\n<ul>\r\n    <li><strong>`str stream_condition`</strong>: a binary string of '0's and '1's</li>\r\n</ul>\r\n<p>The function is expected to return an <strong>`int`</strong>, representing the minimum number of adjustments required to make the data stream optimal.</p>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input: stream_condition = \"10110\"\r\nOutput: 2</code></pre>\r\n<p><strong>Explanation:</strong> Here, stream_condition = \"10110\". An optimal stream \"11111\" can be achieved by flipping the second ('0' to '1') and fifth ('0' to '1') characters. Therefore, the minimum adjustments required are 2.</p>\r\n\r\n<h3>Example 2:</h3>\r\n<pre><code class='language-text'>Input: stream_condition = \"001100\"\r\nOutput: 2</code></pre>\r\n<p><strong>Explanation:</strong> Here, stream_condition = \"001100\". An optimal stream \"000000\" can be achieved by flipping the third ('1' to '0') and fourth ('1' to '0') characters. This is one of the possible ways to obtain an optimal data stream. Therefore, the minimum adjustments required are 2.</p>\r\n\r\n<h3>Example 3:</h3>\r\n<pre><code class='language-text'>Input: stream_condition = \"11010\"\r\nOutput: 1</code></pre>\r\n<p><strong>Explanation:</strong> Here, stream_condition = \"11010\". An optimal stream \"11000\" can be achieved by flipping the fourth character ('1' to '0'). This is one of the possible ways to obtain an optimal data stream. Therefore, the minimum adjustments required are 1.</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li>`1 <= |stream_condition| <= 2 * 10^5`</li>\r\n</ul>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nclass Solution {\npublic:\n    /**\n     * @brief Calculates the minimum number of adjustments to make the binary stream optimal.\n     * An optimal stream does not contain '010' or '101' as subsequences.\n     * @param stream_condition A binary string.\n     * @return The minimum number of adjustments (flips) required.\n     */\n    int determineMinimumAdjustments(std::string stream_condition) {\n        // Core logic to be implemented here.\n        return 0;\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    // The problem description does not specify multiple test cases,\n    // so we handle a single case.\n    std::string stream_condition;\n    std::cin >> stream_condition;\n\n    Solution sol;\n    int result = sol.determineMinimumAdjustments(stream_condition);\n\n    std::cout << result << std::endl;\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "Amazon_16oct",
        "company_id": 657
    },
    {
        "id": 1867,
        "title": "Get Max Health",
        "problem_statement": "<h1>Get Max Health</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>Amazon manages a fleet of <code>n</code> servers in one of its global data centers. Each server has an initial health score, represented as an integer array <code>health</code>, where <code>health[i]</code> is the health of the <code>i</code>-th server.</p>\r\n<p>To optimize server performance, a transformation process is applied to the servers based on the following sequence:</p>\r\n<ul>\r\n    <li>First, choose an <code>i</code>-th server with health <code>x</code>.</li>\r\n    <li>Then, increase the health of all other servers by 1 unit each.</li>\r\n    <li>In the modified health array, check if any servers have health exactly equal to <code>x + 1</code>.</li>\r\n    <li>If no such servers exist, the process ends.</li>\r\n    <li>However, if there is at least one server with health equal to <code>x + 1</code>, choose any of these servers and repeat the transformation process, starting from the newly chosen server.</li>\r\n</ul>\r\n<p>Given the array <code>health</code>, determine the maximum health achievable by considering all possible permutations of the starting server.</p>\r\n\r\n<h2>Function Description</h2>\r\n<p>Complete the function <code>getmaxHealth</code> in the editor below.</p>\r\n<p><code>getmaxHealth</code> has the following parameter(s):</p>\r\n<ul>\r\n    <li><code>int health[n]</code>: the health of the servers</li>\r\n</ul>\r\n<p><strong>Returns</strong></p>\r\n<ul>\r\n    <li><code>int</code>: the maximum health of the server that can be chosen</li>\r\n</ul>\r\n<pre><code class='language-python'>def getmaxHealth(health):\r\n    # write your code here\r\n</code></pre>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<p>Given <code>n=3</code> servers having initial <code>health = [2, 1, 3]</code>. The problem image illustrates the transformation process for different starting health values, often showing the sorted version <code>[1, 2, 3]</code> for clarity in its simulation.</p>\r\n<pre><code class='language-text'>Input: health = [2, 1, 3]\r\nOutput: 3</code></pre>\r\n<p><strong>Explanation:</strong> Amongst all possible permutations of the starting server, the maximum possible health of a chosen server is 3. Hence, the answer is 3.</p>\r\n\r\n<h3>Example 2:</h3>\r\n<pre><code class='language-text'>Input: n = 4, health = [35, 35, 35, 35]\r\nOutput: 38</code></pre>\r\n<p><strong>Explanation:</strong></p>\r\n<ul>\r\n    <li>The health of all the servers is equal so it does not matter which server is chosen first.</li>\r\n    <li>First, the server with health 35 is chosen, at index 0, then the array is <code>[35, 36, 36, 36]</code>.</li>\r\n    <li>Then the server at index 1 is chosen, and the array is <code>[36, 36, 37, 37]</code>.</li>\r\n    <li>Now the server of health 37 is chosen, and the array is <code>[37, 37, 37, 38]</code>.</li>\r\n    <li>Finally, the server with health 38 is chosen, and the new array is <code>[38, 38, 38, 38]</code>.</li>\r\n    <li>There is no server of health 39.</li>\r\n</ul>\r\n\r\n<h3>Example 3:</h3>\r\n<pre><code class='language-text'>Input: n = 1, health = [2]\r\nOutput: 2</code></pre>\r\n<p><strong>Explanation:</strong> There is only 1 server to select.</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>1 <= n <= 10<sup>5</sup></code></li>\r\n    <li><code>1 <= health[i] <= 10<sup>9</sup></code></li>\r\n</ul>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <numeric>\n#include <unordered_map>\n\nclass Solution {\npublic:\n    int getMaxHealth(std::vector<int>& health) {\n        // Write your code here\n        return 0;\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    int n;\n    std::cin >> n;\n\n    std::vector<int> health(n);\n    for (int i = 0; i < n; ++i) {\n        std::cin >> health[i];\n    }\n\n    Solution sol;\n    int result = sol.getMaxHealth(health);\n\n    std::cout << result << std::endl;\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "Amazon_16oct",
        "company_id": 657
    },
    {
        "id": 1868,
        "title": "Optimal Bandwidth",
        "problem_statement": "<h1>Optimal Bandwidth</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>You are part of Amazon's Network Infrastructure Division and you are working on a project to maximize data transfer efficiency across its network of data centers. You are given n data centers, and the bandwidth capacity of each center is given in an integer array named <code>capacity</code>. There are <code>connectionCount</code> data streams that needs to be routed through two data centers, one as the primary route and the other as the failover. Each data stream must use a unique pair of data centers for its routing.</p>\r\n\r\n<p>The <strong>bandwidthRate</strong> for each data stream is defined as the sum of the capacity of its primary and failover data centers.</p>\r\n\r\n<p>Given an integer array <code>capacity</code> and an integer <code>connectionCount</code>, find the maximum total bandwidthRate that can be obtained by optimally choosing unique pair of routes for each data stream.</p>\r\n\r\n<p><strong>Note:</strong> a pair of data centers (x,y) is said to be unique if no other stream has selected the same pair. However, the pairs (y, x) and (x, y) are treated as different routes. It is also possible to select the same data center for primary and failover routes, which means that (x,x) is a valid pair for the connection.</p>\r\n\r\n<p>For example, if <code>capacity = [5, 3, 6]</code> and <code>connectionCount = 4</code>:</p>\r\n<p>The data streams can select their routes among the following 9 possible data center pairs: [1, 1], [1, 2], [1, 3], [2, 1], [2, 2], [2, 3], [3, 1], [3, 2], [3, 3]. (Assuming 1-based indexing of capacity array). However each data stream must select a unique pair of data centers.</p>\r\n<p>To achieve the maximum total bandwidthRate, the data streams can optimally choose the pairs [3, 3], [3, 1], [1, 3], [1, 1] to obtain the maximum sum of bandwidthRate = (6 + 6) + (6 + 5) + (5 + 6) + (5 + 5) = 44.</p>\r\n\r\n<h3>Function Description</h3>\r\n<p>Complete the function <code>calculateOptimalBandwidth</code> in the editor below.</p>\r\n<p><code>calculateOptimalBandwidth</code> has the following parameters:</p>\r\n<ul>\r\n    <li><code>int capacity[]</code>: an array of bandwidth capacity provided by each data center.</li>\r\n    <li><code>int connectionCount</code>: the number of data streams that needs to be routed.</li>\r\n</ul>\r\n<p><strong>Returns</strong></p>\r\n<ul>\r\n    <li><code>long</code>: the maximum total bandwidthRate from the unique routes of data center pairs.</li>\r\n</ul>\r\n\r\n<h2>Examples</h2>\r\n\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input:\r\ncapacity = [4, 3, 7, 3, 6]\r\nconnectionCount = 6\r\nOutput: 74</code></pre>\r\n<p><strong>Explanation:</strong> The six pairs of data centers with the highest sum of bandwidthRate are: [3, 3], [3, 5], [5, 3], [5, 5], [3, 1], [1, 3]. (Assuming 1-based indexing). The total bandwidthRate will be calculated as: 14 (for [3, 3]) + 13 (for [3, 5]) + 13 (for [5, 3]) + 12 (for [5, 5]) + 11 (for [3, 1]) + 11 (for [1, 3]) = 74. Therefore, the total bandwidthRate = 74. Hence return 74 as answer.</p>\r\n\r\n<h3>Example 2:</h3>\r\n<pre><code class='language-text'>Input:\r\ncapacity = [12, 110, 6, 12]\r\nconnectionCount = 4\r\nOutput: 574</code></pre>\r\n<p><strong>Explanation:</strong> The four pairs of data centers with the highest sum of bandwidthRate are [2, 2], [2, 1], [2, 4], [1, 2]. (Assuming 1-based indexing). The total bandwidthRate is calculated as: 220 (for [2, 2]) + 122 (for [2, 1]) + 122 (for [2, 4]) + 110 (for [1, 2]) = 574. Thus, the total bandwidthRate = 574. Hence return 574 as answer.</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>1 &lt;= n &lt;= 2 * 10^5</code></li>\r\n    <li><code>1 &lt;= capacity[i] &lt;= 2 * 10^5</code></li>\r\n    <li><code>1 &lt;= connectionCount &lt;= min(10^9, n^2)</code></li>\r\n</ul>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <vector>\n#include <string>\n#include <numeric>\n#include <algorithm>\n\nclass Solution {\npublic:\n    long long calculateOptimalBandwidth(std::vector<int>& capacity, int connectionCount) {\n        // Core logic to be implemented here\n        return 0LL;\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    int n;\n    int connectionCount;\n    \n    // Assuming the first line of input contains n and connectionCount\n    std::cin >> n >> connectionCount;\n\n    std::vector<int> capacity(n);\n    for (int i = 0; i < n; ++i) {\n        std::cin >> capacity[i];\n    }\n\n    Solution sol;\n    long long result = sol.calculateOptimalBandwidth(capacity, connectionCount);\n\n    std::cout << result << std::endl;\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "Amazon_16oct",
        "company_id": 657
    },
    {
        "id": 1869,
        "title": "Minimum Shipments",
        "problem_statement": "<h1>Minimum Shipments</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>The logistics coordinator at an Amazon fulfillment center needs to dispatch <code>n</code> items from different warehouses, the warehouse of the <code>i<sup>th</sup></code> item is represented by an array <code>warehouses</code>. The coordinator is allowed to perform one operation at a time. Each operation is defined below:</p>\r\n<ol>\r\n    <li>If the inventory has two or more items, the coordinator can select two items <code>x</code> and <code>y</code> from the inventory if they are stored in different warehouses. i.e. <code>warehouses[x] != warehouses[y]</code> and dispatch both of them.</li>\r\n    <li>If the inventory has one or more items, the coordinator can select one item <code>x</code> from the inventory and dispatch it.</li>\r\n</ol>\r\n<p><strong>Note:</strong> After dispatching an item it gets removed from the inventory, and the rest of the items which are currently not dispatched come together keeping the order the same as before.</p>\r\n<p>Given <code>n</code> items and an array <code>warehouses</code>, find the minimum number of operations that the coordinator has to perform to dispatch all of the items.</p>\r\n\r\n<h2>Examples</h2>\r\n<p>Given <code>n=5</code> and <code>warehouses=[2, 9, 7, 8, 8]</code>.</p>\r\n<p>Here's a possible sequence of operations:</p>\r\n<table>\r\n    <thead>\r\n        <tr>\r\n            <th>Operation</th>\r\n            <th>x</th>\r\n            <th>y</th>\r\n            <th>warehouses</th>\r\n        </tr>\r\n    </thead>\r\n    <tbody>\r\n        <tr>\r\n            <td>1.</td>\r\n            <td>1</td>\r\n            <td>5</td>\r\n            <td>[9, 7, 8]</td>\r\n        </tr>\r\n        <tr>\r\n            <td>2.</td>\r\n            <td>1</td>\r\n            <td>3</td>\r\n            <td>[7]</td>\r\n        </tr>\r\n        <tr>\r\n            <td>3.</td>\r\n            <td>1</td>\r\n            <td></td>\r\n            <td>[]</td>\r\n        </tr>\r\n    </tbody>\r\n</table>\r\n<p>The coordinator needs to perform 3 operations to dispatch all of the items.</p>\r\n\r\n<h3>Example 1: Sample Case 0</h3>\r\n<pre><code class='language-text'>Input: n = 4, warehouses = [1, 3, 1, 2]\r\nOutput: 2</code></pre>\r\n<p><strong>Explanation:</strong></p>\r\n<table>\r\n    <thead>\r\n        <tr>\r\n            <th>Operation</th>\r\n            <th>x</th>\r\n            <th>y</th>\r\n            <th>warehouses</th>\r\n        </tr>\r\n    </thead>\r\n    <tbody>\r\n        <tr>\r\n            <td>1.</td>\r\n            <td>1</td>\r\n            <td>4</td>\r\n            <td>[3, 1]</td>\r\n        </tr>\r\n        <tr>\r\n            <td>2.</td>\r\n            <td>1</td>\r\n            <td>2</td>\r\n            <td>[]</td>\r\n        </tr>\r\n    </tbody>\r\n</table>\r\n<p>Hence, the coordinator needs to perform 2 operations to dispatch all of the items.</p>\r\n\r\n<h3>Example 2: Sample Case 1</h3>\r\n<pre><code class='language-text'>Input: n = 4, warehouses = [9, 5, 9, 9]\r\nOutput: 3</code></pre>\r\n<p><strong>Explanation:</strong></p>\r\n<table>\r\n    <thead>\r\n        <tr>\r\n            <th>Operation</th>\r\n            <th>x</th>\r\n            <th>y</th>\r\n            <th>warehouses</th>\r\n        </tr>\r\n    </thead>\r\n    <tbody>\r\n        <tr>\r\n            <td>1.</td>\r\n            <td>1</td>\r\n            <td>2</td>\r\n            <td>[5, 9, 9]</td>\r\n        </tr>\r\n        <tr>\r\n            <td>2.</td>\r\n            <td>1</td>\r\n            <td>2</td>\r\n            <td>[9, 9]</td>\r\n        </tr>\r\n        <tr>\r\n            <td>3.</td>\r\n            <td>1</td>\r\n            <td></td>\r\n            <td>[]</td>\r\n        </tr>\r\n    </tbody>\r\n</table>\r\n<p>Hence, the coordinator needs to perform 3 operations to dispatch all of the items.</p>\r\n\r\n<h2>Function Description</h2>\r\n<p>Complete the function <code>calculateMinShipments</code> in the editor below.</p>\r\n<p><code>calculateMinShipments</code> has the following parameter(s):</p>\r\n<ul>\r\n    <li><code>int warehouses[n]</code>: the warehouse of each item.</li>\r\n</ul>\r\n<p><strong>Returns</strong></p>\r\n<ul>\r\n    <li><code>int</code>: the minimum number of operations that the coordinator has to perform to dispatch all of the items.</li>\r\n</ul>\r\n<pre><code class='language-javascript'>int calculateMinShipments(vector&lt;int&gt; warehouses) {\r\n    // Function body\r\n}</code></pre>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\r\n    <li><code>1 &lt;= warehouses[i] &lt;= 10<sup>9</sup></code></li>\r\n</ul>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <map>\n\nclass Solution {\npublic:\n    /**\n     * @brief Calculates the minimum number of operations to dispatch all items.\n     * @param warehouses A vector of integers where warehouses[i] is the warehouse of the i-th item.\n     * @return The minimum number of operations required.\n     */\n    int calculateMinShipments(std::vector<int>& warehouses) {\n        // Core logic to be implemented here\n        return 0;\n    }\n};\n\nint main() {\n    // Fast I/O\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    int n;\n    std::cin >> n;\n\n    std::vector<int> warehouses(n);\n    for (int i = 0; i < n; ++i) {\n        std::cin >> warehouses[i];\n    }\n\n    Solution sol;\n    int result = sol.calculateMinShipments(warehouses);\n\n    std::cout << result << std::endl;\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "Amazon_16oct",
        "company_id": 657
    },
    {
        "id": 1870,
        "title": "Determine Max DataFlow",
        "problem_statement": "<h1>Determine Max DataFlow</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>As an engineer in Amazon's Data Infrastructure Team, you are tasked with optimizing how information flows through its network of processing nodes.</p>\r\n<p>You are given n processing nodes, and the bandwidth capability of each node is given in an integer array named <code>bandwidth</code>.</p>\r\n<p>There are <code>streamCount</code> data channels that need to be connected to two processing nodes, one as the main connection and the other as the secondary connection. Each data channel must utilize a unique pair of nodes for its connections.</p>\r\n<p>The <code>dataFlow</code> for each data channel is defined as the sum of the bandwidth of its main and secondary nodes.</p>\r\n<p>Given an integer array <code>bandwidth</code> and an integer <code>streamCount</code>, find the maximum total <code>dataFlow</code> that can be achieved by optimally selecting unique pairs of connections for each data channel.</p>\r\n<p><strong>Note:</strong> A pair of nodes (x,y) is said to be unique if no other channel has selected the same pair. However, the pairs (x,y) and (y,x) are treated as different connections. It is also possible to select the same node for main and secondary connections, which means that (x,x) is a valid pair for the connection.</p>\r\n\r\n<p>Complete the function <code>determineMaxDataFlow</code> in the editor below.</p>\r\n<p>The function is expected to return a <code>LONG_INTEGER</code>.</p>\r\n<p>The function accepts the following parameters:</p>\r\n<ul>\r\n    <li><code>int bandwidth[]</code>: array of bandwidth capability provided by each processing node.</li>\r\n    <li><code>long streamCount</code>: the number of data channels that needs to be connected.</li>\r\n</ul>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input: bandwidth = [5, 4, 8, 4, 7], streamCount = 6\r\nOutput: 86</code></pre>\r\n<p><strong>Explanation:</strong> The six pairs of processing nodes with the highest sum of dataFlow are: [3, 3], [3, 5], [3, 1], [5, 3], [5, 1], [1, 1]. (Assuming 1-based indexing). Thus total dataFlow will be calculated as: 16 (for [3, 3]) + 15 (for [3, 5]) + 13 (for [3, 1]) + 15 (for [5, 3]) + 14 (for [5, 1]) + 13 (for [1, 1]) = 86. Therefore, the total dataFlow = 86. Hence return 86 as answer.</p>\r\n\r\n<h3>Example 2:</h3>\r\n<pre><code class='language-text'>Input: bandwidth = [14, 120, 8, 14], streamCount = 4\r\nOutput: 626</code></pre>\r\n<p><strong>Explanation:</strong> The four pairs of processing nodes with the highest sum of dataFlow are: [2, 2], [2, 1], [2, 4], [1, 2]. (Assuming 1-based indexing). The total dataFlow is calculated as: 240 (for [2, 2]) + 134 (for [2, 1]) + 134 (for [2, 4]) + 118 (for [1, 2]) = 626. Thus, the total dataFlow = 626. Hence return 626 as answer.</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>1 <= n <= 2 * 10^5</code></li>\r\n    <li><code>1 <= bandwidth[i] <= 2 * 10^6</code></li>\r\n    <li><code>1 <= streamCount <= min(10^9, n^2)</code></li>\r\n</ul>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <numeric>\n\nclass Solution {\npublic:\n    long long determineMaxDataFlow(const std::vector<int>& bandwidth, long long streamCount) {\n        // Core logic to be implemented here\n        return 0;\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    int n;\n    std::cin >> n;\n    std::vector<int> bandwidth(n);\n    for (int i = 0; i < n; ++i) {\n        std::cin >> bandwidth[i];\n    }\n\n    long long streamCount;\n    std::cin >> streamCount;\n\n    Solution sol;\n    long long result = sol.determineMaxDataFlow(bandwidth, streamCount);\n\n    std::cout << result << std::endl;\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "Amazon_16oct",
        "company_id": 657
    },
    {
        "id": 1871,
        "title": "Calculate Optimal Bandwidth",
        "problem_statement": "<h1>Calculate Optimal Bandwidth</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>You are part of Amazon's Network Infrastructure Division and you are working on a project to minimize data transfer efficiency across its network of data centers.</p>\r\n<p>You are given <code>n</code> data centers, and the bandwidth capacity of each center is given in an integer array <code>capacity</code>. There are <code>connectionCount</code> data streams that need to be routed through two data centers, one as the primary route and the other as the follower. Each data stream must use a unique pair of data centers for its routing.</p>\r\n<p>The bandwidthRate for each data stream is defined as the sum of the capacity of its primary and follower data centers.</p>\r\n<p>Given an integer array <code>capacity</code> and an integer <code>connectionCount</code>, find the maximum total bandwidthRate that can be obtained by optimally choosing unique pairs of routes for each data stream.</p>\r\n<p><strong>Note:</strong> A pair of data centers (x,y) is said to be unique if no other stream is routed to the same pair. However, the pairs (x, y) and (y, x) are treated as the same pair.</p>\r\n<p>It is also possible to select the same data center for primary and follower routes, which means that (x,x) is a valid pair for the connection.</p>\r\n\r\n<h3>Function Description</h3>\r\n<p>Complete the function <code>calculateOptimalBandwidth</code> in the editor below.</p>\r\n<p><code>calculateOptimalBandwidth</code> has the following parameters:</p>\r\n<ul>\r\n    <li><code>int capacity[n]</code>: array of bandwidth capacity provided by each data center.</li>\r\n    <li><code>long connectionCount</code>: the number of data streams that needs to be routed.</li>\r\n</ul>\r\n<p><strong>Returns</strong></p>\r\n<ul>\r\n    <li><code>long</code>: the maximum total bandwidthRate from the unique routes of data center pairs.</li>\r\n</ul>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input:\r\ncapacity = [4, 3, 7, 3, 6]\r\nconnectionCount = 6\r\nOutput: 74</code></pre>\r\n<p><strong>Explanation:</strong></p>\r\n<p>The six pairs of data centers with the highest sum of bandwidthRate are: [3,3], [3,0], [3,1], [0,0], [1,1], [1,3]. (Assuming 0-based indexing)</p>\r\n<p>Thus total bandwidthRate will be calculated as:</p>\r\n<p><code>capacity[3] + capacity[3]</code> (for [3,3]) = 6 + 6 = 12</p>\r\n<p><code>capacity[3] + capacity[0]</code> (for [3,0]) = 6 + 4 = 10</p>\r\n<p><code>capacity[3] + capacity[1]</code> (for [3,1]) = 6 + 3 = 9</p>\r\n<p><code>capacity[0] + capacity[0]</code> (for [0,0]) = 4 + 4 = 8</p>\r\n<p><code>capacity[1] + capacity[1]</code> (for [1,1]) = 3 + 3 = 6</p>\r\n<p><code>capacity[1] + capacity[3]</code> (for [1,3]) = 3 + 6 = 9</p>\r\n<p>Summing these values: 12 + 10 + 9 + 8 + 6 + 9 = 54.</p>\r\n<p>Wait, the explanation in the image is different: \"14 (for [3,3]) + 13 (for [3,0]) + 13 (for [3,1]) + 12 (for [0,0]) + 11 (for [1,1]) + 11 (for [1,3]) = 74.\"\r\nLet's re-evaluate based on the image's explanation values, as my calculation for the given `capacity` array doesn't match the image's explanation for 74. It seems the `capacity` values used in the explanation are different from the input `[4, 3, 7, 3, 6]` or the indices are interpreted differently. Assuming the explanation's values are correct for the output 74:</p>\r\n<p>The six pairs of data centers with the highest sum of bandwidthRate are: [3,3], [3,0], [3,1], [0,0], [1,1], [1,3]. (Assuming 0-based indexing)</p>\r\n<p>Thus total bandwidthRate will be calculated as:</p>\r\n<p>14 (for [3,3]) + 13 (for [3,0]) + 13 (for [3,1]) + 12 (for [0,0]) + 11 (for [1,1]) + 11 (for [1,3]) = 74.</p>\r\n<p>Therefore, the total bandwidthRate = 74. Hence return 74 as answer.</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>1 <= n <= 2 * 10^5</code></li>\r\n    <li><code>1 <= capacity[i] <= 2 * 10^5</code></li>\r\n    <li><code>1 <= connectionCount <= min(10^9, n^2)</code></li>\r\n</ul>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <numeric>\n\nclass Solution {\npublic:\n    long long calculateOptimalBandwidth(std::vector<int>& capacity, long long connectionCount) {\n        // Placeholder for the solution logic\n        return 0;\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    int n;\n    std::cin >> n;\n\n    std::vector<int> capacity(n);\n    for (int i = 0; i < n; ++i) {\n        std::cin >> capacity[i];\n    }\n\n    long long connectionCount;\n    std::cin >> connectionCount;\n\n    Solution solution;\n    long long result = solution.calculateOptimalBandwidth(capacity, connectionCount);\n\n    std::cout << result << std::endl;\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "Amazon_16oct",
        "company_id": 657
    }
]