[
    {
        "id": 1796,
        "title": "Minimum Reversal",
        "problem_statement": "```html\r\n<h1>Minimum Reversal</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>Optimize a directed graph representing a neural network by selecting a root node that minimizes the number of edge reversals needed. The graph has n nodes numbered from 1 to n and n-1 edges, where the i<sup>th</sup> edge connects node g_from[i] to g_to[i]. Select any node as the root, then reverse as many edges as necessary to make all edges flow away from the root. Find the root node choice that requires the minimum number of edge reversals.</p>\r\n<p>Complete the function <code>getMinInversions</code> in the editor with the following arguments:</p>\r\n<ul>\r\n    <li><code>int a_nodes</code>: the number of nodes in the graph</li>\r\n    <li><code>List&lt;Integer&gt; g_from</code>: a list representing the starting nodes of the directed edges</li>\r\n    <li><code>List&lt;Integer&gt; g_to</code>: a list representing the ending nodes of the directed edges</li>\r\n</ul>\r\n<p><strong>Returns:</strong> <code>int</code>: the minimum number of edges that must be inverted</p>\r\n\r\n<h2>Examples</h2>\r\n\r\n<h3>Example 1:</h3>\r\n<p>Consider a graph with:</p>\r\n<pre><code class='language-text'>g_nodes = 4\r\ng_from = [1, 2, 3]\r\ng_to = [4, 4, 4]</code></pre>\r\n<p><strong>Explanation:</strong> The graph has edges 1->4, 2->4, and 3->4. If node 2 is selected as the root, edges 1->4 and 3->4 need to be reversed to 4->1 and 4->3, respectively, to make all edges flow away from the root. The edge 2->4 already flows away from the root. Thus, 2 edges need to be inverted. The minimum number of edges to be inverted is 2.</p>\r\n\r\n<h3>Example 2: (Sample Case 0)</h3>\r\n<pre><code class='language-text'>Input:\r\ng_nodes = 3, g_edges = 2\r\ng_from = [2, 2], g_to = [1, 3]\r\n\r\nSTDIN:\r\n3 2\r\n2 1\r\n2 3</code></pre>\r\n<pre><code class='language-text'>Output: 0</code></pre>\r\n<p><strong>Explanation:</strong> The optimal strategy is to root the tree at node 2. With node 2 as the root, edges 2->1 and 2->3 already flow away from the root, requiring 0 inversions.</p>\r\n\r\n<h3>Example 3: (Sample Case 1)</h3>\r\n<pre><code class='language-text'>Input:\r\ng_nodes = 4, g_edges = 3\r\ng_from = [1, 1, 4], g_to = [3, 2, 2]\r\n\r\nSTDIN:\r\n4 3\r\n1 3\r\n1 2\r\n4 2</code></pre>\r\n<pre><code class='language-text'>Output: 1</code></pre>\r\n<p><strong>Explanation:</strong> The optimal strategy is to root the tree at node 1. With node 1 as the root, edges 1->3 and 1->2 already flow away. The edge 4->2 needs to be reversed to 2->4, requiring 1 inversion.</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>2 &le; g_nodes &le; 10<sup>5</sup></code></li>\r\n    <li><code>1 &le; g_from[i], g_to[i] &le; g_nodes</code></li>\r\n    <li><code>g_from[i] != g_to[i]</code></li>\r\n</ul>\r\n```",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nclass Solution {\npublic:\n    /**\n     * @brief Finds the minimum number of edge reversals required to make all edges flow away from a chosen root.\n     * @param g_nodes The number of nodes in the graph.\n     * @param g_from A list representing the starting nodes of the directed edges.\n     * @param g_to A list representing the ending nodes of the directed edges.\n     * @return The minimum number of edges that must be inverted.\n     */\n    int getMinInversions(int g_nodes, const std::vector<int>& g_from, const std::vector<int>& g_to) {\n        // Core logic to solve the problem will be implemented here.\n        // This is a placeholder.\n        return 0;\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    int g_nodes;\n    std::cin >> g_nodes;\n\n    // The problem statement implies g_edges = g_nodes - 1,\n    // but the sample input format shows g_edges being read explicitly.\n    // We will follow the sample input format.\n    int g_edges;\n    std::cin >> g_edges;\n\n    std::vector<int> g_from(g_edges);\n    std::vector<int> g_to(g_edges);\n\n    for (int i = 0; i < g_edges; ++i) {\n        std::cin >> g_from[i] >> g_to[i];\n    }\n\n    Solution solution;\n    int result = solution.getMinInversions(g_nodes, g_from, g_to);\n\n    std::cout << result << std::endl;\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "uber_13oct",
        "company_id": 633
    },
    {
        "id": 1797,
        "title": "Load Balancing",
        "problem_statement": "<h1>Load Balancing</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>Develop a prototype for a resource allocation system within a distributed parallel computing framework.</p>\r\n<p>You have <code>n</code> resources and <code>m</code> tasks to schedule, where the <code>i</code><sup>th</sup> task has a processing time of <code>burstTime[i]</code>. The total load time of a resource is the sum of the burst times of the jobs assigned to it. Each resource can only be allocated jobs in a contiguous segment, i.e., from some index <code>x</code> to some index <code>y</code> or <code>[x, x + 1, x + 2, ..., y]</code>.</p>\r\n<p>Determine the minimum possible value of the maximum total load time across all resources.</p>\r\n<p>Complete the function <code>getMinMaxLoadTime</code> in the editor with the following parameter(s):</p>\r\n<ul>\r\n    <li><code>int n</code>: the number of resources.</li>\r\n    <li><code>int burstTime[]</code>: the burst time of jobs.</li>\r\n</ul>\r\n<p><strong>Returns:</strong></p>\r\n<ul>\r\n    <li><code>long int</code>: the minimum max load time of the job schedule.</li>\r\n</ul>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<p><strong>Input:</strong></p>\r\n<pre><code class='language-text'>n = 3\r\nm = 6\r\nburstTime = [4, 3, 2, 2, 2, 6]</code></pre>\r\n<p>An optimal resource allocation is shown:</p>\r\n<pre><code class='language-text'>Server   Jobs      Total Load Time\r\n1        4, 3      4 + 3 = 7\r\n2        2, 2, 2   2 + 2 + 2 = 6\r\n3        6         6</code></pre>\r\n<p><strong>Explanation:</strong> Here, the maximum load on any machine is 7.</p>\r\n\r\n<h3>Sample Input 0:</h3>\r\n<pre><code class='language-text'>n = 2\r\nburstTime[] size m = 5\r\nburstTime = [9, 2, 4, 4, 5]</code></pre>\r\n<p><strong>Output:</strong></p>\r\n<pre><code class='language-text'>13</code></pre>\r\n<p><strong>Explanation:</strong> It is optimal to allocate the first two jobs to the first resource and the remaining three jobs to the other resource. Total load times are 9 + 2 = 11 and 4 + 4 + 5 = 13.</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\r\n    <li><code>1 &lt;= m &lt;= 10<sup>5</sup></code></li>\r\n    <li><code>1 &lt;= burstTime[i] &lt;= 10<sup>9</sup></code></li>\r\n</ul>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <vector>\n#include <string>\n#include <numeric>\n#include <algorithm>\n\nclass Solution {\npublic:\n    long long getMinMaxLoadTime(int n, const std::vector<long long>& burstTime) {\n        // Core logic to solve the problem goes here.\n        // This is a placeholder.\n        return 0;\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    int n;\n    int m;\n    // The problem description is a bit ambiguous about how n and m are provided.\n    // Based on competitive programming standards, we'll assume n and m are read first.\n    // Example 1: n=3, m=6. Sample Input 0: n=2, m=5.\n    // Let's assume the first number is n and the second is m (size of burstTime).\n    std::cin >> n;\n    std::cin >> m;\n\n    std::vector<long long> burstTime(m);\n    for (int i = 0; i < m; ++i) {\n        std::cin >> burstTime[i];\n    }\n\n    Solution sol;\n    long long result = sol.getMinMaxLoadTime(n, burstTime);\n\n    std::cout << result << std::endl;\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "uber_13oct",
        "company_id": 633
    }
]