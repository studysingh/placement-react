[
    {
        "id": 1824,
        "title": "Fraud Detection System",
        "problem_statement": "<h1>Fraud Detection System</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>Stripe processes billions of dollars worth of transactions every day. As guardians of the Internet ecosystem, it is our duty to ensure that legitimate merchants can safely transact with their customers, and that we quickly detect and block illegitimate or fraudulent activity.</p>\r\n<p>To detect fraud, we employ various ML models at scale such as Radar to detect fraudulent transactions as they come in. These models examine a variety of different variables about incoming transactions to determine their authenticity. One input we can look at is the outcome from the credit card networks like Visa/Mastercard. These networks communicate with banks and provide different response codes to reflect the outcomes of credit card transactions. While they act as a safety net, if we have enough data to determine a merchant is fraudulent, we should proactively block them to protect consumers from malicious activities like usage of stolen cards.</p>\r\n<p>Today, we will be building a very simple fraud detection model to determine if a merchant is fraudulent or not.</p>\r\n<p><strong>Note:</strong> though the question is split into parts to guide your implementation, there are testcases for all three parts, so your solution should work for all three parts.</p>\r\n\r\n<h3>Part 1</h3>\r\n<p>Each Stripe merchant has an associated Merchant Consumer Code (MCC) specifying what kind of business the merchant operates. Certain businesses e.g. airlines, event venues are more risky than others, so we have different tolerances of fraud for them. We will start with a very basic algorithm for detecting fraud: if a merchant is ever at or above a certain threshold of the total number of fraudulent transactions (all thresholds are integers &gt; 1), we will mark them as fraudulent. We will additionally only begin marking merchants as fraudulent once we've seen at least some initial number of transactions total for them, to prevent merchants as being marked fraudulent if the first couple transactions we see from them are fraudulent.</p>\r\n<p>There are six string inputs:</p>\r\n<ul>\r\n    <li><strong>Input 1:</strong> a comma-separated list of codes that are not fraudulent</li>\r\n    <li><strong>Input 2:</strong> a comma-separated list of codes that are fraudulent</li>\r\n    <li><strong>Input 3:</strong> A table of MCCs and their corresponding fraud thresholds (each row is separated by a newline and each column is separated by a comma)</li>\r\n    <li><strong>Input 4:</strong> A table of merchants by account ID and their corresponding MCC</li>\r\n    <li><strong>Input 5:</strong> The minimum number of transactions we have to have seen in order to evaluate a merchant as fraudulent</li>\r\n    <li><strong>Input 6:</strong> A table of charges that look like <code>CHARGE,charge_id,account_id,amount,code</code></li>\r\n</ul>\r\n<p>You will return a lexicographically sorted comma-separated list of merchants (by account ID) that are fraudulent.</p>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1 (Part 1):</h3>\r\n<pre><code class='language-text'>Input:\r\n\"approved\",\"invalid_pin\",\"expired_card\"\r\n\"do_not_honor\",\"stolen_card\",\"lost_card\"\r\nretail,5\r\nairline,2\r\nrestaurant,10\r\nvenue,3\r\nacct_1,airline\r\nacct_2,venue\r\nacct_3,retail\r\n0\r\nCHARGE,ch_1,acct_1,100,do_not_honor\r\nCHARGE,ch_2,acct_1,200,approved\r\nCHARGE,ch_3,acct_1,300,do_not_honor\r\nCHARGE,ch_4,acct_2,100,lost_card\r\nCHARGE,ch_5,acct_2,200,lost_card\r\nCHARGE,ch_6,acct_2,300,lost_card\r\nCHARGE,ch_7,acct_3,100,lost_card\r\nCHARGE,ch_8,acct_2,200,stolen_card\r\nCHARGE,ch_9,acct_3,100,approved\r\nOutput:\r\nacct_1,acct_2</code></pre>\r\n<p><strong>Explanation:</strong> In the example above, we see that the initial transaction minimum is 0 transactions, so we can immediately begin evaluating merchants. We see that acct_1 has 2 transactions marked as do_not_honor. It has an MCC code airline, so it has a fraud threshold of 2 fraudulent transactions. So, this merchant is marked as fraudulent by our algorithm. Similarly, acct_2, a venue merchant by MCC code, has 4 fraudulent transactions, which is above the threshold of 3 for this MCC code. On the other hand, acct_3 only has 1 fraudulent transaction, which is below its threshold of 5, so we don't mark it as fraudulent.</p>\r\n\r\n<h2>Follow-up</h2>\r\n<h3>Part 2</h3>\r\n<p>We deployed this model to production, but now we're getting complaints from large users like Ticketmaster and Amazon that have a large number of transactions and are being marked as fraudulent even though most of their transactions are legitimate. Using a numerical threshold is too strict, so we will create a new algorithm that uses the percentage of fraudulent transactions (between 0 and 1, inclusive) as our threshold. If a merchant's fraud percentage is ever at or above this threshold, they will be marked as fraudulent and remain fraudulent even if their percentage drops with more transactions. We will once again have a minimum number of transactions to see before evaluating merchants.</p>\r\n<p>We will have the same 6 inputs, but the threshold (Input 3) will now be a fraction representing the maximum percentage of fraudulent transactions allowed before a merchant is marked as fraudulent. The output will again be a list of merchants that are fraudulent.</p>\r\n\r\n<h3>Example 2 (Part 2):</h3>\r\n<pre><code class='language-text'>Input:\r\n\"approved\",\"invalid_pin\",\"expired_card\"\r\n\"do_not_honor\",\"stolen_card\",\"lost_card\"\r\nretail,0.5\r\nairline,0.25\r\nrestaurant,0.8\r\nvenue,0.25\r\nacct_1,airline\r\nacct_2,venue\r\nacct_3,retail\r\n0\r\nCHARGE,ch_1,acct_1,100,do_not_honor\r\nCHARGE,ch_2,acct_1,200,approved\r\nCHARGE,ch_3,acct_1,300,do_not_honor\r\nCHARGE,ch_4,acct_2,100,lost_card\r\nCHARGE,ch_5,acct_2,200,lost_card\r\nCHARGE,ch_6,acct_2,300,lost_card\r\nCHARGE,ch_7,acct_3,100,lost_card\r\nCHARGE,ch_8,acct_2,200,stolen_card\r\nCHARGE,ch_9,acct_3,100,approved\r\nOutput:\r\nacct_2</code></pre>\r\n<p><strong>Explanation:</strong> With the new thresholds, let's re-evaluate.\r\nFor acct_1 (airline, threshold 0.25):\r\nTotal transactions: 3 (ch_1, ch_2, ch_3)\r\nFraudulent transactions: 2 (ch_1, ch_3)\r\nFraud percentage: 2/3 â‰ˆ 0.667. Since 0.667 > 0.25, acct_1 is marked fraudulent.\r\n\r\nFor acct_2 (venue, threshold 0.25):\r\nTotal transactions: 4 (ch_4, ch_5, ch_6, ch_8)\r\nFraudulent transactions: 4 (ch_4, ch_5, ch_6, ch_8)\r\nFraud percentage: 4/4 = 1.0. Since 1.0 > 0.25, acct_2 is marked fraudulent.\r\n\r\nFor acct_3 (retail, threshold 0.5):\r\nTotal transactions: 2 (ch_7, ch_9)\r\nFraudulent transactions: 1 (ch_7)\r\nFraud percentage: 1/2 = 0.5. Since 0.5 >= 0.5, acct_3 is marked fraudulent.\r\n\r\nThe example output `acct_2` suggests there might be a slight discrepancy or a different interpretation of the \"remain fraudulent\" rule or the specific data points. Assuming the problem implies a cumulative check, the output should be `acct_1,acct_2,acct_3` based on the provided data and rules. However, strictly following the provided example output: `acct_2` is the only one listed. This might imply a more complex \"remain fraudulent\" logic or a specific state at the end of all transactions. For this conversion, we stick to the given output.\r\n</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li>For Part 1, all fraud thresholds (Input 3) are integers greater than 1.</li>\r\n    <li>For Part 2, all fraud thresholds (Input 3) are fractions between 0 and 1, inclusive.</li>\r\n    <li>The output should be a lexicographically sorted comma-separated list of fraudulent merchant account IDs.</li>\r\n    <li>Input 5 specifies the minimum number of transactions required before a merchant can be evaluated for fraud.</li>\r\n</ul>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <string>\n#include <vector>\n#include <sstream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <cctype>\n\nclass Solution {\npublic:\n    std::string detectFraud(\n        const std::string& non_fraudulent_codes_raw,\n        const std::string& fraudulent_codes_raw,\n        const std::vector<std::string>& mcc_thresholds_raw,\n        const std::vector<std::string>& merchant_mccs_raw,\n        int min_transactions,\n        const std::vector<std::string>& charges_raw) {\n        // Your solution logic goes here\n        return \"\";\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    std::string non_fraudulent_codes_raw;\n    std::getline(std::cin, non_fraudulent_codes_raw);\n\n    std::string fraudulent_codes_raw;\n    std::getline(std::cin, fraudulent_codes_raw);\n\n    std::vector<std::string> mcc_thresholds_raw;\n    std::string line;\n    \n    while (std::getline(std::cin, line)) {\n        if (line.empty()) continue;\n        if (line.rfind(\"acct_\", 0) == 0) {\n            break;\n        }\n        mcc_thresholds_raw.push_back(line);\n    }\n\n    std::vector<std::string> merchant_mccs_raw;\n    if (!line.empty()) {\n        merchant_mccs_raw.push_back(line);\n    }\n\n    while (std::getline(std::cin, line)) {\n        if (line.empty()) continue;\n        bool is_num = !line.empty();\n        for(char c : line) {\n            if(!std::isdigit(c)) {\n                is_num = false;\n                break;\n            }\n        }\n        if (is_num) {\n            break;\n        }\n        merchant_mccs_raw.push_back(line);\n    }\n\n    int min_transactions = 0;\n    if (!line.empty()) {\n        min_transactions = std::stoi(line);\n    }\n\n    std::vector<std::string> charges_raw;\n    while (std::getline(std::cin, line)) {\n        if (!line.empty()) {\n            charges_raw.push_back(line);\n        }\n    }\n\n    Solution solution;\n    std::string result = solution.detectFraud(\n        non_fraudulent_codes_raw,\n        fraudulent_codes_raw,\n        mcc_thresholds_raw,\n        merchant_mccs_raw,\n        min_transactions,\n        charges_raw\n    );\n\n    std::cout << result << std::endl;\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "stripe_14oct",
        "company_id": 644
    }
]