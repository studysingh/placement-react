[
    {
        "id": 1166,
        "title": "Login Code Transformation",
        "problem_statement": "<h1>Login Code Transformation</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>In a software company, each employee's login process involves two arrays: <code>initialLogin</code> of size <code>n</code> and <code>standardLogin</code> of size <code>m</code>.</p>\r\n<p>The security software transforms these arrays by repeatedly performing an operation:</p>\r\n<ul>\r\n    <li>Select any subsegment of either array and replace it with the sum of its elements.</li>\r\n</ul>\r\n<p>For example, the array <code>[1, 5, 6, 8, 2]</code> can be transformed into <code>[12, 8, 2]</code> by replacing the subsegment <code>[1, 5, 6]</code> with <code>[12]</code>.</p>\r\n<p>The goal is to maximize the length of equal arrays after performing the operations any number of times on both <code>initialLogin</code> and <code>standardLogin</code>. The login code is the maximum possible length of these equal arrays. If the arrays cannot be made equal through the operations, the <code>initialLogin</code> is considered invalid, and the result should be <code>-1</code>.</p>\r\n<p>Determine the login code based on the provided <code>initialLogin</code> and <code>standardLogin</code>, or return <code>-1</code> if <code>initialLogin</code> is invalid.</p>\r\n\r\n<h3>Function Description</h3>\r\n<p>Complete the function <code>getLoginCodes</code> in the editor with the following parameters:</p>\r\n<ul>\r\n    <li><code>initialLogin</code>: The initial array</li>\r\n    <li><code>standardLogin</code>: The standard array used by the security software</li>\r\n</ul>\r\n<p><strong>Returns:</strong></p>\r\n<ul>\r\n    <li><code>int</code>: The login code</li>\r\n</ul>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input:\r\nn = 5\r\ninitialLogin = [2, 4, 3, 7, 10]\r\nm = 4\r\nstandardLogin = [6, 5, 5, 10]\r\nOutput: 3</code></pre>\r\n<p><strong>Explanation:</strong> An optimal sequence of operations to achieve a maximum common length of 3 is as follows:</p>\r\n<ol>\r\n    <li><strong>Operation 1:</strong> Replace the subsegment <code>[3, 7]</code> (sum is 10) with <code>[10]</code> in <code>initialLogin</code>.\r\n        <ul>\r\n            <li><code>initialLogin</code> becomes <code>[2, 4, 10, 10]</code></li>\r\n            <li><code>standardLogin</code> remains <code>[6, 5, 5, 10]</code></li>\r\n        </ul>\r\n    </li>\r\n    <li><strong>Operation 2:</strong> Replace the subsegment <code>[5, 5]</code> (sum is 10) with <code>[10]</code> in <code>standardLogin</code>.\r\n        <ul>\r\n            <li><code>initialLogin</code> remains <code>[2, 4, 10, 10]</code></li>\r\n            <li><code>standardLogin</code> becomes <code>[6, 10, 10]</code></li>\r\n        </ul>\r\n    </li>\r\n    <li><strong>Operation 3:</strong> Replace the subsegment <code>[2, 4]</code> (sum is 6) with <code>[6]</code> in <code>initialLogin</code>.\r\n        <ul>\r\n            <li><code>initialLogin</code> becomes <code>[6, 10, 10]</code></li>\r\n            <li><code>standardLogin</code> remains <code>[6, 10, 10]</code></li>\r\n        </ul>\r\n    </li>\r\n</ol>\r\n<p>After these operations, both arrays are <code>[6, 10, 10]</code>, which has a length of 3. This is the maximum possible length.</p>\r\n\r\n<h3>Example 2 (Sample Case 0):</h3>\r\n<pre><code class='language-text'>Input:\r\ninitialLogin = [1, 3, 4, 7, 2]\r\nstandardLogin = [1, 3, 4, 7, 2]\r\nOutput: 5</code></pre>\r\n<p><strong>Explanation:</strong> The arrays are already equal, so no operations need to be performed. Their length is 5.</p>\r\n\r\n<h3>Example 3 (Sample Case 1):</h3>\r\n<pre><code class='language-text'>Input:\r\ninitialLogin = [3, 4, 1]\r\nstandardLogin = [3, 4, 1, 7, 6]\r\nOutput: -1</code></pre>\r\n<p><strong>Explanation:</strong> It is not possible to make the arrays equal through the allowed operations.</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>1 &lt;= n, m &lt;= 2 * 10^5</code></li>\r\n    <li><code>1 &lt;= initialLogin[i], standardLogin[i] &lt;= 10^9</code></li>\r\n</ul>",
        "google_doc_link": null,
        "solution_code": null,
        "company_name": "Lumber_4aug",
        "company_id": 392
    },
    {
        "id": 1167,
        "title": "Total Valid Prefixes",
        "problem_statement": "<h1>Total Valid Prefixes</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>Given a binary sequence of length n as a string, perform the following operation any number of times: Append either a '0' or a '1' to the end of the sequence.</p>\r\n<p>A sequence is considered valid if it is possible to make the total number of '10' subsequences in the updated sequence exactly equal to k.</p>\r\n<p>Your task is to count the total number of valid non-empty prefix sequences of the given binary sequence.</p>\r\n<p><strong>Notes:</strong></p>\r\n<ol>\r\n    <li>A sequence is a subsequence if it can be obtained by deleting digits (possibly none) without altering the relative positions.</li>\r\n    <li>A non-empty prefix sequence is any sequence derived by deleting digits from the end of the given sequence, ensuring the length of the prefix is at least 1.</li>\r\n</ol>\r\n\r\n<h2>Function Description</h2>\r\n<p>Complete the function <code>calculateTotalPrefix</code> in the editor with the following parameters:</p>\r\n<ul>\r\n    <li><code>string sequence</code>: the binary sequence</li>\r\n    <li><code>int k</code>: the number of \"10\" subsequences desired</li>\r\n</ul>\r\n<p><strong>Returns:</strong></p>\r\n<ul>\r\n    <li><code>int</code>: the total number of non-empty prefix sequences of the given binary sequence</li>\r\n</ul>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>1 <= n <= 2 * 10^5</code></li>\r\n    <li><code>0 <= k <= 10^9</code></li>\r\n    <li>The sequence consists only of digits 0 and 1.</li>\r\n</ul>\r\n\r\n<h2>Examples</h2>\r\n\r\n<h3>Sample Case 0:</h3>\r\n<pre><code class='language-text'>Input: sequence = \"101\", k = 2\r\nOutput: 2</code></pre>\r\n<p><strong>Explanation:</strong></p>\r\n<pre><code class='language-text'>Analyze all non-empty prefix sequences\r\nPrefix Sequence | Appended String | Sequence Formed After Append | Is Good?\r\n----------------|-----------------|------------------------------|----------\r\n\"1\"             | \"00\"            | \"100\"                        | Good (k=2 is satisfied)\r\n\"10\"            | \"0\"             | \"100\"                        | Good (k=2 is satisfied)\r\n\"101\"           | --              | --                           | No (Not possible to make it good)</code></pre>\r\n<p>For \"101\", there is initially 1 good sequence at indices (0, 1). If a \"0\" is appended, there are three good sequences with indices (0, 1), (0, 3), and (1, 3).</p>\r\n\r\n<h3>Sample Case 1:</h3>\r\n<pre><code class='language-text'>Input: sequence = \"11\", k = 1\r\nOutput: 1</code></pre>\r\n<p><strong>Explanation:</strong></p>\r\n<pre><code class='language-text'>Analyze all non-empty prefix sequences\r\nPrefix Sequence | Appended String | Sequence Formed After Append | Is Good?\r\n----------------|-----------------|------------------------------|----------\r\n\"1\"             | \"0\"             | \"10\"                         | Good (k=1)\r\n\"11\"            | --              | --                           | No (Not possible to convert)</code></pre>\r\n\r\n<h3>Sample Case 2:</h3>\r\n<pre><code class='language-text'>Input: sequence = \"100\", k = 1\r\nOutput: 2</code></pre>\r\n<p><strong>Explanation:</strong></p>\r\n<pre><code class='language-text'>Analyze all non-empty prefix sequences\r\nPrefix Sequence | Appended String | Sequence Formed After Append | Is Good?\r\n----------------|-----------------|------------------------------|----------\r\n\"1\"             | \"0\"             | \"10\"                         | Good (There are k '10' sequences)\r\n\"10\"            | Blank           | \"10\"                         | Good (There are k '10' sequences)\r\n\"100\"           | --              | --                           | Not Good (Not possible)</code></pre>\r\n<p>For \"100\", there are already 2 subsequences of \"10\": indices (0, 1) and indices (0, 2). Hence, the number of non-empty prefix sequences of the given binary sequence is 2.</p>",
        "google_doc_link": null,
        "solution_code": null,
        "company_name": "Lumber_4aug",
        "company_id": 392
    },
    {
        "id": 1168,
        "title": "Shortest Substring to Make Distinct Characters",
        "problem_statement": "<h1>Shortest Substring to Make Distinct Characters</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>Determine the length of the shortest substring to delete from a string <code>s</code> of length <code>n</code>, so that the resulting string contains only distinct characters.</p>\r\n<p>A substring is a sequence of characters that appear consecutively within a string. If a substring is deleted, the remaining parts of the string are joined together. If no deletion is necessary, the answer should be 0.</p>\r\n<p>You need to implement the function <code>findShortestSubstring</code> with the following parameter:</p>\r\n<ul>\r\n    <li><code>s</code>: The string to analyze.</li>\r\n</ul>\r\n<p><strong>Returns:</strong></p>\r\n<p>An integer representing the length of the shortest substring that should be deleted.</p>\r\n\r\n<h2>Examples</h2>\r\n\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input: s = \"abcbbck\"\r\nOutput: 3</code></pre>\r\n<p><strong>Explanation:</strong> To obtain a string with only distinct characters, one optimal choice is to remove the substring \"bbc\" from \"abcbbck\". This results in \"abck\", which contains only distinct characters ('a', 'b', 'c', 'k'). The length of the removed substring \"bbc\" is 3.</p>\r\n\r\n<h3>Example 2:</h3>\r\n<pre><code class='language-text'>Input: s = \"xabbcacpqr\"\r\nOutput: 3</code></pre>\r\n<p><strong>Explanation:</strong> Given string <code>s = \"xabbcacpqr\"</code>, remove the substring \"bca\" (from index 2 to 4) to get \"xabcpqr\". The resulting string \"xabcpqr\" contains only distinct characters. The length of the removed substring \"bca\" is 3.</p>\r\n\r\n<h3>Example 3:</h3>\r\n<pre><code class='language-text'>Input: s = \"abc\"\r\nOutput: 0</code></pre>\r\n<p><strong>Explanation:</strong> The string <code>s = \"abc\"</code> already contains distinct characters only. Therefore, no deletion is necessary, and the length of the shortest substring to delete is 0.</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>1 &le; n &le; 10<sup>5</sup></code></li>\r\n    <li><code>s</code> consists of lowercase English letters only.</li>\r\n</ul>",
        "google_doc_link": null,
        "solution_code": null,
        "company_name": "Lumber_4aug",
        "company_id": 392
    }
]