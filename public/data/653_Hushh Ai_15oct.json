[
    {
        "id": 1851,
        "title": "Ki",
        "problem_statement": "<h1>Ki</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>Given is a rooted tree with <code>N</code> vertices numbered 1 to <code>N</code>. The root is Vertex 1, and the <code>i</code>-th edge (<code>1 ≤ i ≤ N - 1</code>) connects Vertex <code>a_i</code> and <code>b_i</code>.</p>\r\n<p>Each of the vertices has a counter installed. Initially, the counters on all the vertices have the value 0.</p>\r\n<p>Now, the following <code>Q</code> operations will be performed:</p>\r\n<ul>\r\n    <li>Operation <code>j</code> (<code>1 ≤ j ≤ Q</code>): Increment by <code>x_j</code> the counter on every vertex contained in the subtree rooted at Vertex <code>p_j</code>.</li>\r\n</ul>\r\n<p>Find the value of the counter on each vertex after all operations.</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>2 ≤ N ≤ 2 × 10^5</code></li>\r\n    <li><code>1 ≤ Q ≤ 2 × 10^5</code></li>\r\n    <li><code>1 ≤ a_i < b_i ≤ N</code></li>\r\n    <li><code>1 ≤ p_j ≤ N</code></li>\r\n    <li><code>1 ≤ x_j ≤ 10^4</code></li>\r\n    <li>The given graph is a tree.</li>\r\n    <li>All values in input are integers.</li>\r\n</ul>\r\n\r\n<h2>Input</h2>\r\n<p>Input is given from Standard Input in the following format:</p>\r\n<pre><code class='language-text'>N Q\r\na_1 b_1\r\n:\r\na_{N-1} b_{N-1}\r\np_1 x_1\r\n:\r\np_Q x_Q</code></pre>\r\n\r\n<h2>Output</h2>\r\n<p>Print the values of the counters on Vertex 1, 2, ..., <code>N</code> after all operations, in this order, with spaces in between.</p>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input:\r\n4 3\r\n1 2\r\n2 3\r\n2 4\r\n2 10\r\n1 100\r\n3 1\r\nOutput:\r\n100 110 111 110</code></pre>\r\n<p><strong>Explanation:</strong> The tree in this input has Vertex 1 as root, with children 2. Vertex 2 has children 3 and 4. Initially, all counters are 0.</p>\r\n<p>Each operation changes the values of the counters on the vertices as follows:</p>\r\n<ul>\r\n    <li><strong>Operation 1:</strong> Increment by 10 the counter on every vertex contained in the subtree rooted at Vertex 2, that is, Vertex 2, 3, 4. The values of the counters on Vertex 1, 2, 3, 4 are now 0, 10, 10, 10, respectively.</li>\r\n    <li><strong>Operation 2:</strong> Increment by 100 the counter on every vertex contained in the subtree rooted at Vertex 1, that is, Vertex 1, 2, 3, 4. The values of the counters on Vertex 1, 2, 3, 4 are now 100, 110, 110, 110, respectively.</li>\r\n    <li><strong>Operation 3:</strong> Increment by 1 the counter on every vertex contained in the subtree rooted at Vertex 3, that is, Vertex 3. The values of the counters on Vertex 1, 2, 3, 4 are now 100, 110, 111, 110, respectively.</li>\r\n</ul>\r\n\r\n<h3>Example 2:</h3>\r\n<pre><code class='language-text'>Input:\r\n6 2\r\n1 2\r\n1 3\r\n2 4\r\n3 6\r\n2 5\r\n1 10\r\n1 10\r\nOutput:\r\n20 20 20 20 20 20</code></pre>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <utility>\n\nvoid setup() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n}\n\nclass Solution {\npublic:\n    std::vector<long long> solve(int N, int Q, const std::vector<std::vector<int>>& adj, const std::vector<std::pair<int, int>>& queries) {\n        // Core logic goes here\n        std::vector<long long> placeholder_result(N + 1, 0);\n        return placeholder_result;\n    }\n};\n\nint main() {\n    setup();\n    int N, Q;\n    std::cin >> N >> Q;\n\n    std::vector<std::vector<int>> adj(N + 1);\n    for (int i = 0; i < N - 1; ++i) {\n        int a, b;\n        std::cin >> a >> b;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    std::vector<std::pair<int, int>> queries(Q);\n    for (int i = 0; i < Q; ++i) {\n        int p, x;\n        std::cin >> p >> x;\n        queries[i] = {p, x};\n    }\n\n    Solution solution;\n    std::vector<long long> result = solution.solve(N, Q, adj, queries);\n\n    for (int i = 1; i <= N; ++i) {\n        std::cout << result[i] << (i == N ? \"\" : \" \");\n    }\n    std::cout << std::endl;\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "Hushh Ai_15oct",
        "company_id": 653
    },
    {
        "id": 1852,
        "title": "Coins Respawn",
        "problem_statement": "<h1>Coins Respawn</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>There is a directed graph with N vertices numbered 1 to N and M edges. The i-th edge is directed from Vertex A<sub>i</sub> to Vertex B<sub>i</sub>, and there are C<sub>i</sub> coins placed along that edge. Additionally, there is a button on Vertex N.</p>\r\n<p>We will play a game on this graph. You start the game on Vertex 1 with zero coins, and head for Vertex N by traversing the edges while collecting coins. It takes one minute to traverse an edge, and you can collect the coins placed along the edge each time you traverse it. As usual in games, even if you traverse an edge once and collect the coins, the same number of coins will reappear next time you traverse that edge, which you can collect again.</p>\r\n<p>When you reach Vertex N, you can end the game by pressing the button. (You can also choose to leave Vertex N without pressing the button and continue traveling.) However, when you end the game, you will be asked to pay T &times; P coins, where T is the number of minutes elapsed since the start of the game. If you have less than T &times; P coins, you will have to pay all of your coins instead.</p>\r\n<p>Your score will be the number of coins you have after this payment. Determine if there exists a maximum value of the score that can be obtained. If the answer is yes, find that maximum value.</p>\r\n\r\n<h2>Input</h2>\r\n<p>Input is given from Standard Input in the following format:</p>\r\n<pre><code class='language-text'>N M P\r\nA_1 B_1 C_1\r\n...\r\nA_M B_M C_M</code></pre>\r\n\r\n<h2>Output</h2>\r\n<p>If there exists a maximum value of the score that can be obtained, print that maximum value; otherwise, print -1.</p>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input:\r\n3 3 10\r\n1 2 20\r\n2 3 30\r\n1 3 45\r\nOutput:\r\n35</code></pre>\r\n<p><strong>Explanation:</strong> There are two ways to travel from Vertex 1 to Vertex 3:</p>\r\n<ul>\r\n<li>Vertex 1 &rarr; 2 &rarr; 3: You collect 20 + 30 = 50 coins on the way. After two minutes from the start of the game, you press the button, pay 2 &times; 10 = 20 coins, and you have 50 - 20 = 30 coins left.</li>\r\n<li>Vertex 1 &rarr; 3: You collect 45 coins on the way. After one minute from the start of the game, you press the button, pay 1 &times; 10 = 10 coins, and you have 45 - 10 = 35 coins left.</li>\r\n</ul>\r\n<p>Thus, the maximum score that can be obtained is 35.</p>\r\n\r\n<h3>Example 2:</h3>\r\n<pre><code class='language-text'>Input:\r\n2 2 10\r\n1 2 100\r\n2 2 100\r\nOutput:\r\n-1</code></pre>\r\n<p><strong>Explanation:</strong> The edge extending from Vertex 1 takes you to Vertex 2. If you then traverse the edge extending from Vertex 2 to itself t times and press the button, your score will be 90 + 90t. Thus, you can infinitely increase your score, which means there is no maximum value of the score that can be obtained.</p>\r\n\r\n<h3>Example 3:</h3>\r\n<pre><code class='language-text'>Input:\r\n4 5 10\r\n1 2 1\r\n3 4 1\r\n1 3 1\r\n2 2 100\r\n3 3 100\r\nOutput:\r\n0</code></pre>\r\n<p><strong>Explanation:</strong> There is no way to travel from Vertex 1 to Vertex 4 other than traversing the edge leading from Vertex 1 to Vertex 4 directly. You will pick up one coin along this edge, but after being asked to paying 10 coins, your score will be 0.</p>\r\n<p>Note that you can collect an infinite number of coins if you traverse the edge leading from Vertex 1 to Vertex 2, but this is pointless since you can no longer reach Vertex 4 and end.</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n<li>2 &le; N &le; 2500</li>\r\n<li>1 &le; M &le; 5000</li>\r\n<li>1 &le; A<sub>i</sub>, B<sub>i</sub> &le; N</li>\r\n<li>1 &le; C<sub>i</sub> &le; 10<sup>5</sup></li>\r\n<li>0 &le; P &le; 10<sup>5</sup></li>\r\n<li>All values in input are integers.</li>\r\n<li>Vertex N can be reached from Vertex 1.</li>\r\n</ul>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <vector>\n#include <tuple>\n\nstruct Edge {\n    int from;\n    int to;\n    int cost;\n};\n\nclass Solution {\npublic:\n    long long solve(int N, int M, int P, const std::vector<Edge>& edges) {\n        // Core logic to solve the problem will be implemented here.\n        // This is a placeholder.\n        return 0;\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    int N, M, P;\n    std::cin >> N >> M >> P;\n\n    std::vector<Edge> edges;\n    for (int i = 0; i < M; ++i) {\n        int u, v, c;\n        std::cin >> u >> v >> c;\n        edges.push_back({u, v, c});\n    }\n\n    Solution solution;\n    long long result = solution.solve(N, M, P, edges);\n\n    std::cout << result << std::endl;\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "Hushh Ai_15oct",
        "company_id": 653
    }
]