[
    {
        "id": 1691,
        "title": "Maximize Equalized Substrings After One Swap",
        "problem_statement": "<h1>Maximize Equalized Substrings After One Swap</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>You are given an equalized string, where the number of 'L' characters is the same as the number of 'R' characters. Determine the maximum number of equalized substrings into which the string can be divided, after performing at most one swap of two adjacent characters.</p>\r\n<p><strong>Note:</strong> An equalized substring is any contiguous part of the string in which the total number of 'L' characters equals the total number of 'R' characters.</p>\r\n<p>Return an integer representing this maximum count.</p>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input: s = \"RLRLLRLRL\"\r\nOutput: 5</code></pre>\r\n<p><strong>Explanation:</strong> Swapping the characters at indices 3 and 4 (0-based) changes the string to \"RLRLRLRLRL\". This updated string can be divided into: \"RL\", \"RL\", \"RL\", \"RL\", and \"RL\", each of which is an equalized substring. Hence, the answer is 5.</p>\r\n\r\n<h3>Example 2:</h3>\r\n<pre><code class='language-text'>Input: s = \"LLLLRRRR\"\r\nOutput: 1</code></pre>\r\n<p><strong>Explanation:</strong> No single swap can increase the count of equalized substrings, so the entire string forms just one equalized substring. Therefore, the answer is 1.</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>2 &le; |s| &le; 2 * 10<sup>5</sup></code></li>\r\n    <li><code>s</code> contains only 'L' and 'R', with an equal number of 'L' and 'R'.</li>\r\n</ul>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nclass Solution {\npublic:\n    int solve(const std::string& s) {\n        // Core logic to find the maximum number of equalized substrings\n        // after at most one adjacent swap.\n        return 0; // Placeholder\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    std::string s;\n    std::cin >> s;\n\n    Solution solution;\n    int result = solution.solve(s);\n\n    std::cout << result << std::endl;\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "Factset_9oct",
        "company_id": 591
    },
    {
        "id": 1692,
        "title": "Generating Login Codes",
        "problem_statement": "<h1>Generating Login Codes</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>In a software company, each employee's login process involves two arrays: <code>initialLogin</code> of size <code>n</code> and <code>standardLogin</code> of size <code>m</code>.</p>\r\n<p>The security software transforms these arrays by repeatedly performing an operation:</p>\r\n<ul>\r\n    <li>Select any subsegment of either array and replace it with the sum of its elements.</li>\r\n</ul>\r\n<p>For example, the array <code>[1, 5, 6, 8, 2]</code> can be transformed into <code>[12, 8, 2]</code> by replacing the subsegment <code>[1, 5, 6]</code> with <code>[12]</code>.</p>\r\n<p>The goal is to maximize the length of equal arrays after performing the operations any number of times on both <code>initialLogin</code> and <code>standardLogin</code>. The login code is the maximum possible length of these equal arrays. If the arrays cannot be made equal through the operations, the <code>initialLogin</code> is considered invalid, and the result should be <code>-1</code>.</p>\r\n<p>Determine the login code based on the provided <code>initialLogin</code> and <code>standardLogin</code>, or return <code>-1</code> if <code>initialLogin</code> is invalid.</p>\r\n\r\n<h2>Function Description</h2>\r\n<p>Complete the function <code>getLoginCodes</code> in the editor with the following parameters:</p>\r\n<ul>\r\n    <li><code>initialLogin[n]</code>: the initial array</li>\r\n    <li><code>standardLogin[m]</code>: the standard array used by the security software</li>\r\n</ul>\r\n\r\n<h3>Returns</h3>\r\n<p><code>int</code>: the login code</p>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<p><strong>Input:</strong></p>\r\n<pre><code class='language-text'>n = 5\r\ninitialLogin = [2, 4, 3, 7, 10]\r\nm = 4\r\nstandardLogin = [6, 5, 5, 10]</code></pre>\r\n<p>An optimal sequence of operations:</p>\r\n<pre><code class='language-text'>Operation Number | Operation                                | initialLogin After Operation | standardLogin After Operation\r\n-----------------|------------------------------------------|------------------------------|------------------------------\r\n1                | Replace the subsegment [3, 7] with [10]  | [2, 4, 10, 10]               | [6, 5, 5, 10]\r\n                 | in initialLogin                          |                              |\r\n2                | Replace the subsegment [5, 5] with [10]  | [2, 4, 10, 10]               | [6, 10, 10]\r\n                 | in standardLogin                         |                              |\r\n3                | Replace the subsegment [2, 4] with [6]   | [6, 10, 10]                  | [6, 10, 10]\r\n                 | in initialLogin                          |                              |</code></pre>\r\n<p><strong>Output:</strong> 3</p>\r\n<p><strong>Explanation:</strong> Return the maximum possible length, 3.</p>\r\n\r\n<h3>Sample Case 0:</h3>\r\n<pre><code class='language-text'>Input:\r\n5\r\n1\r\n3\r\n4\r\n7\r\n2\r\n5\r\n1\r\n3\r\n4\r\n7\r\n2\r\nOutput:\r\n5</code></pre>\r\n<p><strong>Explanation:</strong> The arrays are already equal, so no operations need to be performed. Their length is 5.</p>\r\n\r\n<h3>Sample Case 1:</h3>\r\n<pre><code class='language-text'>Input:\r\n3\r\n3\r\n4\r\n1\r\n5\r\n3\r\n4\r\n1\r\n7\r\n6\r\nOutput:\r\n-1</code></pre>\r\n<p><strong>Explanation:</strong> No order of operations can make both arrays equal, so <code>initialLogin</code> is invalid.</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>1 &lt;= n, m &lt;= 2 * 10^5</code></li>\r\n    <li><code>1 &lt;= initialLogin[i], standardLogin[i] &lt;= 10^9</code></li>\r\n</ul>\r\n\r\n<h2>Input Format for Custom Testing</h2>\r\n<p>The first line contains an integer, <code>n</code>, the size of <code>initialLogin</code>.</p>\r\n<p>The next <code>n</code> lines contain an integer, <code>initialLogin[i]</code>.</p>\r\n<p>The following line contains the integer <code>m</code>, the size of <code>standardLogin</code>.</p>\r\n<p>The next <code>m</code> lines contain an integer, <code>standardLogin[i]</code>.</p>\r\n\r\n<pre><code class='language-javascript'>#include &lt;bits/stdc++.h&gt;\r\n\r\n/*\r\n * Complete the 'getLoginCodes' function below.\r\n *\r\n * The function is expected to return an INTEGER.\r\n * The function accepts following parameters:\r\n *  1. INTEGER_ARRAY initialLogin\r\n *  2. INTEGER_ARRAY standardLogin\r\n */\r\n\r\nint getLoginCodes(std::vector&lt;int&gt; initialLogin, std::vector&lt;int&gt; standardLogin) {\r\n    // Function body to be implemented\r\n}\r\n\r\nint main() {\r\n    // Main function for testing\r\n}\r\n</code></pre>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <vector>\n#include <string>\n#include <numeric>\n\nclass Solution {\npublic:\n    int getLoginCodes(std::vector<int>& initialLogin, std::vector<int>& standardLogin) {\n        // Core logic to be implemented here\n        return 0;\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    int n;\n    std::cin >> n;\n    std::vector<int> initialLogin(n);\n    for (int i = 0; i < n; ++i) {\n        std::cin >> initialLogin[i];\n    }\n\n    int m;\n    std::cin >> m;\n    std::vector<int> standardLogin(m);\n    for (int i = 0; i < m; ++i) {\n        std::cin >> standardLogin[i];\n    }\n\n    Solution sol;\n    int result = sol.getLoginCodes(initialLogin, standardLogin);\n\n    std::cout << result << std::endl;\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "Factset_9oct",
        "company_id": 591
    },
    {
        "id": 1693,
        "title": "Weird Pod Count",
        "problem_statement": "<h1>Weird Pod Count</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>There are n microservices, where the number of running pods for the i<sup>th</sup> microservice is given by <code>pods[i]</code> for all <code>1 &le; i &le; n</code>. The goal is to make the number of running pods for each microservice distinct by:</p>\r\n<ul>\r\n<li>Choosing any i<sup>th</sup> microservice and increasing its number of running pods by 1, at a cost of <code>cost[i]</code></li>\r\n</ul>\r\n<p>Find the minimum possible cost to achieve this condition.</p>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input: n = 5, pods = [5, 2, 5, 3, 1], cost = [3, 7, 8, 6, 9]\r\nOutput: 9</code></pre>\r\n<p><strong>Explanation:</strong> An optimal sequence of operations is:</p>\r\n<ul>\r\n<li>Choose <code>pods[0] = 5</code> and increase it by 1. This operation costs 3. Now, <code>pods = [6, 2, 5, 3, 1]</code>.</li>\r\n<li>Choose <code>pods[3] = 3</code> and increase it by 1. This operation costs 6. Now, <code>pods = [6, 2, 5, 4, 1]</code>.</li>\r\n</ul>\r\n<p>Hence, <code>pods = [6, 2, 5, 4, 1]</code> consists of distinct numbers of running pods. The total cost is 3 + 6 = 9, which is the minimum possible.</p>\r\n\r\n<h3>Example 2:</h3>\r\n<pre><code class='language-text'>Input:\r\npods = [8, 6, 8]\r\ncost = [9, 5, 7]\r\nOutput: 7</code></pre>\r\n<p><strong>Explanation:</strong> An optimal sequence of operations is:</p>\r\n<ul>\r\n<li>Choose <code>pods[2] = 8</code> and increase it by 1. This operation costs 7. Now, <code>pods = [8, 6, 9]</code>.</li>\r\n</ul>\r\n<p>Now, <code>pods = [8, 6, 9]</code> consists of distinct numbers of running pods.</p>\r\n\r\n<h3>Example 3:</h3>\r\n<pre><code class='language-text'>Input:\r\npods = [3, 5]\r\ncost = [1, 7]\r\nOutput: 0</code></pre>\r\n<p><strong>Explanation:</strong> There is no need to perform any operation since the numbers of running pods are already distinct.</p>\r\n\r\n<h2>Function Description</h2>\r\n<p>Complete the function <code>getMinCost</code> in the editor with the following parameter(s):</p>\r\n<p><code>int pods[n]</code>: the number of running pods for each micro-service<br>\r\n<code>int cost[n]</code>: the cost of increasing the number of running pods for each micro-service</p>\r\n<p><strong>Returns</strong><br>\r\n<code>long</code>: the minimum possible cost to make the number of running pods for each microservice distinct.</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n<li><code>1 &le; n &le; 10<sup>5</sup></code></li>\r\n<li><code>1 &le; pods[i] &le; 10<sup>9</sup></code></li>\r\n<li><code>1 &le; cost[i] &le; 10<sup>5</sup></code></li>\r\n</ul>\r\n\r\n<pre><code class='language-cpp'>long getMinCost(vector<int> pods, vector<int> cost) {\r\n    // Function body to be implemented\r\n}</code></pre>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nclass Solution {\npublic:\n    long long getMinCost(const std::vector<int>& pods, const std::vector<int>& cost) {\n        // Core logic to be implemented here\n        return 0;\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    int n;\n    std::cin >> n;\n\n    std::vector<int> pods(n);\n    for (int i = 0; i < n; ++i) {\n        std::cin >> pods[i];\n    }\n\n    std::vector<int> cost(n);\n    for (int i = 0; i < n; ++i) {\n        std::cin >> cost[i];\n    }\n\n    Solution solution;\n    long long result = solution.getMinCost(pods, cost);\n\n    std::cout << result << std::endl;\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "Factset_9oct",
        "company_id": 591
    }
]