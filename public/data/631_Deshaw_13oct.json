[
    {
        "id": 1790,
        "title": "Save Components from Infection",
        "problem_statement": "<h1>Save Components from Infection</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>There are <code>n</code> software components arranged in a circular network, labeled from 1 to <code>n</code>. Each component relies on its neighboring components to function, meaning component 1 and 2 are neighbors, component 2 and 3 are neighbors, and so forth, with component <code>n</code> also connected back to component 1 to complete the circle.</p>\r\n<p>Initially, <code>m</code> of these components have been infected by a malicious bug. Each day, the lead developer can \"patch\" one uninfected component, making it permanently immune to the bug.</p>\r\n<p>Every day, the following sequence of events unfolds:</p>\r\n<ul>\r\n    <li>The lead developer selects an uninfected component and patches it, making it permanently bug-free.</li>\r\n    <li>All remaining unpatched and uninfected components with a neighboring infected component get infected by the bug.</li>\r\n</ul>\r\n<p>The developer's goal is to prevent as many components as possible from being infected.</p>\r\n<p>Given an integer <code>n</code> representing the total number of software components in the network and an integer array <code>infected</code> containing the indices of the initially infected components.</p>\r\n<p>Find the maximum number of components that can be saved from being infected if the developer optimally chooses which components to patch each day.</p>\r\n<p><strong>Note:</strong></p>\r\n<ul>\r\n    <li>The developer always applies a patch before the bug spreads to new components each day.</li>\r\n    <li>A patched component will never be infected.</li>\r\n</ul>\r\n\r\n<h3>Function Description</h3>\r\n<p>Complete the function <code>getMaxSaved</code> in the editor.</p>\r\n<p><code>getMaxSaved</code> has the following parameter(s):</p>\r\n<ul>\r\n    <li><code>int n</code>: an integer representing the total number of software components in the circular network.</li>\r\n    <li><code>int m</code>: an integer representing the count of components that are initially infected by the bug.</li>\r\n    <li><code>int infected[m]</code>: an array of integers containing the indices of the initially infected components.</li>\r\n</ul>\r\n<p><strong>Returns</strong></p>\r\n<ul>\r\n    <li><code>int</code>: the maximum number of components that can be saved from being infected.</li>\r\n</ul>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input: n = 9, m = 3, infected = [1, 3, 5]\r\nOutput: 3</code></pre>\r\n<p><strong>Explanation:</strong> To save the maximum number of components from infection, one of the optimal approaches is as follows:</p>\r\n<ul>\r\n    <li><strong>Day 1:</strong> The developer patches component 6, making it permanently bug-free. The infection then spreads to adjacent unprotected components neighboring an infected one, resulting in components [2, 4, 9] becoming infected.</li>\r\n    <li><strong>Day 2:</strong> The developer patches component 8, which stops any further spread since no uninfected components remain with infected neighbors. No additional components are infected.</li>\r\n    <li><strong>Day 3:</strong> The developer patches component 7, securing it permanently.</li>\r\n</ul>\r\n<p>In this way, the developer successfully saves a maximum of 3 components from infection.</p>\r\n<p>Note that there may be other sequences of patching components that achieve the same outcome of protecting 3 components, but no sequence can protect more than 3 components.</p>\r\n<p>Therefore, the answer is 3.</p>\r\n\r\n<h3>Example 2:</h3>\r\n<pre><code class='language-text'>Input: n = 7, m = 2, infected = [4, 1]\r\nOutput: 2</code></pre>\r\n<p><strong>Explanation:</strong> To save the maximum number of components from infection, one of the optimal approaches is as follows:</p>\r\n<ul>\r\n    <li><strong>Day 1:</strong> The developer patches component 2, making it permanently bug-free. The infection then spreads to adjacent unprotected components neighboring an infected one, resulting in components [3, 5, 7] becoming infected.</li>\r\n    <li><strong>Day 2:</strong> The developer patches component 6, which stops any further spread since no uninfected components remain with infected neighbors. No additional components are infected.</li>\r\n</ul>\r\n<p>In this way, the developer successfully saves a maximum of 2 components from infection.</p>\r\n<p>Note that other sequences of patching components may achieve the same outcome of protecting 2 components, but no sequence can protect more than 2 components.</p>\r\n<p>Therefore, the answer is 2.</p>\r\n\r\n<h3>Example 3:</h3>\r\n<pre><code class='language-text'>Input: n = 5, m = 3, infected = [1, 3, 5]\r\nOutput: 1</code></pre>\r\n<p><strong>Explanation:</strong> To save the maximum number of components from infection, one of the optimal approaches is as follows:</p>\r\n<ul>\r\n    <li><strong>Day 1:</strong> The developer patches component 4, making it permanently bug-free. The infection then spreads to adjacent unprotected components neighboring an infected one, resulting in component [2] becoming infected.</li>\r\n</ul>\r\n<p>In this way, the developer successfully saves a maximum of 1 component from infection.</p>\r\n<p>Note that other sequences of patching components may achieve the same outcome of protecting 1 component, but no sequence can protect more than 1 component.</p>\r\n<p>Therefore, the answer is 1.</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>2 &lt;= n &lt;= 10^9</code></li>\r\n    <li><code>1 &lt;= m &lt;= min(n, 10^5)</code></li>\r\n    <li><code>1 &lt;= infected[i] &lt;= n</code></li>\r\n</ul>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <numeric>\n\nclass Solution {\npublic:\n    int getMaxSaved(int n, int m, const std::vector<int>& infected) {\n        // Core logic to find the maximum number of saved components goes here.\n        return 0; // Placeholder return\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    int n, m;\n    std::cin >> n >> m;\n\n    std::vector<int> infected(m);\n    for (int i = 0; i < m; ++i) {\n        std::cin >> infected[i];\n    }\n\n    Solution solution;\n    int result = solution.getMaxSaved(n, m, infected);\n\n    std::cout << result << std::endl;\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "Deshaw_13oct",
        "company_id": 631
    },
    {
        "id": 1791,
        "title": "Maximum Recipes",
        "problem_statement": "<h1>Maximum Recipes</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>Determine the largest set of recipes that can be cooked without violating any precedence notes.</p>\r\n<p>Chef Bill wants to prepare a subset of n different recipes for tonight's banquet. His sous-chef supplies m handwritten notes, each stating that one recipe must be completed before another. A note written as a before b means Bill has to finish recipe a strictly earlier than recipe b.</p>\r\n<p>Treating each recipe as a vertex and every note as a directed edge a → b forms a dependency graph. Because every recipe appears on the right-hand side of at most one note, every vertex has in-degree ≤ 1. Such a graph is a collection of directed chains and single directed cycles (possibly with chains leading out of them). To make it acyclic, exactly one recipe must be skipped from every directed cycle; a self-loop (a before a) counts as a cycle of length 1 and forces that recipe to be skipped.</p>\r\n<p>Your task is to compute the maximum number of recipes Chef Bill can prepare without violating any of the notes he follows.</p>\r\n\r\n<h3>Function Description</h3>\r\n<p>Complete maxRecipes with the following parameters:</p>\r\n<ul>\r\n    <li>n - integer, total number of recipes</li>\r\n    <li>p - integer array of length m; p[i] is the recipe that must come first in note i</li>\r\n    <li>d - integer array of length m; d[i] is the recipe that must follow in note i</li>\r\n</ul>\r\n\r\n<h3>Returns</h3>\r\n<ul>\r\n    <li>An integer: the largest number of recipes Bill can cook while respecting the notes.</li>\r\n</ul>\r\n\r\n<h3>Input Format for Custom Testing</h3>\r\n<p>The first line contains integer n.</p>\r\n<p>The second line contains integer m.</p>\r\n<p>The next m lines each contain an integer p[i] (the \"before\" recipe).</p>\r\n<p>The following line contains integer m again.</p>\r\n<p>The next m lines each contain an integer d[i] (the \"after\" recipe).</p>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input:\r\n2\r\n0\r\n0\r\n(repeat) m\r\nOutput:\r\n2</code></pre>\r\n<p><strong>Explanation:</strong> No dependencies exist, so Bill can cook both recipes.</p>\r\n\r\n<h3>Example 2:</h3>\r\n<pre><code class='language-text'>Input:\r\n2\r\n1\r\n1\r\n1\r\n2\r\nOutput:\r\n1</code></pre>\r\n<p><strong>Explanation:</strong> One note: recipe 1 before recipe 2. Bill can cook both in order, so the answer is 2.</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>1 <= n <= 10^5</code></li>\r\n    <li><code>0 <= m <= n</code></li>\r\n    <li><code>1 <= p[i], d[i] <= n</code></li>\r\n    <li>Each recipe appears in d at most once (in-degree <= 1).</li>\r\n</ul>\r\n\r\n<pre><code class='language-javascript'>int maxRecipes(int n, vector&lt;int&gt; p, vector&lt;int&gt; d) {\r\n}</code></pre>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <vector>\n#include <string>\n#include <numeric>\n\nclass Solution {\npublic:\n    int maxRecipes(int n, std::vector<int> p, std::vector<int> d) {\n        // Your code here\n        return 0;\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    int n;\n    std::cin >> n;\n\n    int m;\n    std::cin >> m;\n\n    std::vector<int> p(m);\n    for (int i = 0; i < m; ++i) {\n        std::cin >> p[i];\n    }\n\n    int m_again;\n    std::cin >> m_again;\n\n    std::vector<int> d(m);\n    for (int i = 0; i < m; ++i) {\n        std::cin >> d[i];\n    }\n\n    Solution solution;\n    int result = solution.maxRecipes(n, p, d);\n    std::cout << result << std::endl;\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "Deshaw_13oct",
        "company_id": 631
    }
]