[
    {
        "id": 1828,
        "title": "Square Accumulate Root",
        "problem_statement": "<h1>Square Accumulate Root</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>A developer needs to perform three operations on input numbers: squaring a number, taking the square root of a number, or summing input numbers. The order of these operations is unknown beforehand, making it ideal for implementing co-routines using the producer-filter-consumer pattern. Implement three co-routines:</p>\r\n<ul>\r\n    <li>The accumulator: Receives a number, adds it to the previously stored sum (starting at 0), and yields the new sum.</li>\r\n    <li>The squarer: Receives a number and yields its square.</li>\r\n    <li>The rooter: Receives a number and yields the floor of its square root.</li>\r\n</ul>\r\n<p><strong>Functions Description</strong></p>\r\n<p>Complete the co-routine accumulator, squarer, and rooter in the editor below. These co-routines do not have any input and communicate completely through the sub-routine pipeline.</p>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input: order = [square, accumulate]\r\nnums = [1, 2, 3]</code></pre>\r\n<p><strong>Explanation:</strong></p>\r\n<ul>\r\n    <li>After processing 1: The output is 1 (1<sup>2</sup> = 1, accumulate to 0 + 1 = 1)</li>\r\n    <li>After processing 2: The output is 5 (2<sup>2</sup> = 4, accumulate to 1 + 4 = 5)</li>\r\n    <li>After processing 3: The output is 14 (3<sup>2</sup> = 9, accumulate to 5 + 9 = 14)</li>\r\n</ul>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li>1 &le; n &le; 10<sup>5</sup></li>\r\n    <li>1 &le; nums[i] &le; 10<sup>5</sup> (where 0 &le; i &lt; n)</li>\r\n</ul>\r\n\r\n<h2>Input Format</h2>\r\n<p>The first line contains a string, order, describing the order in which to perform the operations.\r\nThe next line contains an integer, n, denoting the number of elements in nums.\r\nEach line i of the n subsequent lines (where 0 &le; i &lt; n) contains an integer describing nums[i].</p>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <sstream>\n#include <algorithm>\n\nclass Solution {\npublic:\n    /**\n     * @param order A string describing the order of operations.\n     * @param nums A vector of integers to be processed.\n     * @return A vector of long longs containing the result for each number processed.\n     */\n    std::vector<long long> process_numbers(const std::string& order, const std::vector<int>& nums) {\n        // --- Placeholder for the core logic ---\n        // 1. Parse the 'order' string to determine the sequence of operations.\n        //    For example, split the string by commas or other delimiters.\n        //\n        // 2. Initialize any stateful operations. For 'accumulate', you'll need a\n        //    running sum variable, initialized to 0.\n        //\n        // 3. Iterate through each number in the 'nums' vector.\n        //\n        // 4. For each number, apply the sequence of operations parsed in step 1.\n        //    - 'square': value = value * value\n        //    - 'root': value = floor(sqrt(value))\n        //    - 'accumulate': sum += value; value = sum\n        //\n        // 5. After processing each number through the pipeline, store the final\n        //    result in a results vector.\n        //\n        // 6. Return the results vector.\n\n        std::vector<long long> results;\n        // Example placeholder:\n        // for (int num : nums) {\n        //     long long current_val = num;\n        //     // Apply operations based on parsed 'order'\n        //     results.push_back(current_val);\n        // }\n        return results;\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    std::string order;\n    std::getline(std::cin, order);\n\n    int n;\n    std::cin >> n;\n\n    std::vector<int> nums(n);\n    for (int i = 0; i < n; ++i) {\n        std::cin >> nums[i];\n    }\n\n    Solution sol;\n    std::vector<long long> results = sol.process_numbers(order, nums);\n\n    for (size_t i = 0; i < results.size(); ++i) {\n        std::cout << results[i] << \"\\n\";\n    }\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "ZS_14oct",
        "company_id": 646
    },
    {
        "id": 1829,
        "title": "Python: Lambda Sort",
        "problem_statement": "<h1>Python: Lambda Sort</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>Implement a lambda function to sort a two-dimensional array based on one or more columns. You are provided with a list of pairs in the format [index to sort on, sort direction], where the sort direction is 1 for descending and 0 for ascending. Complete the lambda function to perform the requested sorting operations in the specified order.</p>\r\n<p><strong>Note:</strong> The sort should be stable, i.e., in the event of a tie, the array that is at the lower index originally is at the lower index in the result.</p>\r\n\r\n<p><strong>Functions Description</strong></p>\r\n<p>Complete the lambda expression in the <code>indexSort</code> function that takes the following parameters:</p>\r\n<ul>\r\n    <li><code>arr[n][m]</code>: a 2-dimensional array of arrays of size m</li>\r\n    <li><code>indices[k][2]</code>: a 2-dimensional array of 2-element arrays: [sort index, direction]</li>\r\n</ul>\r\n<p><strong>Returns</strong></p>\r\n<p>None: The lambda function sorts the global array in place</p>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input: arr = [[2, 1], [3, 3], [1, 4], [2, 3], [6, 4, 3]]\r\nindices = [[1, 0], [2, 1]]</code></pre>\r\n<p><strong>Explanation:</strong></p>\r\n<ol>\r\n    <li>The primary sort key is column 1, ascending. This sort produces [[2, 1], [4, 2, 3], [3, 3], [6, 4, 3]]. The column 1 values are 2, 2, 3, 4.</li>\r\n    <li>The secondary sort key is column 2, descending. This applies to the two records that tied in the primary sort: [1, 2, 1] and [4, 2, 3]. These are sorted descending as [4, 2, 3], [1, 2, 1] using column 2 values 3, 1.</li>\r\n    <li>The sorted list is [[4, 2, 3], [1, 2, 1], [3, 3, 1], [6, 4, 3]].</li>\r\n</ol>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>1 &le; n &le; 10<sup>4</sup></code></li>\r\n    <li><code>1 &le; m &le; 10</code></li>\r\n    <li><code>1 &le; k &le; m</code></li>\r\n    <li><code>0 &le; indices[i][0] &lt; m</code> (where <code>0 &le; i &lt; k</code>)</li>\r\n</ul>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nclass Solution {\npublic:\n    std::vector<std::vector<int>> indexSort(\n        std::vector<std::vector<int>> arr,\n        const std::vector<std::vector<int>>& indices) {\n        // Core logic to be implemented here.\n        return arr;\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    int n;\n    std::cin >> n;\n\n    std::vector<std::vector<int>> arr(n);\n    for (int i = 0; i < n; ++i) {\n        int m_i;\n        std::cin >> m_i;\n        arr[i].resize(m_i);\n        for (int j = 0; j < m_i; ++j) {\n            std::cin >> arr[i][j];\n        }\n    }\n\n    int k;\n    std::cin >> k;\n    std::vector<std::vector<int>> indices(k, std::vector<int>(2));\n    for (int i = 0; i < k; ++i) {\n        std::cin >> indices[i][0] >> indices[i][1];\n    }\n\n    Solution solution;\n    std::vector<std::vector<int>> result = solution.indexSort(arr, indices);\n\n    for (const auto& row : result) {\n        for (size_t i = 0; i < row.size(); ++i) {\n            std::cout << row[i] << (i == row.size() - 1 ? \"\" : \" \");\n        }\n        std::cout << \"\\n\";\n    }\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "ZS_14oct",
        "company_id": 646
    },
    {
        "id": 1830,
        "title": "Python: Suffix-stripping Stemmer",
        "problem_statement": "<h1>Python: Suffix-stripping Stemmer</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>Implement a stemming algorithm to extract the base form of words using these rules:</p>\r\n<ol>\r\n    <li>If the word ends in \"ed\", \"ly\", or \"ing\", remove the suffix.</li>\r\n    <li>If the resulting word is longer than 8 letters, keep only the first 8 letters.</li>\r\n</ol>\r\n<p>Create a function that takes a string of space-separated words and returns its stemmed counterpart.</p>\r\n<p>Complete the function <code>stemmer</code> in the editor with the following parameter(s):</p>\r\n<ul>\r\n    <li><code>string text</code>: the input text</li>\r\n</ul>\r\n<p><strong>Returns</strong></p>\r\n<ul>\r\n    <li><code>string</code>: the input text with each of the words replaced by its stem</li>\r\n</ul>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input: text = \"an extremely dangerous dog is barking\"\r\nOutput: \"an extreme dangerou dog is bark\"</code></pre>\r\n<p><strong>Explanation:</strong> Processing each word:</p>\r\n<ul>\r\n    <li>\"an\": No suffix to remove, less than 8 letters → \"an\"</li>\r\n    <li>\"extremely\": Remove \"ly\" → \"extreme\", less than 8 letters → \"extreme\"</li>\r\n    <li>\"dangerous\": No suffix to remove, but 9 letters long → truncate to \"dangerou\"</li>\r\n    <li>\"dog\": No suffix to remove, less than 8 letters → \"dog\"</li>\r\n    <li>\"is\": No suffix to remove, less than 8 letters → \"is\"</li>\r\n    <li>\"barking\": Remove \"ing\" → \"bark\", less than 8 letters → \"bark\"</li>\r\n</ul>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li>Every character in text is either an English lowercase letter or a space character.</li>\r\n    <li>text starts and ends with a letter. No two consecutive characters are spaces.</li>\r\n    <li>text contains at most 100 words.</li>\r\n    <li>No word is longer than 18 letters.</li>\r\n</ul>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <string>\n#include <vector>\n#include <sstream>\n\nclass Solution {\npublic:\n    std::string stemmer(const std::string& text) {\n        // Your implementation here\n        return \"\";\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    std::string text;\n    std::getline(std::cin, text);\n\n    Solution solution;\n    std::string result = solution.stemmer(text);\n\n    std::cout << result << std::endl;\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "ZS_14oct",
        "company_id": 646
    }
]