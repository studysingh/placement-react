[
    {
        "id": 1699,
        "title": "Divisor power",
        "problem_statement": "<h1>Divisor power</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>Given a rooted tree consisting of N nodes which are rooted at node 1. Each node is associated with some value A[i].</p>\r\n<p>D(X) is defined as the number of divisors of X. For example, D(6) = 4, D(12) = 6.</p>\r\n<p>COUNT(i, A[j]) is defined as the frequency of A[j] in the subtree of node i.</p>\r\n<p>Find the divisor power of each node where the divisor power of node i is defined as:</p>\r\n<p>DivisorPower(i) = Σ D(A[j]) * COUNT(i, A[j])</p>\r\n<p>where j varies over all the nodes in the subtree of i.</p>\r\n\r\n<h3>Function description</h3>\r\n<p>Complete the <code>Divisor_Power</code> function. The function takes the following 3 parameters and returns an array denoting the divisor power of each node:</p>\r\n<ul>\r\n    <li><strong>N:</strong> Represents the number of nodes in the tree</li>\r\n    <li><strong>A:</strong> Represents the array denoting the associated value with nodes</li>\r\n    <li><strong>edge:</strong> Represents the edge in the tree</li>\r\n</ul>\r\n\r\n<h3>Input format for custom testing</h3>\r\n<p><strong>Note:</strong> Use this input format if you are testing against custom input or writing code in a language where we don't provide boilerplate code.</p>\r\n<ul>\r\n    <li>The first line contains an integer N.</li>\r\n    <li>The next line contains N space-separated integers denoting the values of A[i].</li>\r\n    <li>The next N-1 line contains two space-separated integers X and Y describing there is an edge between X and Y.</li>\r\n</ul>\r\n\r\n<h3>Output format</h3>\r\n<p>Print N space-separated integers representing the divisor power of each node.</p>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<p><strong>Sample Input:</strong></p>\r\n<pre><code class='language-text'>5\r\n10 10 4 4 12\r\n1 2\r\n2 3\r\n2 4\r\n3 5</code></pre>\r\n<p><strong>Sample Output:</strong></p>\r\n<pre><code class='language-text'>34 22 9 3 6</code></pre>\r\n<p><strong>Explanation:</strong></p>\r\n<p>The tree structure is as follows:</p>\r\n<pre><code class='language-text'>    1 (A[1]=10)\r\n    |\r\n    2 (A[2]=10)\r\n   / \\\r\n  3   4 (A[4]=4)\r\n  |\r\n  5 (A[5]=12)</code></pre>\r\n<p>The values associated with nodes are A = [10, 10, 4, 4, 12] (assuming 1-indexed for A[i] based on node i).</p>\r\n<p>Let's calculate D(X) for the values present:</p>\r\n<ul>\r\n    <li>D(4) = 3 (divisors: 1, 2, 4)</li>\r\n    <li>D(10) = 4 (divisors: 1, 2, 5, 10)</li>\r\n    <li>D(12) = 6 (divisors: 1, 2, 3, 4, 6, 12)</li>\r\n</ul>\r\n<p>Now, we calculate DivisorPower(i) for each node i using the formula: Σ D(A[j]) * COUNT(i, A[j]) where j is a node in the subtree of i.</p>\r\n<ul>\r\n    <li><strong>Node 1:</strong> Subtree nodes = {1, 2, 3, 4, 5}. Values in subtree = [10, 10, 4, 4, 12].\r\n        <ul>\r\n            <li>j=1 (A[1]=10): D(10) * COUNT(1, 10) = 4 * 2 = 8</li>\r\n            <li>j=2 (A[2]=10): D(10) * COUNT(1, 10) = 4 * 2 = 8</li>\r\n            <li>j=3 (A[3]=4): D(4) * COUNT(1, 4) = 3 * 2 = 6</li>\r\n            <li>j=4 (A[4]=4): D(4) * COUNT(1, 4) = 3 * 2 = 6</li>\r\n            <li>j=5 (A[5]=12): D(12) * COUNT(1, 12) = 6 * 1 = 6</li>\r\n            <li>DivisorPower(1) = 8 + 8 + 6 + 6 + 6 = 34</li>\r\n        </ul>\r\n    </li>\r\n    <li><strong>Node 2:</strong> Subtree nodes = {2, 3, 4, 5}. Values in subtree = [10, 4, 4, 12].\r\n        <ul>\r\n            <li>j=2 (A[2]=10): D(10) * COUNT(2, 10) = 4 * 1 = 4</li>\r\n            <li>j=3 (A[3]=4): D(4) * COUNT(2, 4) = 3 * 2 = 6</li>\r\n            <li>j=4 (A[4]=4): D(4) * COUNT(2, 4) = 3 * 2 = 6</li>\r\n            <li>j=5 (A[5]=12): D(12) * COUNT(2, 12) = 6 * 1 = 6</li>\r\n            <li>DivisorPower(2) = 4 + 6 + 6 + 6 = 22</li>\r\n        </ul>\r\n    </li>\r\n    <li><strong>Node 3:</strong> Subtree nodes = {3, 5}. Values in subtree = [4, 12].\r\n        <ul>\r\n            <li>j=3 (A[3]=4): D(4) * COUNT(3, 4) = 3 * 1 = 3</li>\r\n            <li>j=5 (A[5]=12): D(12) * COUNT(3, 12) = 6 * 1 = 6</li>\r\n            <li>DivisorPower(3) = 3 + 6 = 9</li>\r\n        </ul>\r\n    </li>\r\n    <li><strong>Node 4:</strong> Subtree nodes = {4}. Values in subtree = [4].\r\n        <ul>\r\n            <li>j=4 (A[4]=4): D(4) * COUNT(4, 4) = 3 * 1 = 3</li>\r\n            <li>DivisorPower(4) = 3</li>\r\n        </ul>\r\n    </li>\r\n    <li><strong>Node 5:</strong> Subtree nodes = {5}. Values in subtree = [12].\r\n        <ul>\r\n            <li>j=5 (A[5]=12): D(12) * COUNT(5, 12) = 6 * 1 = 6</li>\r\n            <li>DivisorPower(5) = 6</li>\r\n        </ul>\r\n    </li>\r\n</ul>\r\n<p>The output array is [34, 22, 9, 3, 6].</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>2 &le; N &le; 10<sup>5</sup></code></li>\r\n    <li><code>1 &le; A<sub>i</sub> &le; 10<sup>6</sup></code></li>\r\n    <li><code>1 &le; X, Y &le; N</code></li>\r\n</ul>\r\n\r\n<pre><code class='language-cpp'>vector<long long> Divisor_Power(int N, vector<int> A, vector<vector<int>> edge) {\r\n    // Write your code here\r\n}</code></pre>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <vector>\n#include <string>\n\nclass Solution {\npublic:\n    /**\n     * @param N The number of nodes in the tree.\n     * @param A A vector of integers where A[i] is the value associated with node i+1.\n     * @param edge A vector of pairs representing the edges of the tree.\n     * @return A vector of long longs representing the divisor power of each node.\n     */\n    std::vector<long long> Divisor_Power(int N, std::vector<int>& A, std::vector<std::vector<int>>& edge) {\n        // --- Placeholder for the solution logic ---\n        // The actual implementation will involve:\n        // 1. Pre-calculating the number of divisors for all possible values in A.\n        // 2. Building an adjacency list representation of the tree from the edge list.\n        // 3. Performing a DFS from the root (node 1) to compute subtree properties.\n        // 4. For each node, calculate the DivisorPower based on the values in its subtree.\n        //    This can be done efficiently using techniques like DFS with map merging.\n        \n        std::vector<long long> result(N);\n        // The result vector should be populated with the DivisorPower for each node from 1 to N.\n        // result[i] will correspond to the answer for node i+1.\n        return result;\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    int N;\n    std::cin >> N;\n\n    std::vector<int> A(N);\n    for (int i = 0; i < N; ++i) {\n        std::cin >> A[i];\n    }\n\n    std::vector<std::vector<int>> edge(N - 1, std::vector<int>(2));\n    for (int i = 0; i < N - 1; ++i) {\n        std::cin >> edge[i][0] >> edge[i][1];\n    }\n\n    Solution solution;\n    std::vector<long long> result = solution.Divisor_Power(N, A, edge);\n\n    for (size_t i = 0; i < result.size(); ++i) {\n        std::cout << result[i] << (i == result.size() - 1 ? \"\" : \" \");\n    }\n    std::cout << std::endl;\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "Trimble",
        "company_id": 593
    },
    {
        "id": 1700,
        "title": "Debugging - K-special numbers",
        "problem_statement": "<h1>Debugging - K-special numbers</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>You are given a code for the following problem statement in the <code>count_K_special_numbers</code> function. However, the solution fails the test cases because there are bugs in the code. Your task is to find and fix all the bugs so that it passes all the test cases.</p>\r\n<p>You are given a range <code>[L, R]</code> and an integer <code>k</code>.</p>\r\n<p>An integer <code>A</code> as <code>a_1 a_2 ... a_n</code> consisting of <code>n</code> digits in decimal representation without any leading zeros is called K-special number, if <code>(a_i mod k) = (i mod k)</code> holds true for all <code>i (1 &le; i &le; n)</code>.</p>\r\n<p><strong>Task:</strong> Determine the number of K-special numbers in the range <code>[L, R]</code>.</p>\r\n<p><strong>Notes:</strong></p>\r\n<ul>\r\n    <li>The mod operation returns the remainder or signed remainder of a division after dividing one number by another. It is represented by the <code>%</code> sign in Python.</li>\r\n    <li>1-based indexing is followed.</li>\r\n</ul>\r\n<p>Complete the <code>count_K_special_numbers</code> function provided in the editor. This function takes the following 3 parameters and returns the number of K-Special numbers in the range <code>[L, R]</code>:</p>\r\n<ul>\r\n    <li><code>k</code>: Represents the value of integer <code>k</code></li>\r\n    <li><code>L</code>: Represents an integer denoting the lower limit of the range</li>\r\n    <li><code>R</code>: Represents an integer denoting the upper limit of the range</li>\r\n</ul>\r\n<p><strong>Input Format:</strong></p>\r\n<p>Note: This is the input format that you must use to provide custom input (available above the Compile and Test button).</p>\r\n<p>The first line contains an integer <code>T</code> denoting the number of test cases. <code>T</code> also denotes the number of times you have to run the <code>count_K_special_numbers</code> function on a different set of inputs.</p>\r\n<p>For each test case:</p>\r\n<ul>\r\n    <li>The first line contains a single integer <code>k</code>.</li>\r\n    <li>The second line contains a single integer <code>L</code>.</li>\r\n    <li>The third line contains a single integer <code>R</code>.</li>\r\n</ul>\r\n<p><strong>Output Format:</strong></p>\r\n<p>For each test case in a new line, print an integer representing the number of K-special numbers in the range <code>[L, R]</code>.</p>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input:\r\n2\r\n3\r\n126\r\n126\r\n1\r\n11\r\n18\r\nOutput:\r\n1\r\n8</code></pre>\r\n<p><strong>Explanation:</strong></p>\r\n<p>The first line contains the number of test cases, <code>T=2</code>.</p>\r\n<p><strong>First test case:</strong></p>\r\n<ul>\r\n    <li><code>k = 3</code></li>\r\n    <li><code>L = 126</code></li>\r\n    <li><code>R = 126</code></li>\r\n</ul>\r\n<p>The number in the range <code>[126, 126]</code> is <code>126</code>. Let's check if <code>126</code> is a K-special number for <code>k=3</code>.</p>\r\n<p>For <code>A = 126</code>, digits are <code>a_1=1, a_2=2, a_3=6</code>.</p>\r\n<ul>\r\n    <li>For <code>i=1</code>: <code>(a_1 mod k) = (1 mod 3) = 1</code>. <code>(i mod k) = (1 mod 3) = 1</code>. Matches.</li>\r\n    <li>For <code>i=2</code>: <code>(a_2 mod k) = (2 mod 3) = 2</code>. <code>(i mod k) = (2 mod 3) = 2</code>. Matches.</li>\r\n    <li>For <code>i=3</code>: <code>(a_3 mod k) = (6 mod 3) = 0</code>. <code>(i mod k) = (3 mod 3) = 0</code>. Matches.</li>\r\n</ul>\r\n<p>Since <code>(a_i mod k) = (i mod k)</code> holds true for all <code>i</code>, <code>126</code> is a K-special number.</p>\r\n<p>Therefore, the number of K-Special numbers in the range <code>[126, 126]</code> is 1.</p>\r\n<p><strong>Second test case:</strong></p>\r\n<ul>\r\n    <li><code>k = 1</code></li>\r\n    <li><code>L = 11</code></li>\r\n    <li><code>R = 18</code></li>\r\n</ul>\r\n<p>The output is <code>8</code>. (No detailed explanation provided for this test case in the source image.)</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>1 &le; T &le; 10<sup>5</sup></code></li>\r\n    <li><code>1 &le; k &le; 9</code></li>\r\n    <li><code>1 &le; L &le; R &le; 10<sup>13</sup></code></li>\r\n</ul>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nclass Solution {\npublic:\n    long long count_K_special_numbers(int k, long long L, long long R) {\n        // Core logic to solve the problem will be implemented here.\n        // A common approach is to use digit DP to count numbers up to R\n        // and subtract the count up to L-1.\n        return 0;\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    int t;\n    std::cin >> t;\n    while (t--) {\n        int k;\n        long long L, R;\n        std::cin >> k;\n        std::cin >> L;\n        std::cin >> R;\n\n        Solution solver;\n        long long result = solver.count_K_special_numbers(k, L, R);\n        std::cout << result << \"\\n\";\n    }\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "Trimble",
        "company_id": 593
    }
]