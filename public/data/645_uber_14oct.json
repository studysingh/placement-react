[
    {
        "id": 1827,
        "title": "Efficient Scaling",
        "problem_statement": "<h1>Efficient Scaling</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>A data processing pipeline consists of <code>n</code> services in series where the output of service <code>i</code> serves as input to service <code>i+1</code>. Each service has varying latency, and the throughput of the <code>i<sup>th</sup></code> service is represented by <code>throughput[i]</code> in messages per minute.</p>\r\n<p>Each service can be scaled up independently. Scaling up the <code>i<sup>th</sup></code> service one unit of time costs <code>scalingCost[i]</code>, and after scaling up <code>x</code> times, the service can process <code>throughput[i] * (1 + x)</code> messages per minute.</p>\r\n<p>Given <code>throughput</code> and <code>scalingCost</code> arrays of size <code>n</code>, and a <code>budget</code> value, determine the optimal scaling configuration to maximize the throughput of the final service. Return the maximum throughput possible.</p>\r\n\r\n<p><strong>Illustrative Example:</strong></p>\r\n<p>Consider <code>throughput = [4, 2, 7]</code>, <code>scalingCost = [3, 5, 6]</code>, <code>budget = 35</code>.</p>\r\n<p>To maximize the throughput of the final service, an optimal solution might involve scaling as follows:</p>\r\n<pre><code class='language-text'>Service Index | Throughput | Scale To | Times Scaled | Cost per Scaling | Total Cost\r\n--------------|------------|----------|--------------|------------------|-----------\r\n0             | 4          | 12       | 2            | 3                | 6\r\n1             | 2          | 10       | 4            | 5                | 20\r\n2             | 7          | 14       | 1            | 6                | 6\r\n</code></pre>\r\n<p>The total cost for this scaling is <code>6 + 20 + 6 = 32</code>, which is within the budget of <code>35</code>. The remaining budget is <code>35 - 32 = 3</code>.</p>\r\n<p>From these units applied in series, they generate a throughput of <code>min(12, 10, 14) = 10</code> units. This is the maximum possible throughput given the budget. Hence the answer is <code>10</code>.</p>\r\n\r\n<p>Complete the function <code>getMaximumThroughput</code> in the editor below.</p>\r\n<p>The function <code>getMaximumThroughput</code> has the following parameters:</p>\r\n<ul>\r\n    <li><code>int throughput[n]</code>: the throughput generated by each of the <code>n</code> services</li>\r\n    <li><code>int scalingCost[n]</code>: the cost of scaling up a service one time</li>\r\n    <li><code>int budget</code>: the available money</li>\r\n</ul>\r\n\r\n<h3>Returns</h3>\r\n<p><code>long int</code>: the maximum value of the throughput generated at the end of the composite service after scaling within the budget.</p>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1: (Sample Case 0)</h3>\r\n<pre><code class='language-text'>Input:\r\nn = 3\r\nthroughput = [3, 2, 5]\r\nscalingCost = [2, 5, 10]\r\nbudget = 28\r\n\r\nOutput:\r\n6</code></pre>\r\n<p><strong>Explanation:</strong>\r\nThe optimal scaling configuration to achieve maximum throughput within the budget is:</p>\r\n<pre><code class='language-text'>Service Index | Throughput | Scale To | Times Scaled | Cost per Scaling | Total Cost\r\n--------------|------------|----------|--------------|------------------|-----------\r\n0             | 3          | 15       | 4            | 2                | 8\r\n1             | 2          | 6        | 2            | 5                | 10\r\n2             | 5          | 10       | 1            | 10               | 10\r\n</code></pre>\r\n<p>The total cost is <code>8 + 10 + 10 = 28</code>, which exactly matches the budget. The final throughput is <code>min(15, 6, 10) = 6</code>.</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>1 <= n <= 10<sup>5</sup></code></li>\r\n    <li><code>1 <= throughput[i] <= 10<sup>7</sup></code></li>\r\n    <li><code>1 <= scalingCost[i] <= 200</code></li>\r\n    <li><code>1 <= budget <= 10<sup>9</sup></code></li>\r\n    <li>It is guaranteed that the answer, i.e., the maximum throughput value at the end of the <code>n</code> services is <code>&lt;= 10<sup>9</sup></code>.</li>\r\n</ul>\r\n\r\n<h2>Input Format For Custom Testing</h2>\r\n<p>The first line contains an integer, <code>n</code>, the number of elements in <code>throughput</code>.</p>\r\n<p>The next line contains <code>n</code> integers, <code>throughput[0], throughput[1], ..., throughput[n-1]</code>.</p>\r\n<p>The next line contains an integer, <code>n</code>, the number of elements in <code>scalingCost</code>.</p>\r\n<p>The next line contains <code>n</code> integers, <code>scalingCost[0], scalingCost[1], ..., scalingCost[n-1]</code>.</p>\r\n<p>The next line contains an integer, <code>budget</code>.</p>\r\n\r\n<p><strong>Function Signature:</strong></p>\r\n<pre><code class='language-javascript'>public static int getMaximumThroughput(List&lt;Integer&gt; throughput, List&lt;Integer&gt; scalingCost, int budget) {\r\n    // Write your code here\r\n}</code></pre>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nclass Solution {\npublic:\n    long long getMaximumThroughput(const std::vector<int>& throughput, const std::vector<int>& scalingCost, int budget) {\n        // Core logic to determine the optimal scaling and maximum throughput goes here.\n        return 0; // Placeholder return\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    int n;\n    std::cin >> n;\n\n    std::vector<int> throughput(n);\n    for (int i = 0; i < n; ++i) {\n        std::cin >> throughput[i];\n    }\n\n    int n_scaling_cost;\n    std::cin >> n_scaling_cost; // As per input format, read n again\n\n    std::vector<int> scalingCost(n);\n    for (int i = 0; i < n; ++i) {\n        std::cin >> scalingCost[i];\n    }\n\n    int budget;\n    std::cin >> budget;\n\n    Solution sol;\n    long long result = sol.getMaximumThroughput(throughput, scalingCost, budget);\n\n    std::cout << result << std::endl;\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "uber_14oct",
        "company_id": 645
    },
    {
        "id": 1831,
        "title": "Security Breaching",
        "problem_statement": "<h1>Security Breaching</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>Calculate attacker points in a multi-level cyber attack simulation.</p>\r\n<ul>\r\n    <li>An attack progresses through <code>n</code> security levels (1 to <code>n</code>).</li>\r\n    <li>The attacker can start at any level <code>i</code> with initial energy <code>k</code>.</li>\r\n    <li>At each level <code>i</code>:\r\n        <ul>\r\n            <li>The attacker must spend <code>layers[i]</code> energy to breach that level.</li>\r\n            <li>If energy is insufficient, the attack fails and ends.</li>\r\n            <li>If after breaching, remaining energy is greater than or equal to <code>energy[i]</code>, the attacker scores 1 point.</li>\r\n        </ul>\r\n    </li>\r\n</ul>\r\n<p>Compute an array where the <code>i</code><sup>th</sup> element represents the maximum number of points an attacker can score when starting at level <code>i</code> with initial energy <code>k</code>. Return the array of maximum possible scores from each starting level.</p>\r\n\r\n<p>Complete the function <code>getNumPoints</code> in the editor with the following arguments:</p>\r\n<ul>\r\n    <li><code>int layers[n]</code>: the energy required to breach each layer.</li>\r\n    <li><code>int energy[n]</code>: the minimum remaining energy required to score a point after breaching a layer.</li>\r\n    <li><code>long int k</code>: the initial energy.</li>\r\n</ul>\r\n<p><strong>Returns:</strong></p>\r\n<ul>\r\n    <li><code>int[n]</code>: the number of points that can be collected starting from each level.</li>\r\n</ul>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input:\r\nn = 3\r\nlayers = [5, 8, 1]\r\nenergy = [4, 2, 1]\r\nk = 10\r\nOutput: [1, 2, 1]</code></pre>\r\n<p><strong>Explanation:</strong></p>\r\n<ul>\r\n    <li><strong>Starting at Level 1:</strong>\r\n        <ul>\r\n            <li>Initial Energy: 10</li>\r\n            <li><strong>Level 1:</strong> Spend <code>layers[0] = 5</code>. Energy left = <code>10 - 5 = 5</code>.\r\n                Since <code>5 >= energy[0] = 4</code>, 1 point is awarded. (Total points: 1)</li>\r\n            <li><strong>Level 2:</strong> Current Energy = 5. Spend <code>layers[1] = 8</code>.\r\n                Energy is insufficient (<code>5 < 8</code>). The attack fails and ends.</li>\r\n            <li>Maximum points for starting at Level 1: 1.</li>\r\n        </ul>\r\n    </li>\r\n    <li><strong>Starting at Level 2:</strong>\r\n        <ul>\r\n            <li>Initial Energy: 10</li>\r\n            <li><strong>Level 2:</strong> Spend <code>layers[1] = 8</code>. Energy left = <code>10 - 8 = 2</code>.\r\n                Since <code>2 >= energy[1] = 2</code>, 1 point is awarded. (Total points: 1)</li>\r\n            <li><strong>Level 3:</strong> Current Energy = 2. Spend <code>layers[2] = 1</code>. Energy left = <code>2 - 1 = 1</code>.\r\n                Since <code>1 >= energy[2] = 1</code>, 1 point is awarded. (Total points: 2)</li>\r\n            <li>Maximum points for starting at Level 2: 2.</li>\r\n        </ul>\r\n    </li>\r\n    <li><strong>Starting at Level 3:</strong>\r\n        <ul>\r\n            <li>Initial Energy: 10</li>\r\n            <li><strong>Level 3:</strong> Spend <code>layers[2] = 1</code>. Energy left = <code>10 - 1 = 9</code>.\r\n                Since <code>9 >= energy[2] = 1</code>, 1 point is awarded. (Total points: 1)</li>\r\n            <li>Maximum points for starting at Level 3: 1.</li>\r\n        </ul>\r\n    </li>\r\n</ul>\r\n<p>Hence, the answer is <code>[1, 2, 1]</code>.</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>1 <= n <= 2 * 10^5</code></li>\r\n    <li><code>1 <= layers[i] <= 10^9</code></li>\r\n    <li><code>1 <= energy[i] <= 10^9</code></li>\r\n    <li><code>1 <= k <= 2 * 10^9</code></li>\r\n</ul>\r\n\r\n<h2>Input Format For Custom Testing</h2>\r\n<p>The first line contains an integer, <code>n</code>, the number of elements in <code>layers</code>.</p>\r\n<p>Each of the next <code>n</code> lines contains an integer, <code>layers[i]</code>.</p>\r\n<p>The next line contains an integer, <code>n</code>, the number of elements in <code>energy</code>.</p>\r\n<p>Each of the next <code>n</code> lines contains an integer, <code>energy[i]</code>.</p>\r\n<p>The next line contains an integer, <code>k</code>.</p>\r\n\r\n<h3>Sample Input For Custom Testing</h3>\r\n<pre><code class='language-text'>3\r\n2\r\n2\r\n5\r\n3\r\n2\r\n3\r\n1\r\n5</code></pre>\r\n\r\n<h3>Sample Output</h3>\r\n<pre><code class='language-text'>1\r\n1\r\n0</code></pre>\r\n\r\n<p><strong>Explanation:</strong></p>\r\n<ul>\r\n    <li><strong>Starting from the first level:</strong>\r\n        <ul>\r\n            <li>Initial Energy: 5</li>\r\n            <li><strong>Level 1:</strong> Spend <code>layers[0] = 2</code>. Energy left = <code>5 - 2 = 3</code>.\r\n                Since <code>3 >= energy[0] = 2</code>, 1 point is collected. (Total points: 1)</li>\r\n            <li><strong>Level 2:</strong> Current Energy = 3. Spend <code>layers[1] = 2</code>. Energy left = <code>3 - 2 = 1</code>.\r\n                Since <code>1 < energy[1] = 3</code>, no point is collected. (Total points: 1)</li>\r\n            <li><strong>Level 3:</strong> Current Energy = 1. Spend <code>layers[2] = 5</code>.\r\n                Energy is insufficient (<code>1 < 5</code>). The attack fails and ends.</li>\r\n            <li>Maximum points for starting at Level 1: 1.</li>\r\n        </ul>\r\n    </li>\r\n    <li><strong>Starting from the second level:</strong>\r\n        <ul>\r\n            <li>Initial Energy: 5</li>\r\n            <li><strong>Level 2:</strong> Spend <code>layers[1] = 2</code>. Energy left = <code>5 - 2 = 3</code>.\r\n                Since <code>3 >= energy[1] = 3</code>, 1 point is collected. (Total points: 1)</li>\r\n            <li><strong>Level 3:</strong> Current Energy = 3. Spend <code>layers[2] = 5</code>.\r\n                Energy is insufficient (<code>3 < 5</code>). The attack fails and ends.</li>\r\n            <li>Maximum points for starting at Level 2: 1.</li>\r\n        </ul>\r\n    </li>\r\n    <li><strong>Starting from the third level:</strong>\r\n        <ul>\r\n            <li>Initial Energy: 5</li>\r\n            <li><strong>Level 3:</strong> Spend <code>layers[2] = 5</code>. Energy left = <code>5 - 5 = 0</code>.\r\n                Since <code>0 < energy[2] = 1</code>, no point is collected. (Total points: 0)</li>\r\n            <li>Maximum points for starting at Level 3: 0.</li>\r\n        </ul>\r\n    </li>\r\n</ul>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <vector>\n#include <string>\n#include <numeric>\n\nclass Solution {\npublic:\n    std::vector<int> getNumPoints(const std::vector<int>& layers, const std::vector<int>& energy, long int k) {\n        // Core logic goes here\n        int n = layers.size();\n        std::vector<int> result(n);\n        return result;\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    int n_layers;\n    std::cin >> n_layers;\n    std::vector<int> layers(n_layers);\n    for (int i = 0; i < n_layers; ++i) {\n        std::cin >> layers[i];\n    }\n\n    int n_energy;\n    std::cin >> n_energy;\n    std::vector<int> energy(n_energy);\n    for (int i = 0; i < n_energy; ++i) {\n        std::cin >> energy[i];\n    }\n\n    long int k;\n    std::cin >> k;\n\n    Solution sol;\n    std::vector<int> result = sol.getNumPoints(layers, energy, k);\n\n    for (size_t i = 0; i < result.size(); ++i) {\n        std::cout << result[i] << (i == result.size() - 1 ? \"\" : \" \");\n    }\n    std::cout << std::endl;\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "uber_14oct",
        "company_id": 645
    }
]