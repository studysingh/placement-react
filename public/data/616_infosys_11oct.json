[
    {
        "id": 1754,
        "title": "Minimum Cost Grid Path",
        "problem_statement": "<h1>Minimum Cost Grid Path</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>We have a grid with <strong>H</strong> rows and <strong>W</strong> columns, where each square is either <strong>white</strong> or <strong>black</strong>.</p>\r\n<p>For each square at position <code>(i, j)</code> &mdash; the i-th row from the top and j-th column from the left &mdash; the color is represented by <code>A[i][j]</code>:</p>\r\n<ul>\r\n    <li>If <code>A[i][j] = 0</code>, the square is white.</li>\r\n    <li>If <code>A[i][j] = 1</code>, the square is black.</li>\r\n</ul>\r\n<p>You can perform the operations described below any number of times, in any order:</p>\r\n<ul>\r\n    <li><strong>Row Flip:</strong> Choose a row <code>i</code> (<code>1 <= i <= H</code>), pay <code>R[i]</code> yen, and invert the color of every square in that row &mdash; white squares turn black, and black squares turn white.</li>\r\n    <li><strong>Column Flip:</strong> Choose a column <code>j</code> (<code>1 <= j <= W</code>), pay <code>C[j]</code> yen, and invert the color of every square in that column.</li>\r\n</ul>\r\n<p>You need to ensure there's a valid path from the top-left square <code>(1, 1)</code> to the bottom-right square <code>(H, W)</code>. This path should consist <strong>only</strong> of squares that have the <strong>same color</strong>, and you can only move down or right at each step.</p>\r\n<p>Your task is to find the minimum total cost to achieve this.</p>\r\n<p><strong>Note:</strong> It's guaranteed that a solution always exists under the given constraints.</p>\r\n\r\n<h2>Input Format</h2>\r\n<p>The first line contains an integer, <code>N</code>, denoting the number of rows (H).</p>\r\n<p>The next line contains an integer, <code>M</code>, denoting the number of columns (W).</p>\r\n<p>Each line <code>i</code> of the <code>N</code> subsequent lines (where <code>0 <= i < N</code>) contains an integer describing <code>R[i]</code>.</p>\r\n<p>Each line <code>j</code> of the <code>M</code> subsequent lines (where <code>0 <= j < M</code>) contains an integer describing <code>C[j]</code>.</p>\r\n<p>Each line <code>i</code> of the <code>N</code> subsequent lines (where <code>0 <= i < N</code>) contains a string describing <code>A[i]</code> (where <code>A[i][j]</code> is a character '0' or '1').</p>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input:\r\n2\r\n2\r\n1\r\n1\r\n1\r\n1\r\n11\r\nOutput:\r\n0</code></pre>\r\n<p><strong>Explanation:</strong> You already have a path of 1's from (1, 1) to (2, 2).</p>\r\n\r\n<h3>Example 2:</h3>\r\n<pre><code class='language-text'>Input:\r\n2\r\n2\r\n2\r\n2\r\n2\r\n2\r\n01\r\n10\r\nOutput:\r\n4</code></pre>\r\n<p><strong>Explanation:</strong> The path is (1, 1), (1, 2), (2, 2) or (1, 2), (2, 1), (2, 2). The cost will be 2 + 2 = 4.</p>\r\n\r\n<h3>Example 3:</h3>\r\n<pre><code class='language-text'>Input:\r\n2\r\n2\r\n1\r\n1\r\n1\r\n1\r\n10\r\n01\r\nOutput:\r\n2</code></pre>\r\n<p><strong>Explanation:</strong> The path is (1, 1), (1, 2), (2, 2) or (1, 2), (2, 1), (2, 2). The cost will be 1 + 1 = 2.</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>2 <= N <= 1000</code></li>\r\n    <li><code>2 <= M <= 1000</code></li>\r\n    <li><code>1 <= R[i] <= 100</code></li>\r\n    <li><code>1 <= C[j] <= 100</code></li>\r\n    <li><code>len(A[i]) == M</code> for all <code>i</code></li>\r\n</ul>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nclass Solution {\npublic:\n    long long solve(int H, int W, const std::vector<long long>& R, const std::vector<long long>& C, const std::vector<std::string>& A) {\n        // Placeholder for the solution logic\n        return 0;\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    int N, M;\n    std::cin >> N;\n    std::cin >> M;\n\n    std::vector<long long> R(N);\n    for (int i = 0; i < N; ++i) {\n        std::cin >> R[i];\n    }\n\n    std::vector<long long> C(M);\n    for (int i = 0; i < M; ++i) {\n        std::cin >> C[i];\n    }\n\n    std::vector<std::string> A(N);\n    for (int i = 0; i < N; ++i) {\n        std::cin >> A[i];\n    }\n\n    Solution solution;\n    long long result = solution.solve(N, M, R, C, A);\n    std::cout << result << std::endl;\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "infosys_11oct",
        "company_id": 616
    },
    {
        "id": 1755,
        "title": "Funny Jumping Game",
        "problem_statement": "<h1>Funny Jumping Game</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>There is a grid (N rows and M columns) of integers. You want to create a funny jumping game. In this game, you start from any cell (r, c), and you have two options for movement:</p>\r\n<ol>\r\n    <li>Move to a cell (newr, c) where r &lt; newr, if and only if grid[r][c] &gt;= grid[newr][c].</li>\r\n    <li>Move to a cell (r, newc) where c &lt; newc, if and only if grid[r][c] &lt;= grid[r][newc].</li>\r\n</ol>\r\n<p>If you cannot make any move, the game ends.</p>\r\n<ul>\r\n    <li>Define a \"PATH\" as all the cells (r, c) you visited, maintaining the order of visits.</li>\r\n    <li>Define \"A\" as the maximum number of cells that the \"PATH\" can reach.</li>\r\n    <li>Define \"B\" as the number of distinct \"PATH\"s of length \"A\" modulo 10<sup>9</sup> + 7.</li>\r\n</ul>\r\n<p>We say that two paths, path1 and path2, of length \"A\" are different if there exists at least one position K (where 1 &lt;= K &lt;= \"A\") such that the cell at position K in path1 is different from the cell at position K in path2.</p>\r\n<p>Your task is to find the product of \"A\" and \"B\".</p>\r\n\r\n<h3>Input Format:</h3>\r\n<p>The first line contains an integer, N, denoting the number of rows in Grid.</p>\r\n<p>The next line contains an integer, M, denoting the number of columns in Grid.</p>\r\n<p>Each line i of the N subsequent lines (where 0 &lt;= i &lt; N) contains M space separated integers each describing the row Grid[i].</p>\r\n\r\n<h2>Examples</h2>\r\n\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input:\r\n2\r\n2\r\n1 2\r\n2 3\r\nOutput:\r\n4</code></pre>\r\n<p><strong>Explanation:</strong>\r\nmaximum length = 2\r\npaths = 2\r\nProduct A * B = 2 * 2 = 4.</p>\r\n\r\n<h3>Example 2:</h3>\r\n<pre><code class='language-text'>Input:\r\n3\r\n2\r\n1 1\r\n1 1\r\n1 1\r\nOutput:\r\n12</code></pre>\r\n<p><strong>Explanation:</strong>\r\nmaximum length = 4\r\npaths = 3\r\nProduct A * B = 4 * 3 = 12.</p>\r\n\r\n<h3>Example 3:</h3>\r\n<pre><code class='language-text'>Input:\r\n1\r\n6\r\n2 1 3 5 7 5\r\nOutput:\r\n16</code></pre>\r\n<p><strong>Explanation:</strong>\r\nmaximum length = 4\r\npaths = 4\r\nProduct A * B = 4 * 4 = 16.</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li>1 &lt;= N &lt;= 200</li>\r\n    <li>1 &lt;= M &lt;= 50000</li>\r\n    <li>1 &lt;= Grid[i][j] &lt;= 10000</li>\r\n</ul>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <vector>\n#include <string>\n\nclass Solution {\npublic:\n    long long solve(int N, int M, const std::vector<std::vector<int>>& grid) {\n        // Your solution logic goes here\n        return 0;\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    int N;\n    std::cin >> N;\n\n    int M;\n    std::cin >> M;\n\n    std::vector<std::vector<int>> grid(N, std::vector<int>(M));\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < M; ++j) {\n            std::cin >> grid[i][j];\n        }\n    }\n\n    Solution solution;\n    long long result = solution.solve(N, M, grid);\n\n    std::cout << result << std::endl;\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "infosys_11oct",
        "company_id": 616
    }
]