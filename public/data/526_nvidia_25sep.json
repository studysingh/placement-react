[
    {
        "id": 1508,
        "title": "Largest Magical Binary String",
        "problem_statement": "<h1>Largest Magical Binary String</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>Two definitions follow:</p>\r\n<ul>\r\n    <li>A binary string consists of 0's and/or 1's. For example, 01011, 1111, and 00 are binary strings.</li>\r\n    <li>The prefix of a string is any of its substrings that include the beginning of the string. For example, the prefixes of 11010 are 1, 11, 110, 1101, and 11010.</li>\r\n</ul>\r\n<p>A non-empty binary string is <strong>good</strong> if the following two conditions are true:</p>\r\n<ol>\r\n    <li>The number of 0's is equal to the number of 1's.</li>\r\n    <li>For every prefix of the binary string, the number of 1's is not less than the number of 0's.</li>\r\n</ol>\r\n<p>For example, 11010 is not good because it does not have an equal number of 0's and 1's, but 110010 is good because it satisfies both conditions.</p>\r\n<p>A good string can contain multiple good substrings. If two consecutive substrings are good, then they can be swapped as long as the resulting string is still a good string. Given a good binary string, <code>binString</code>, perform zero or more swap operations on its adjacent good substrings such that the resulting string is the largest possible numeric value. Two substrings are adjacent if the last character of the first substring occurs exactly one index before the first character of the second substring.</p>\r\n\r\n<h3>Function Description</h3>\r\n<p>Complete the function <code>largestMagical</code> in the editor below.</p>\r\n\r\n<h3>Function Parameters</h3>\r\n<p><code>str binString</code>: a binary string</p>\r\n\r\n<h3>Returns</h3>\r\n<p><code>str</code>: the largest possible binary value as a string</p>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input: binString = \"11011000\"\r\nOutput: 11100100</code></pre>\r\n<p><strong>Explanation:</strong> Choose two adjacent good substrings to swap: 10 and 1100. The resultant string, str = 11100100.</p>\r\n\r\n<h3>Example 2:</h3>\r\n<pre><code class='language-text'>Input: binString = \"1100\"\r\nOutput: 1100</code></pre>\r\n<p><strong>Explanation:</strong> The only good substring of binString is 1100. No operations can be applied to the string.</p>\r\n\r\n<h3>Example 3:</h3>\r\n<pre><code class='language-text'>Input: binString = \"1101001100\"\r\nOutput: 1101001100</code></pre>\r\n<p><strong>Explanation:</strong> The only consecutive good substrings are 110100 and 1100. Note that 100 is not a good substring because it contains more zeroes than ones. If they are swapped, it results in a lexicographically smaller string. Thus, binString is already the lexicographically largest good string that can be formed.</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li>Each character of <code>binString</code> ∈ {0, 1}.</li>\r\n    <li>1 ≤ |<code>binString</code>| ≤ 50</li>\r\n    <li><code>binString</code> is a good string.</li>\r\n</ul>\r\n\r\n<pre><code class='language-javascript'>\r\n/*\r\n * Complete the 'largestMagical' function below.\r\n *\r\n * The function is expected to return a STRING.\r\n * The function accepts STRING binString as parameter.\r\n */\r\n\r\nstring largestMagical(string binString) {\r\n\r\n}\r\n</code></pre>",
        "google_doc_link": null,
        "solution_code": null,
        "company_name": "nvidia_25sep ",
        "company_id": 526
    },
    {
        "id": 1509,
        "title": "Binary String Power of Two Regex",
        "problem_statement": "<h1>Binary String Power of Two Regex</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>Given a binary string, find a regex that checks whether that binary number when converted to a decimal number is a power of two or not.</p>\r\n<p>Complete the code in the editor below by replacing the blank (i.e., \"_______\") with a regular expression that matches something according to the criterion above. Locked code in the editor prints <strong>True</strong> for each correct match and <strong>False</strong> for each incorrect match.</p>\r\n<p>Input from stdin will be processed as follows and passed to the function.</p>\r\n<p>The first line consists of an integer, n, the number of binary strings to follow. Each of the next n lines contains a string representation of a binary number.</p>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input: s = '0101010'\r\nOutput: False</code></pre>\r\n<p><strong>Explanation:</strong> The binary string '0101010' converts to 42 in decimal, which is not a power of 2. The regex should return a false value.</p>\r\n\r\n<h3>Example 2:</h3>\r\n<pre><code class='language-text'>Input:\r\n4\r\n1000\r\n0100\r\n0010\r\n0110\r\nOutput:\r\nTrue\r\nTrue\r\nTrue\r\nFalse</code></pre>\r\n<p><strong>Explanation:</strong></p>\r\n<ul>\r\n<li>Binary '1000' is 8 in decimal (2³), which is a power of 2.</li>\r\n<li>Binary '0100' is 4 in decimal (2²), which is a power of 2.</li>\r\n<li>Binary '0010' is 2 in decimal (2¹), which is a power of 2.</li>\r\n<li>Binary '0110' is 6 in decimal, which is not a power of 2.</li>\r\n</ul>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n<li>Test strings consist only of ascii characters '0' and '1'.</li>\r\n</ul>",
        "google_doc_link": null,
        "solution_code": null,
        "company_name": "nvidia_25sep ",
        "company_id": 526
    }
]