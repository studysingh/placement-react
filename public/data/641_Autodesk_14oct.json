[
    {
        "id": 1816,
        "title": "Alternating Digit Sum",
        "problem_statement": "<h1>Alternating Digit Sum</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>Given an integer <code>n</code>, your task is to calculate the alternating sum of its digits. In other words, add up all the digits, taking the first digit with a positive sign, the second digit with a negative sign, the third digit with a positive sign, etc.</p>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input: n = 52134\r\nOutput: 5</code></pre>\r\n<p><strong>Explanation:</strong> 5 - 2 + 1 - 3 + 4 = 5</p>\r\n\r\n<h3>Example 2:</h3>\r\n<pre><code class='language-text'>Input: n = 12345\r\nOutput: 3</code></pre>\r\n<p><strong>Explanation:</strong> 1 - 2 + 3 - 4 + 5 = 3</p>\r\n\r\n<h3>Example 3:</h3>\r\n<pre><code class='language-text'>Input: n = 104956\r\nOutput: -5</code></pre>\r\n<p><strong>Explanation:</strong> 1 - 0 + 4 - 9 + 5 - 6 = -5</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><strong>Execution time limit:</strong> 0.5 seconds (cpp)</li>\r\n    <li><strong>Memory limit:</strong> 1 GB</li>\r\n    <li><strong>Input:</strong> integer <code>n</code>\r\n        <ul>\r\n            <li>A positive integer number.</li>\r\n            <li>Guaranteed constraints: <code>1 &le; n &le; 10<sup>9</sup></code></li>\r\n        </ul>\r\n    </li>\r\n    <li><strong>Output:</strong> integer\r\n        <ul>\r\n            <li>The alternating sum of the digits of <code>n</code>.</li>\r\n        </ul>\r\n    </li>\r\n</ul>\r\n\r\n<h2>C++ Syntax Tips</h2>\r\n<pre><code class='language-javascript'>// prints help message to the console\r\n// Returns: \"hello, &lt;name&gt;\"\r\nstring helloWorld(string name) {\r\n  cout &lt;&lt; \"This prints to the console when you run Tests\" &lt;&lt; endl;\r\n  return \"hello, \" + name;\r\n}</code></pre>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nclass Solution {\npublic:\n    int alternatingDigitSum(int n) {\n        // Core logic goes here\n        return 0;\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    int n;\n    std::cin >> n;\n\n    Solution sol;\n    int result = sol.alternatingDigitSum(n);\n\n    std::cout << result << std::endl;\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "Autodesk_14oct",
        "company_id": 641
    },
    {
        "id": 1817,
        "title": "Lexicographically Smallest String After Reversal",
        "problem_statement": "<h1>Lexicographically Smallest String After Reversal</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>Given a string <code>word</code>, you can reverse some of the characters from the beginning or from the end of <code>word</code> to get new strings.</p>\r\n<p>Reversing the first <code>k</code> characters of a string <code>w_0 w_1 ... w_{n-1}</code> (i.e. within <code>[0 ... k-1]</code>) produces <code>w_{k-1} ... w_1 w_0 w_k ... w_{n-1}</code>.</p>\r\n<p>Reversing the last <code>k</code> characters of a string <code>w_0 w_1 ... w_{n-1}</code> (i.e. within <code>[n-k ... n-1]</code>) produces <code>w_0 ... w_{n-k-1} w_{n-1} ... w_{n-k}</code>.</p>\r\n<p>Your task is to iterate over all possible new strings that can be formed by this way, and return the alphabetically smallest one.</p>\r\n<p><strong>Note:</strong> You are not expected to provide the most optimal solution, but a solution with time complexity not worse than <code>O(word.length^3)</code> will fit within the execution time limit.</p>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input: word = \"abdca\"\r\nOutput: \"abdca\"</code></pre>\r\n<p><strong>Explanation:</strong> Let's consider all possible reverse operations:</p>\r\n<ul>\r\n    <li>Reversing the first 1 character results in the following: \"abdca\"</li>\r\n    <li>Reversing the first 2 characters results in the following: \"badca\"</li>\r\n    <li>Reversing the first 3 characters results in the following: \"dbaca\"</li>\r\n    <li>Reversing the first 4 characters results in the following: \"cdaba\"</li>\r\n    <li>Reversing the first 5 characters results in the following: \"acdba\"</li>\r\n    <li>Reversing the last 1 character results in the following: \"abdac\"</li>\r\n    <li>Reversing the last 2 characters results in the following: \"adbca\"</li>\r\n    <li>Reversing the last 3 characters results in the following: \"dbaca\"</li>\r\n    <li>Reversing the last 4 characters results in the following: \"dacab\"</li>\r\n    <li>Reversing the last 5 characters results in the following: \"acabd\"</li>\r\n</ul>\r\n<p>Among these, the alphabetically smallest string is \"abdca\", which should be the final output.</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li>[execution time limit] 0.5 seconds (cpp)</li>\r\n    <li>[memory limit] 1 GB</li>\r\n</ul>\r\n<p><strong>Input:</strong></p>\r\n<ul>\r\n    <li><code>word</code>: A string containing lowercase English letters.</li>\r\n    <li>Guaranteed constraints:\r\n        <ul>\r\n            <li><code>1 <= word.length <= 100</code></li>\r\n        </ul>\r\n    </li>\r\n</ul>\r\n<p><strong>Output:</strong></p>\r\n<ul>\r\n    <li>A string representing the alphabetically smallest string possible after using one of operations described above.</li>\r\n</ul>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nclass Solution {\npublic:\n    std::string findSmallestString(std::string word) {\n        // Your solution logic goes here\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    std::string word;\n    std::cin >> word;\n\n    Solution solution;\n    std::string result = solution.findSmallestString(word);\n\n    std::cout << result << std::endl;\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "Autodesk_14oct",
        "company_id": 641
    },
    {
        "id": 1818,
        "title": "Protein Folding Y-Pattern Transformation",
        "problem_statement": "<h1>Protein Folding Y-Pattern Transformation</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>You are a molecular biologist working in a research laboratory that studies protein folding patterns. You have a square matrix representing a microscopic view of a protein structure, where each cell contains one of three possible molecular states: 0 (inactive), 1 (partially active), or 2 (fully active).</p>\r\n<p>Your research has identified a specific molecular pattern that indicates optimal protein stability - a \"Y-shaped\" molecular pathway. This pattern consists of two diagonal molecular chains extending from the upper-corners down to the center, plus a vertical chain extending downward from the center.</p>\r\n<p>Your task is to determine the minimum number of molecular state changes required to transform the current protein matrix into one that exhibits this stable Y-pattern.</p>\r\n<p>The Y-pattern is achieved when:</p>\r\n<ul>\r\n    <li>all molecular states along the diagonals from the upper-left and upper-right corners down to the center are identical,</li>\r\n    <li>all molecular states along the vertical path from the center downward are identical to the diagonal states,</li>\r\n    <li>all other molecular states (the background) are identical to each other but different from the Y-pattern states.</li>\r\n</ul>\r\n<p>Note: For a square matrix of size <code>n x n</code>, where <code>n</code> is an odd integer and <code>n >= 3</code>, there are exactly 3 possible Y-pattern configurations. The Y-pattern states and background states can be any combination of the three molecular states (0, 1, 2) as long as they are different from each other.</p>\r\n<p>Below, you can see an example of a Y-pattern for a <code>5 x 5</code> matrix.</p>\r\n<p><img src=\"https://i.imgur.com/example-y-pattern.png\" alt=\"Example 5x5 Y-Pattern\" style=\"max-width: 100%;\"></p>\r\n<p>(Note: The image shows a 5x5 grid where cells forming the Y-pattern are orange, and background cells are white. The Y-pattern cells are (0,0), (0,4), (1,1), (1,3), (2,2), (3,2), (4,2) assuming 0-indexed rows and columns.)</p>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input: proteinMatrix = [[0, 0, 2], [1, 2, 0], [0, 2, 0]]\r\nOutput: 2</code></pre>\r\n<p><strong>Explanation:</strong>\r\nThe optimal transformation is to change <code>proteinMatrix[0][0]</code> from <code>0</code> to <code>2</code> and <code>proteinMatrix[1][0]</code> from <code>1</code> to <code>0</code>.\r\nThe <code>2</code>s form the Y-pattern molecular pathway and <code>0</code>s form the background.\r\nThe final matrix is shown below:</p>\r\n<pre><code class='language-text'>proteinMatrix = [\r\n  [2, 0, 2],\r\n  [0, 2, 0],\r\n  [0, 2, 0]\r\n]</code></pre>\r\n\r\n<h3>Example 2:</h3>\r\n<pre><code class='language-text'>Input: proteinMatrix = [[0, 0, 0, 2, 2], [1, 2, 1, 2, 0], [0, 1, 2, 1, 1], [0, 0, 2, 1, 1], [1, 1, 2, 1, 1]]\r\nOutput: 8</code></pre>\r\n<p><strong>Explanation:</strong>\r\nThe <code>2</code>s form the Y-pattern molecular pathway.\r\nThe optimal solution is to change all of the <code>0</code>s (total 8) to <code>1</code>s to create a uniform background.\r\nThe final matrix is shown below:</p>\r\n<pre><code class='language-text'>proteinMatrix = [\r\n  [1, 1, 1, 2, 2],\r\n  [1, 2, 1, 2, 1],\r\n  [1, 1, 2, 1, 1],\r\n  [1, 1, 2, 1, 1],\r\n  [1, 1, 2, 1, 1]\r\n]</code></pre>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><strong>Execution time limit:</strong> 0.5 seconds (cpp)</li>\r\n    <li><strong>Memory limit:</strong> 1 GB</li>\r\n    <li><strong>Input:</strong> <code>array array integer proteinMatrix</code>\r\n        <ul>\r\n            <li>The square matrix is <code>n x n</code> (where <code>n</code> is odd) representing the protein structure, where each cell contains one of three molecular states: 0 (inactive), 1 (partially active), or 2 (fully active).</li>\r\n            <li><code>proteinMatrix.length <= 99</code> (i.e., <code>n <= 99</code>)</li>\r\n            <li><code>n >= 3</code></li>\r\n            <li><code>0 <= proteinMatrix[i][j] <= 2</code></li>\r\n        </ul>\r\n    </li>\r\n    <li><strong>Output:</strong> <code>integer</code>\r\n        <ul>\r\n            <li>The minimum number of molecular state changes required to transform the protein matrix into one that exhibits the stable Y-pattern.</li>\r\n        </ul>\r\n    </li>\r\n</ul>\r\n\r\n<h2>Syntax Tips</h2>\r\n<pre><code class='language-cpp'>int solution(vector&lt;vector&lt;int&gt;&gt; proteinMatrix) {\r\n\r\n}</code></pre>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nvoid setup_io() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n}\n\nclass Solution {\npublic:\n    int solution(std::vector<std::vector<int>>& proteinMatrix) {\n        // Core logic to calculate the minimum number of molecular state changes goes here.\n        return 0;\n    }\n};\n\nint main() {\n    setup_io();\n\n    int n;\n    std::cin >> n;\n\n    std::vector<std::vector<int>> proteinMatrix(n, std::vector<int>(n));\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            std::cin >> proteinMatrix[i][j];\n        }\n    }\n\n    Solution sol;\n    int result = sol.solution(proteinMatrix);\n\n    std::cout << result << std::endl;\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "Autodesk_14oct",
        "company_id": 641
    },
    {
        "id": 1819,
        "title": "Single Digit Difference Pairs",
        "problem_statement": "<h1>Single Digit Difference Pairs</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>In the shadowy corners of the hacker underworld, data isn't just stored in an encrypted with secrets. Among the lines of encrypted entries lies an array of codes. Represented by positive integers, each one a digital fingerprint. Within this array, certain code pairs appear remarkably identical, save for a subtle corruption in a single digit.</p>\r\n<p>You've intercepted this array, and your mission is to uncover how many unique index-pairs (i, j) exist such that i != j, codes[i] and codes[j] are exactly the same length, but differ in precisely one digit.</p>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input: codes = [101, 12, 304, 7, 414, 604, 700, 1]\r\nOutput: 5</code></pre>\r\n<p><strong>Explanation:</strong>\r\n<ul>\r\n    <li>codes[0] = 101 differs from codes[2] = 304 in the first digit.</li>\r\n    <li>codes[0] = 101 differs from codes[4] = 414 in the first digit.</li>\r\n    <li>codes[1] = 12 differs from codes[5] = 604 in the third digit.</li>\r\n    <li>codes[2] = 304 differs from codes[5] = 604 in the first digit.</li>\r\n    <li>codes[3] = 7 differs from codes[7] = 1 in their only digit.</li>\r\n</ul>\r\nOnly pairs with the same number of digits are considered. For example: codes[0] = 404 and codes[1] = 12 are ignored, since they have different lengths (3 vs 2).</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>1 &lt;= codes.length &lt;= 10^4</code></li>\r\n    <li><code>1 &lt;= codes[i] &lt;= 10^9</code></li>\r\n</ul>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nclass Solution {\npublic:\n    int countPairs(const std::vector<int>& codes) {\n        // Core logic goes here\n        return 0;\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    int n;\n    // Reading the size of the array is a common competitive programming pattern,\n    // even if not explicitly stated in the problem description.\n    // We will assume the first input is the number of codes.\n    std::cin >> n;\n\n    std::vector<int> codes(n);\n    for (int i = 0; i < n; ++i) {\n        std::cin >> codes[i];\n    }\n\n    Solution solution;\n    int result = solution.countPairs(codes);\n\n    std::cout << result << std::endl;\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "Autodesk_14oct",
        "company_id": 641
    }
]