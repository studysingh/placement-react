[
    {
        "id": 885,
        "title": "Cool Graph Traversal",
        "problem_statement": "<h1>Cool Graph Traversal</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>You are given an undirected connected graph of <code>g_nodes</code> nodes and <code>M</code> connections. Traverse the graph and store the order of traversal in array <code>A</code>. You need to determine the order of traversal <code>A</code> such that when <code>A</code> is processed by the following algorithm, it produces the lexicographically largest possible array <code>B</code>. Return the resulting array <code>B</code>.</p>\r\n\r\n<p>The algorithm to construct array <code>B</code> from traversal array <code>A</code> is as follows:</p>\r\n<pre><code class='language-javascript'>for (int i = 0; i < A.size(); i++) {\r\n    bool found = 0;\r\n    for (int j = 0; j < B.size(); j++) {\r\n        if (A[i] == B[j]) {\r\n            found = 1;\r\n            break;\r\n        }\r\n    }\r\n    if (!found) {\r\n        B.push_back(A[i]);\r\n    }\r\n}</code></pre>\r\n<p>This algorithm effectively adds elements from <code>A</code> to <code>B</code> only if they are not already present in <code>B</code>, maintaining their first appearance order.</p>\r\n\r\n<p>For example, consider a graph with <code>g_nodes = 5</code> nodes and <code>M = 5</code> edges. Connected pairs are elements of <code>g_from</code> and <code>g_to</code>: (4, 3), (2, 4), (1, 4), (1, 2), (2, 3). An optimal traversal for this graph is <code>4 -> 3 -> 2 -> 1</code>, resulting in array <code>A = [4, 3, 2, 1]</code>. Applying the described algorithm to this <code>A</code> yields <code>B = [4, 3, 2, 1]</code>, which is the largest lexicographically possible array <code>B</code>.</p>\r\n\r\n<p>Complete the function <code>coolGraph</code> in the editor below. The function must return an array representing array <code>B</code>.</p>\r\n\r\n<p><code>coolGraph</code> has the following parameters:</p>\r\n<ul>\r\n    <li><code>int g_nodes</code>: the number of nodes</li>\r\n    <li><code>vector&lt;int&gt; g_from</code>: one end of each connected pair of nodes</li>\r\n    <li><code>vector&lt;int&gt; g_to</code>: the other end of each connected pair of nodes</li>\r\n</ul>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input:\r\ng_nodes = 3, M = 2\r\ng_from = [3, 3], g_to = [1, 2]\r\nOutput: [3, 2, 1]</code></pre>\r\n<p><strong>Explanation:</strong> The graph has 3 nodes and 2 edges: (3,1) and (3,2). A possible optimal traversal order is <code>3 -> 2 -> 3 -> 1</code>, which forms array <code>A = [3, 2, 3, 1]</code>. Applying the algorithm to <code>A</code> results in <code>B = [3, 2, 1]</code>.</p>\r\n\r\n<h3>Example 2:</h3>\r\n<pre><code class='language-text'>Input:\r\ng_nodes = 4, M = 5\r\ng_from = [4, 2, 1, 1, 2], g_to = [3, 4, 4, 2, 3]\r\nOutput: [4, 3, 2, 1]</code></pre>\r\n<p><strong>Explanation:</strong> The graph has 4 nodes and 5 edges: (4,3), (2,4), (1,4), (1,2), (2,3). A possible optimal traversal is <code>4 -> 3 -> 2 -> 1</code>, which forms array <code>A = [4, 3, 2, 1]</code>. Applying the algorithm to <code>A</code> results in <code>B = [4, 3, 2, 1]</code>.</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>1 &lt;= g_nodes &lt;= 10^5</code></li>\r\n    <li><code>1 &lt;= M &lt;= 2 * 10^5</code></li>\r\n    <li><code>1 &lt;= g_from[i], g_to[i] &lt;= g_nodes</code></li>\r\n    <li><code>g_from[i] != g_to[i]</code></li>\r\n    <li><code>g_from[i]</code> and <code>g_to[i]</code> form an undirected edge.</li>\r\n</ul>",
        "google_doc_link": null,
        "solution_code": null,
        "company_name": "Agoda_25july",
        "company_id": 272
    },
    {
        "id": 886,
        "title": "Find Remaining Balls",
        "problem_statement": "```html\r\n<h1>Find Remaining Balls</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>There are N balls placed on a 1-dimensional axis, all moving at the same non-zero speed. For each ball:</p>\r\n<ul>\r\n    <li><code>direction[i]</code> represents the direction (<code>-1</code> for left, <code>1</code> for right)</li>\r\n    <li><code>strength[i]</code> represents the strength of the ball.</li>\r\n</ul>\r\n<p>When two balls collide:</p>\r\n<ul>\r\n    <li>If one ball has higher strength, it destroys the weaker one and continues moving.</li>\r\n    <li>If both have equal strength, both are destroyed.</li>\r\n</ul>\r\n<p>Return the zero-based indices of the balls that remain after all collisions, in ascending order.</p>\r\n\r\n<h2>Function Description</h2>\r\n<p>Complete the function <code>findRemainingBalls</code> in the editor with the following parameter(s):</p>\r\n<ul>\r\n    <li><code>int direction[n]</code>: the directions of the particles in order of their starting relative positions.</li>\r\n    <li><code>int strength[n]</code>: the strengths of the particles.</li>\r\n</ul>\r\n\r\n<h2>Returns</h2>\r\n<p><code>int[]</code>: an integer array that contains the zero-based indices of the remaining balls in ascending order.</p>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input:\r\nN = 3\r\ndirection = [1, -1, 1]\r\nstrength = [3, 1, 1]\r\nOutput: [0]</code></pre>\r\n<p><strong>Explanation:</strong> The first and the third balls are moving right and the second ball is moving left. The first and the second balls will collide at some point and the ball with higher strength, ball 0, remains. The third ball does not collide with any ball.</p>\r\n\r\n<h3>Example 2:</h3>\r\n<pre><code class='language-text'>Input:\r\nN = 2\r\ndirection = [1, 1]\r\nstrength = [3, 4]\r\nOutput: [0, 1]</code></pre>\r\n<p><strong>Explanation:</strong> Both balls are moving to the right at the same speed, so they do not collide.</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>1 <= n <= 10^5</code></li>\r\n    <li><code>direction[i]</code> is either <code>1</code> or <code>-1</code></li>\r\n    <li><code>1 <= strength[i] <= 10^9</code></li>\r\n</ul>\r\n```",
        "google_doc_link": null,
        "solution_code": null,
        "company_name": "Agoda_25july",
        "company_id": 272
    },
    {
        "id": 887,
        "title": "Optimize In-App Upgrades",
        "problem_statement": "<h1>Optimize In-App Upgrades</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>In an Android app, there are <code>n</code> in-app upgrades listed. The cost of the <code>i<sup>th</sup></code> upgrade is given by <code>upgradeCosts[i]</code> and it enhances the app's functionality by a factor of <code>2<sup>i</sup></code>. You are given a limited amount of currency represented by an integer, <code>budget</code>.</p>\r\n<p>Implement a function that selects a combination of upgrades such that the total enhancement is maximized without exceeding the available budget.</p>\r\n<p>The function <code>optimizeInAppUpgrades</code> takes the following inputs:</p>\r\n<ul>\r\n    <li><code>upgradeCosts</code>: an array of integers representing the costs of each in-app upgrade.</li>\r\n    <li><code>budget</code>: an integer representing the in-app currency available to spend.</li>\r\n</ul>\r\n<p>The function should return the maximum enhancement that can be obtained, modulo (10<sup>9</sup> + 7).</p>\r\n<pre><code class='language-cpp'>int optimizeInAppUpgrades(std::vector<int> upgradeCosts, int budget) {\r\n    // Complete the 'optimizeInAppUpgrades' function below.\r\n    // The function is expected to return an INTEGER.\r\n    // The function accepts following parameters:\r\n    //  1. INTEGER_ARRAY upgradeCosts\r\n    //  2. INTEGER budget\r\n}</code></pre>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input: n = 5\r\nupgradeCosts = [10, 20, 14, 40, 60]\r\nbudget = 70</code></pre>\r\n<p><strong>Some valid upgrade combinations are:</strong></p>\r\n<ul>\r\n    <li>Select upgrades 0, 1, and 2 -> total cost = 10 + 20 + 14 = 44 -> enhancement = 2<sup>0</sup> + 2<sup>1</sup> + 2<sup>2</sup> = 1 + 2 + 4 = 7</li>\r\n    <li>Select upgrades 0 and 4 -> cost = 10 + 60 = 70 -> enhancement = 2<sup>0</sup> + 2<sup>4</sup> = 1 + 16 = 17</li>\r\n    <li>Select upgrades 1 and 4 -> cost = 20 + 50 = 70 -> enhancement = 2<sup>1</sup> + 2<sup>4</sup> = 2 + 16 = 18</li>\r\n    <li>Select upgrades 2 and 4 -> cost = 14 + 50 = 64 -> enhancement = 2<sup>2</sup> + 2<sup>4</sup> = 4 + 16 = 20 &lt;- (maximum)</li>\r\n</ul>\r\n<p>Out of all possible combinations, the maximum enhancement that can be obtained is 20, and 20 modulo (10<sup>9</sup> + 7) = 20.</p>\r\n<p>Hence, the answer is 20.</p>\r\n\r\n<h3>Example 2:</h3>\r\n<pre><code class='language-text'>Input: n = 3\r\nupgradeCosts = [3, 4, 1]\r\nbudget = 8\r\nOutput: 7</code></pre>\r\n<p><strong>Explanation:</strong> All the upgrades can be purchased since the total cost is within the developer's allocated budget. The total impact from the selected upgrades would be 2<sup>0</sup> + 2<sup>1</sup> + 2<sup>2</sup> = 7, and 7 modulo (10<sup>9</sup> + 7) = 7.</p>\r\n\r\n<h3>Example 3:</h3>\r\n<pre><code class='language-text'>Input: n = 5\r\nupgradeCosts = [19, 78, 27, 18, 20]\r\nbudget = 25\r\nOutput: 16</code></pre>\r\n<p><strong>Explanation:</strong> The optimal strategy is to purchase only the final upgrade, yielding an impact of 2<sup>4</sup> = 16, and 16 modulo (10<sup>9</sup> + 7) = 16.</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>1 &le; n &le; 10<sup>5</sup></code></li>\r\n    <li><code>1 &le; upgradeCosts[i] &le; 10<sup>9</sup></code></li>\r\n    <li><code>0 &le; budget &le; 10<sup>9</sup></code></li>\r\n</ul>",
        "google_doc_link": null,
        "solution_code": null,
        "company_name": "Agoda_25july",
        "company_id": 272
    },
    {
        "id": 888,
        "title": "Malware Spread Control",
        "problem_statement": "<h1>Malware Spread Control</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>Implement a prototype service for malware spread control in a network.</p>\r\n<p>There are <code>g_nodes</code> servers in a network and <code>g_edges</code> connections between its nodes. The <code>i<sup>th</sup></code> bidirectional connection connects <code>g_from[i]</code> and <code>g_to[i]</code>. Some of the nodes are infected with malware. They are listed in the array <code>malware</code>, where if <code>malware[i] = 1</code> node <code>i</code> is infected, and if <code>malware[i] = 0</code>, node <code>i</code> is not infected.</p>\r\n<p>Any infected node infects other non-infected nodes, which are directly connected. This process goes on until no new infected nodes are possible. Exactly 1 node can be removed from the network. Return the index of the node to remove such that the total infected nodes in the remaining network are minimized. If multiple nodes lead to the same minimum result, then return the one with the lowest index.</p>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input: g_nodes = 9, g_edges = 5, g_from = [1, 2, 4, 6, 7], g_to = [2, 3, 5, 7, 8], malware = [0, 0, 1, 0, 1, 0, 0, 0, 0]\r\nOutput: 3</code></pre>\r\n<p><strong>Explanation:</strong> Initially, nodes [3, 5] are infected. At the end, nodes [1, 2, 3, 4, 5] will be infected. If node 3 is removed, only nodes 4 and 5 are infected, which is the minimum possible. Return 3, the node to remove.</p>\r\n\r\n<h3>Example 2:</h3>\r\n<pre><code class='language-text'>Input:\r\ng_nodes = 5, g_edges = 4\r\ng_from = [1, 2, 3, 4], g_to = [2, 3, 4, 5]\r\nmalware = [1, 1, 1, 1, 1]\r\nOutput: 1</code></pre>\r\n<p><strong>Explanation:</strong> All nodes are infected even after removing any node. Return the lowest index, 1, as the answer.</p>\r\n\r\n<h3>Example 3:</h3>\r\n<pre><code class='language-text'>Input:\r\ng_nodes = 4, g_edges = 2\r\ng_from = [1, 3], g_to = [2, 4]\r\nmalware = [0, 1, 1, 0]\r\nOutput: 2</code></pre>\r\n<p><strong>Explanation:</strong> Removing either node 2 or 3 leads to a total of 2 infected nodes. Node 2 is the lower index.</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n<li><code>1 <= g_nodes <= 10<sup>5</sup></code></li>\r\n<li><code>0 <= g_edges <= min(g_nodes*(g_nodes-1)/2, 10<sup>5</sup>)</code></li>\r\n<li><code>1 <= g_from[i], g_to[i] <= g_nodes</code></li>\r\n<li><code>malware[i] = 0</code> or <code>1</code>.</li>\r\n</ul>\r\n\r\n<h2>Function Description</h2>\r\n<p>Complete the function <code>getNodeToRemove</code> in the editor below.</p>\r\n<pre><code class='language-cpp'>int getNodeToRemove(int g_nodes, vector<int> g_from, vector<int> g_to, vector<int> malware)</code></pre>\r\n<p><code>getNodeToRemove</code> has the following parameter(s):</p>\r\n<ul>\r\n<li><code>int g_nodes</code>: the number of nodes</li>\r\n<li><code>int g_edges</code>: the number of edges</li>\r\n<li><code>int g_from[]</code>: one end of the connections</li>\r\n<li><code>int g_to[]</code>: another end of the connections</li>\r\n<li><code>int malware[]</code>: the affected nodes</li>\r\n</ul>\r\n<p><strong>Returns:</strong></p>\r\n<ul>\r\n<li><code>int</code>: the optimal node to remove</li>\r\n</ul>",
        "google_doc_link": null,
        "solution_code": null,
        "company_name": "Agoda_25july",
        "company_id": 272
    },
    {
        "id": 889,
        "title": "Token Management System",
        "problem_statement": "<h1>Token Management System</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>Implement a session-based authentication system that manages user sessions with unique tokens and configurable time-to-live (TTL) values. Each token has an expiration time calculated by adding its TTL (in seconds) to the creation time. Tokens can be renewed before expiration to extend their validity.</p>\r\n<p>The system must support three operations:</p>\r\n<ul>\r\n    <li><code>generate &lt;token_id&gt; &lt;current_time&gt;</code>: At the current time, creates a new token with the specified ID.</li>\r\n    <li><code>renew &lt;token_id&gt; &lt;current_time&gt;</code>: At the current time, extends an existing, unexpired token's expiration time. The request is ignored if the token has expired or does not exist.</li>\r\n    <li><code>count &lt;current_time&gt;</code>: Returns the number of unexpired tokens at the same timestamp.</li>\r\n</ul>\r\n<p><strong>Important Note:</strong> Token expiration is evaluated before processing any actions at the same timestamp. If a token's expiration time exactly matches the current time, the token is considered expired and cannot be renewed or counted.</p>\r\n\r\n<h2>Function Description</h2>\r\n<p>Complete the <code>getUnexpiredTokens</code> function in the editor with the following parameter(s):</p>\r\n<ul>\r\n    <li><code>int time_to_live</code>: the time to live for a token</li>\r\n    <li><code>string queried[q]</code>: the queries</li>\r\n</ul>\r\n<p><strong>Returns:</strong></p>\r\n<p><code>int[]</code>: the results of the count queries, in the same order as they appear.</p>\r\n<pre><code class='language-cpp'>vector<int> getUnexpiredTokens(int time_to_live, vector<string> queries)</code></pre>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input:\r\ntime_to_live = 5\r\nqueries = [\"generate aaa 1\", \"renew aaa 2\", \"count 6\", \"generate bbb 7\", \"renew aaa 8\", \"count 15\"]\r\nOutput: [1, 0]</code></pre>\r\n<p><strong>Explanation:</strong>\r\nAt <code>t = 6</code>, the only unexpired token is 'aaa'.\r\nAt <code>t = 15</code>, all tokens have expired, so the count of unexpired tokens is 0.</p>\r\n\r\n<h3>Example 2:</h3>\r\n<pre><code class='language-text'>Input:\r\ntime_to_live = 35\r\nqueries = [\"generate token1 3\", \"count 4\", \"generate token2 6\", \"count 7\", \"generate token3 11\", \"count 41\"]\r\nOutput: [1, 2, 1]</code></pre>\r\n<p><strong>Explanation:</strong></p>\r\n<ul>\r\n    <li><strong>Query 1:</strong> <code>generate token1 3</code>. A new token 'token1' is generated at time 3. Its expiration time is 3 + 35 = 38.</li>\r\n    <li><strong>Query 2:</strong> <code>count 4</code>. At time 4, 'token1' is unexpired (expires at 38). Count is 1. Output: 1.</li>\r\n    <li><strong>Query 3:</strong> <code>generate token2 6</code>. A new token 'token2' is generated at time 6. Its expiration time is 6 + 35 = 41.</li>\r\n    <li><strong>Query 4:</strong> <code>count 7</code>. At time 7, 'token1' (expires 38) and 'token2' (expires 41) are both unexpired. Count is 2. Output: 2.</li>\r\n    <li><strong>Query 5:</strong> <code>generate token3 11</code>. A new token 'token3' is generated at time 11. Its expiration time is 11 + 35 = 46.</li>\r\n    <li><strong>Query 6:</strong> <code>count 41</code>.\r\n        <ul>\r\n            <li>'token1' (expires 38) is expired because 41 &gt; 38.</li>\r\n            <li>'token2' (expires 41) is expired because 41 exactly matches its expiration time (due to the \"Important Note\").</li>\r\n            <li>'token3' (expires 46) is unexpired because 41 &lt; 46.</li>\r\n        </ul>\r\n        Count is 1. Output: 1.\r\n    </li>\r\n</ul>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>1 &le; q &le; 100000</code></li>\r\n    <li><code>1 &le; |queries| &le; 10<sup>5</sup></code></li>\r\n    <li><code>1 &le; time_to_live &le; 10<sup>8</sup></code></li>\r\n    <li><code>1 &le; current_time &le; 10<sup>8</sup></code></li>\r\n    <li><code>1 &le; length of token_id &le; 10</code></li>\r\n    <li><code>token_id</code> consists only of lowercase letters and numbers.</li>\r\n    <li>All queries of type <code>generate</code> will contain unique values of <code>token_id</code>.</li>\r\n    <li><code>current_time</code> is in non-decreasing order in the queries.</li>\r\n</ul>",
        "google_doc_link": null,
        "solution_code": null,
        "company_name": "Agoda_25july",
        "company_id": 272
    }
]