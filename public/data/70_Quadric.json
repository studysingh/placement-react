[
    {
        "id": 267,
        "title": "Node Commoning in Function Call Graph",
        "problem_statement": "<div class=\\\"problem-container\\\">\n    <div class=\\\"problem-header\\\">\n        <h2>Node Commoning in Function Call Graph</h2>\n    </div>\n\n    <div class=\\\"problem-description\\\">\n        <p>You are given a directed graph that represents an execution of function Calls and their operands. The data structure for the graph including an example is given in the following code snippet. Your goal is to implement the \\\"node_commoning\\\" function that performs Node commoning. The function should find all common chains of Calls/Nodes and transform the graph so that each of these identical set of Calls/Nodes are extracted and occur just once in the output graph (instead of multiple times).</p>\n        <p>Submit your solution as a zip file that includes a file called node_commoning.py.</p>\n    </div>\n\n    <div class=\\\"initial-code\\\">\n        <h3>Initial Code Structure</h3>\n        <pre class=\\\"python\\\">class Call:\n    def __init__(self, op):\n        self._op = op\n        self._operand = []\n        \n    def __call__(self, *n):\n        self._operand.extend(list(n))\n        return self\n        \ndef print_graph(call, done={}):\n    if call not in done:\n        args = []\n        for n in call._operand:\n            args.append(print_graph(n, done))\n        done[call] = len(done)+1\n        print(f\\\"%{done[call]} = {call._op}\\\"+(\\\"\\\" if not args else \\\"(%\\\"+\\\"%\\\".join(str(item) for item in args)+\\\")\\\"))\n    return done[call]\n\ndef node_commoning(call):\n    # write your implementation here\n    pass</pre>\n    </div>\n\n    <div class=\\\"examples\\\">\n        <h3>Example</h3>\n        <div class=\\\"example\\\">\n            <h4>Input Graph:</h4>\n            <pre class=\\\"input\\\">%1 = I()\n%2 = A(%1)\n%3 = B(%2)\n%4 = C(%3)\n%5 = A(%1)\n%6 = B(%5)\n%7 = D(%6)\n%8 = Z(%4,%7)</pre>\n\n            <h4>Output Graph (after node A and node B have been commoned):</h4>\n            <pre class=\\\"output\\\">%1 = I()\n%2 = A(%1)\n%3 = B(%2)\n%4 = C(%3)\n%5 = D(%3)\n%6 = Z(%4,%5)</pre>\n\n            <div class=\\\"example-code\\\">\n                <h4>Example Usage:</h4>\n                <pre class=\\\"python\\\"># Example Input Graph\ninput = Call(\\'I\\')\nc = Call(\\'C\\')(Call(\\'B\\')(Call(\\'A\\')(input)))\nd = Call(\\'D\\')(Call(\\'B\\')(Call(\\'A\\')(input)))\noutput = Call(\\'Z\\')(c, d)\nprint_graph(output)\n\n# Apply node commoning\nmod_call = node_commoning(output)\nprint_graph(mod_call)</pre>\n            </div>\n        </div>\n    </div>\n\n    <div class=\\\"submission-requirements\\\">\n        <h3>Submission Requirements</h3>\n        <ul>\n            <li>Submit a ZIP file containing node_commoning.py</li>\n            <li>File size must not exceed 100 MB when uncompressed</li>\n            <li>ZIP file must not be password-protected</li>\n            <li>Implement the node_commoning function that takes a Call object as input and returns the modified Call object</li>\n        </ul>\n    </div>\n</div>",
        "google_doc_link": "https://docs.google.com/document/d/1cVfnG_jwwgqMqqMH2BR43FNN0yHl_yJWe042eZqoPco/edit?usp=sharing",
        "solution_code": "",
        "company_name": "Quadric",
        "company_id": 70
    }
]