[
    {
        "id": 1764,
        "title": "Robot Run",
        "problem_statement": "<h1>Robot Run</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>You're given a 2D plane of size N * N and a set of coins placed on random points of that plane. You have built a robot named Samuel which can identify the coins placed on the plane and grab them for you. The only problem with Samuel is that he can only walk in a straight line. You can configure Samuel's direction such that he can grab you the maximum number of coins possible. You can configure him to start from any point on the plane.</p>\r\n\r\n<p><strong>Input Format:</strong></p>\r\n<p>The first line of input contains 2 integers N and Q, where N * N will be the size of the plane and Q will be the number of coins which are placed on the plane. The next Q lines contain 2 integers X and Y each representing the position of a coin on the plane. (X,Y) will be the coordinates representation of the coin placement.</p>\r\n\r\n<p><strong>Output Format:</strong></p>\r\n<p>Return the maximum number of coins that Samuel can grab for you.</p>\r\n\r\n<h2>Note</h2>\r\n<p>Each point on the plane can either contain one coin or none.</p>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input:\r\n5 6\r\n1 1\r\n3 2\r\n5 3\r\n4 1\r\n2 3\r\n1 4\r\nOutput:\r\n4</code></pre>\r\n<p><strong>Explanation:</strong> there are multiple directions that you can choose, but to get the maximum coins from the plane on a straight line, you should choose [(1,4), (2,3), (3,2), (4,1)].</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n<li>1 &lt;= N &lt;= 10<sup>4</sup></li>\r\n<li>1 &lt;= Q &lt;= 1000</li>\r\n<li>0 &lt;= X<sub>i</sub>, Y<sub>i</sub> &lt;= N</li>\r\n</ul>\r\n\r\n<h2>Additional Information</h2>\r\n<p>Your code must be able to print the sample output from the provided sample input. However, your code is run against multiple hidden test cases. Therefore, your code must pass these hidden test cases to solve the problem statement.</p>\r\n\r\n<p><strong>Limits:</strong></p>\r\n<ul>\r\n<li>Time Limit: 5.0 sec(s) for each input file</li>\r\n<li>Memory Limit: 256 MB</li>\r\n<li>Source Limit: 1024 KB</li>\r\n</ul>\r\n\r\n<p><strong>Scoring:</strong></p>\r\n<p>Score is assigned if any testcase passes</p>\r\n\r\n<p><strong>Allowed Languages:</strong></p>\r\n<p>Bash, C, C++14, C++17, Clojure, C#, D, Erlang, F#, Go, Groovy, Haskell, Java 8, Java 14, Java 17, JavaScript(Node.js), Julia, Kotlin, Lisp (SBCL), Lua, Objective-C, OCaml, Octave, Pascal, Perl, PHP, Python, Python 3, Python 3.8, R(RScript), Racket, Ruby, Rust, Scala, Swift, TypeScript, Visual Basic</p>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <vector>\n#include <utility>\n\nclass Solution {\npublic:\n    int solve(int N, int Q, const std::vector<std::pair<int, int>>& coins) {\n        // Core logic to find the maximum number of collinear points goes here.\n        return 0;\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    int N, Q;\n    std::cin >> N >> Q;\n\n    std::vector<std::pair<int, int>> coins(Q);\n    for (int i = 0; i < Q; ++i) {\n        std::cin >> coins[i].first >> coins[i].second;\n    }\n\n    Solution solution;\n    int result = solution.solve(N, Q, coins);\n\n    std::cout << result << std::endl;\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "Sprinklr_11oct",
        "company_id": 619
    },
    {
        "id": 1765,
        "title": "Gambler's Dice",
        "problem_statement": "<h1>Gambler's Dice</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>You are given an n-ary perfect tree with k levels. You need to mark each node of this tree with a number on dice such that the resulting tree is Gambler Friendly.</p>\r\n<p>A tree is Gambler Friendly if the following holds:</p>\r\n<p>For every node of tree, let's say it is marked with a number p (1 &lt;= p &lt;= 6), then every adjacent node of this tree is marked with a number q that is adjacent to p on dice. (i.e. p and q are adjacent on dice and p != q)</p>\r\n<p><strong>Note:</strong> A number is not adjacent to itself on dice.</p>\r\n<p>You need to calculate the number of possible ways to paint the tree such that it is Gambler Friendly. Since the number can be very large, print it modulo 10<sup>9</sup> + 7.</p>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input: 3 3\r\nOutput: 100663296</code></pre>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li>2 &lt;= n &lt;= 10<sup>5</sup></li>\r\n    <li>1 &lt;= k &lt;= 10<sup>5</sup></li>\r\n</ul>\r\n\r\n<p><strong>Input Format:</strong> 2 space separated integers, n and k</p>\r\n<p><strong>Note for reference:</strong> Following is a perfect binary tree with 4 levels.</p>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <vector>\n#include <string>\n\nclass Solution {\npublic:\n    long long solve(long long n, long long k) {\n        // Core logic to be implemented here.\n        return 0;\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    long long n, k;\n    std::cin >> n >> k;\n\n    Solution sol;\n    long long result = sol.solve(n, k);\n\n    std::cout << result << std::endl;\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "Sprinklr_11oct",
        "company_id": 619
    }
]