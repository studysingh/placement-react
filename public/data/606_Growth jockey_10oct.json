[
    {
        "id": 1727,
        "title": "GrowthJockey Task Workflow",
        "problem_statement": "<h1>GrowthJockey Task Workflow</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>GrowthJockey's engineering platform manages a massive workflow of 10<sup>9</sup> task nodes, numbered from 1 to 10<sup>9</sup>. Each task node is either complete (black) or pending (white). Initially, there are <code>m</code> distinct completed tasks: <code>a_1, a_2, ..., a_m</code>. All other tasks are still pending. You are given a sequence of commands that GrowthJockey's automation engine will execute. Each command can be of two types:</p>\r\n<ul>\r\n    <li><strong>A</strong> -- Move to the next task (<code>x + 1</code>)</li>\r\n    <li><strong>B</strong> -- Skip to the nearest pending (white) task to the right</li>\r\n</ul>\r\n<p>For each command prefix <code>i</code> (from 1 to <code>n</code>), a new worker starts at task 1. The worker executes the first <code>i</code> commands from the string. The worker marks the last visited task as complete (black). Your job is to find out which task nodes are black after all workers finish their execution.</p>\r\n\r\n<h2>Input</h2>\r\n<p>The first line contains an integer <code>t</code> — the number of test cases. Each test case consists of:</p>\r\n<ul>\r\n    <li>Two integers <code>n</code> and <code>m</code> — the number of commands and initially completed tasks.</li>\r\n    <li>A string <code>s</code> of length <code>n</code>, containing only the characters 'A' and 'B'.</li>\r\n    <li>A line of <code>m</code> integers <code>a_1, a_2, ..., a_m</code> (<code>1 <= a_i <= 10<sup>9</sup></code>) — the indices of initially black (completed) tasks.</li>\r\n</ul>\r\n\r\n<h2>Output</h2>\r\n<p>For each test case:</p>\r\n<ul>\r\n    <li>On the first line, print <code>k</code> — the total number of black tasks at the end.</li>\r\n    <li>On the second line, print the indices of all black tasks in increasing order.</li>\r\n</ul>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input:\r\n1\r\n3 2\r\nABB\r\n1 3\r\nOutput:\r\n4\r\n1 2 3 4</code></pre>\r\n<p><strong>Explanation:</strong></p>\r\n<ul>\r\n    <li>Worker 1 -> moves to 2 -> blackens 2</li>\r\n    <li>Worker 2 -> skips to next white (3) -> blackens 3</li>\r\n    <li>Worker 3 -> skips again to next white (4) -> blackens 4</li>\r\n    <li>Initially, 1 and 3 were black -> total black tasks = {1, 2, 3, 4}</li>\r\n</ul>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li>Task nodes are numbered from 1 to 10<sup>9</sup>.</li>\r\n    <li><code>a_i</code> (indices of initially black tasks) are between 1 and 10<sup>9</sup> (inclusive).</li>\r\n    <li>The command string <code>s</code> contains only characters 'A' and 'B'.</li>\r\n</ul>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n\nclass Solution {\npublic:\n    std::vector<long long> solve(int n, int m, const std::string& s, const std::vector<long long>& a) {\n        // Core logic to determine the final set of black tasks goes here.\n        // The initial set of black tasks is in vector 'a'.\n        // You need to simulate n workers, each executing a prefix of the command string 's'.\n        // Worker i executes s[0...i-1].\n        // After simulation, return all black task indices in increasing order.\n        \n        return {}; // Placeholder return\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n    int t;\n    std::cin >> t;\n    while (t--) {\n        int n, m;\n        std::cin >> n >> m;\n        std::string s;\n        std::cin >> s;\n        std::vector<long long> a(m);\n        for (int i = 0; i < m; ++i) {\n            std::cin >> a[i];\n        }\n\n        Solution solution;\n        std::vector<long long> result = solution.solve(n, m, s, a);\n\n        std::cout << result.size() << \"\\n\";\n        for (size_t i = 0; i < result.size(); ++i) {\n            std::cout << result[i] << (i == result.size() - 1 ? \"\" : \" \");\n        }\n        std::cout << \"\\n\";\n    }\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "Growth jockey_10oct",
        "company_id": 606
    },
    {
        "id": 1728,
        "title": "Minimum Operations to Achieve MEX k",
        "problem_statement": "<h1>Minimum Operations to Achieve MEX k</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>GrowthJockey's Data Engineering team is analyzing sprints where each feature task has an associated tag ID.</p>\r\n<p>You are given an array <code>a</code> of length <code>n</code>, where each element represents a feature tag ID (from 0 to n).</p>\r\n<p>You're also given a target number <code>k</code>, which represents the desired MEX — the smallest non-negative integer not present in the array.</p>\r\n<p>In one operation, the team can reassign any one task's tag (change any element <code>a[i]</code>) to any value in the range <code>[0, n]</code>.</p>\r\n<p>Your goal is to determine the minimum number of such operations required so that the array's MEX becomes exactly equal to <code>k</code>.</p>\r\n\r\n<h2>Definition</h2>\r\n<p>MEX(a) = the smallest non-negative integer that is not present in <code>a</code>.</p>\r\n\r\n<h2>Input</h2>\r\n<p>Each test contains multiple test cases. The first line contains an integer <code>t</code> — the number of test cases. For each test case:</p>\r\n<ul>\r\n    <li>The first line contains two integers <code>n</code> and <code>k</code> — the length of the array and the required MEX(a).</li>\r\n    <li>The second line contains <code>n</code> integers <code>a_1, a_2, ..., a_n</code> (0 ≤ <code>a_i</code> ≤ <code>n</code>) — the array elements.</li>\r\n</ul>\r\n\r\n<h2>Output</h2>\r\n<p>For each test case, print a single integer — the minimum number of operations required to make MEX(a) = <code>k</code>.</p>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input:\r\n1 0\r\n0\r\nOutput:\r\n1</code></pre>\r\n<p><strong>Explanation:</strong> In the first test, array = [0]. Its MEX = 1. To make MEX = 0, we remove 0 (replace it with any number > 0). So 1 operation.</p>\r\n\r\n<h3>Example 2:</h3>\r\n<pre><code class='language-text'>Input:\r\n3 1\r\n0 2 3\r\nOutput:\r\n0</code></pre>\r\n<p><strong>Explanation:</strong> In the second test, [0, 2, 3] already has MEX = 1. No changes required.</p>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <numeric>\n#include <set>\n#include <map>\n\nclass Solution {\npublic:\n    int solve(int n, int k, const std::vector<int>& a) {\n        // Core logic to determine the minimum operations goes here.\n        return 0;\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    int t;\n    std::cin >> t;\n    while (t--) {\n        int n, k;\n        std::cin >> n >> k;\n        std::vector<int> a(n);\n        for (int i = 0; i < n; ++i) {\n            std::cin >> a[i];\n        }\n\n        Solution solution;\n        int result = solution.solve(n, k, a);\n        std::cout << result << std::endl;\n    }\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "Growth jockey_10oct",
        "company_id": 606
    }
]