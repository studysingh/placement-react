[
    {
        "id": 1643,
        "title": "Maximum Coins in a Grid Path",
        "problem_statement": "<h1>Maximum Coins in a Grid Path</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>In a new online game, players navigate a 2 x n matrix (2 rows, n columns) where each cell initially contains a certain number of coins. The number of coins in a cell increases over time - at time t, the cell at position (i, j) contains <code>t * coins[i][j]</code> coins.</p>\r\n\r\n<p>A player must:</p>\r\n<ul>\r\n    <li>Start from position (0, 0) at time t = 0</li>\r\n    <li>Move to a neighboring cell in one unit of time</li>\r\n    <li>Visit each cell exactly once</li>\r\n    <li>Collect all coins in visited cells</li>\r\n</ul>\r\n<p>Determine the maximum number of coins a player can collect.</p>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<p><strong>Input:</strong></p>\r\n<pre><code class='language-text'>n = 4\r\ncoins = [[1, 4, 3, 2], [2, 1, 3, 2]]</code></pre>\r\n<p><strong>Optimal path (as shown in image) and coins collected based on input <code>coins</code> array:</strong></p>\r\n<pre><code class='language-text'>Time (t) | Cell   | coins[i][j] | Collected (t * coins[i][j])\r\n---------|--------|-------------|----------------------------\r\n0        | (0,0)  | 1           | 0 * 1 = 0\r\n1        | (1,0)  | 2           | 1 * 2 = 2\r\n2        | (1,1)  | 1           | 2 * 1 = 2\r\n3        | (0,1)  | 4           | 3 * 4 = 12\r\n4        | (0,2)  | 3           | 4 * 3 = 12\r\n5        | (1,2)  | 3           | 5 * 3 = 15\r\n6        | (0,3)  | 2           | 6 * 2 = 12\r\n7        | (1,3)  | 2           | 7 * 2 = 14</code></pre>\r\n<p><strong>Explanation:</strong> The sum of coins collected for this path is 0 + 2 + 2 + 12 + 12 + 15 + 12 + 14 = 69.</p>\r\n<p><em>Note: The problem statement's original example table showed different collected coin values (summing to 77), implying a different initial <code>coins</code> array was used for its calculation. This explanation uses the explicitly provided <code>coins</code> array for consistency.</em></p>\r\n\r\n<h3>Example 2:</h3>\r\n<p><strong>Input:</strong></p>\r\n<pre><code class='language-text'>n = 2\r\ncoins = [[1, 3], [4, 2]]</code></pre>\r\n<p><strong>Output:</strong></p>\r\n<pre><code class='language-text'>19</code></pre>\r\n<p><strong>Explanation:</strong> The optimal path is (0,0) to (0,1), (0,1) to (1,1), (1,1) to (1,0). The number of coins collected is 0 * 1 + 1 * 3 + 2 * 2 + 3 * 4 = 19.</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>1 <= n <= 10<sup>5</sup></code></li>\r\n    <li><code>1 <= coins[i][j] <= 10<sup>5</sup></code></li>\r\n</ul>\r\n\r\n<h2>Function Description</h2>\r\n<p>Complete the <code>getMaxCoins</code> function in the editor.\r\n<code>getMaxCoins</code> has the following parameter(s):</p>\r\n<ul>\r\n    <li><code>int coins_rows</code>: The number of rows in the matrix (always 2).</li>\r\n    <li><code>int coins_columns</code>: The number of columns in the matrix (<code>n</code>).</li>\r\n    <li><code>int** coins</code>: The initial number of coins in the matrix.</li>\r\n</ul>\r\n\r\n<h2>Returns</h2>\r\n<ul>\r\n    <li><code>long</code>: the maximum number of coins that can be collected.</li>\r\n</ul>\r\n\r\n<h2>Input Format for Custom Testing</h2>\r\n<pre><code class='language-text'>STDIN   FUNCTION\r\n-----   --------\r\n2       -> n = 2 (coins_columns)\r\n2       -> mat[][] size n = 2 (coins_columns)\r\n1 3     -> mat = [[1, 3],\r\n4 2     ->        [4, 2]]</code></pre>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nvoid setup_io() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n}\n\nclass Solution {\npublic:\n    long long getMaxCoins(int n, std::vector<std::vector<int>>& coins) {\n        // Core logic to solve the problem goes here.\n        return 0;\n    }\n};\n\nint main() {\n    setup_io();\n\n    int n;\n    std::cin >> n;\n\n    std::vector<std::vector<int>> coins(2, std::vector<int>(n));\n    for (int i = 0; i < 2; ++i) {\n        for (int j = 0; j < n; ++j) {\n            std::cin >> coins[i][j];\n        }\n    }\n\n    Solution sol;\n    long long result = sol.getMaxCoins(n, coins);\n\n    std::cout << result << std::endl;\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "Publicis Sapient_27sept",
        "company_id": 573
    },
    {
        "id": 1644,
        "title": "Maximum Profit Subarray with Length Constraint",
        "problem_statement": "<h1>Maximum Profit Subarray with Length Constraint</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>You need to analyze the performance of investments in a stock. The profit and loss (P&L) for each month are provided, where each value indicates the profit earned (positive value) or loss incurred (negative value) in that month.</p>\r\n<p>Your task is to find the maximum net profit that can be gained from any contiguous segment of months, with the constraint that the segment cannot exceed a given number of months k.</p>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<p><code>n = 6</code></p>\r\n<p><code>pnl = [3, -2, 2, 8]</code></p>\r\n<p><code>k = 4</code></p>\r\n<p><strong>Explanation:</strong> The optimal subarray is <code>[3, -2, 2, 8]</code> with a total profit of <code>3 + (-2) + 2 + 8 = 11</code>. While the subarray <code>[4, 3, -2, 7]</code> has a higher profit of 12, its length exceeds the constraint k=4. The answer is 8.</p>\r\n\r\n<h2>Function Description</h2>\r\n<p>Complete the function <code>getMaxProfit</code> below.</p>\r\n<p>The function is expected to return a <code>LONG_INTEGER</code>.</p>\r\n<p>The function accepts the following parameters:</p>\r\n<ul>\r\n    <li><code>1. INTEGER pnl_count</code></li>\r\n    <li><code>2. INTEGER_ARRAY pnl</code></li>\r\n    <li><code>3. INTEGER k</code></li>\r\n</ul>\r\n<pre><code class='language-text'>long getMaxProfit(int pnl_count, int* pnl, int k)</code></pre>\r\n\r\n<h3>Returns</h3>\r\n<p><code>long</code>: the sum of a contiguous subarray of size <code>k</code> or less that has the largest sum</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>1 &lt;= n &lt;= 2 * 10^5</code></li>\r\n    <li><code>-10^9 &lt;= pnl[i] &lt;= 10^9</code></li>\r\n    <li><code>1 &lt;= k &lt;= n</code></li>\r\n</ul>\r\n\r\n<h2>Sample Cases</h2>\r\n<h3>Sample Case 0:</h3>\r\n<pre><code class='language-text'>Input:\r\nn = 7\r\npnl = [4, 3, -2, 7]\r\nk = 5\r\nOutput: 15</code></pre>\r\n<p><strong>Explanation:</strong> We can select the subarray <code>[3, -2, 7]</code> with a sum of <code>15</code> and size <code>6</code>, which is equal to <code>k</code>.</p>\r\n\r\n<h3>Sample Case 1:</h3>\r\n<pre><code class='language-text'>Input:\r\nn = 8\r\npnl = [2, 5, -7, 8]\r\nk = 5\r\nOutput: 8</code></pre>\r\n<p><strong>Explanation:</strong> We can select the subarray <code>[2, 5, -7, 8]</code> with a sum of <code>8</code> and size <code>4</code>, which is less than <code>k</code>.</p>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <climits>\n\nclass Solution {\npublic:\n    /**\n     * @brief Finds the maximum profit from a contiguous subarray with length at most k.\n     * \n     * @param n The number of months (size of the pnl array).\n     * @param pnl A vector of long longs representing the profit/loss for each month.\n     * @param k The maximum allowed length of the subarray.\n     * @return A long long representing the maximum possible profit.\n     */\n    long long getMaxProfit(int n, const std::vector<long long>& pnl, int k) {\n        // Your solution logic goes here\n        \n        return 0; // Placeholder return\n    }\n};\n\nint main() {\n    // Fast I/O\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    int n;\n    std::cin >> n;\n\n    std::vector<long long> pnl(n);\n    for (int i = 0; i < n; ++i) {\n        std::cin >> pnl[i];\n    }\n\n    int k;\n    std::cin >> k;\n\n    Solution solution;\n    long long result = solution.getMaxProfit(n, pnl, k);\n\n    std::cout << result << std::endl;\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "Publicis Sapient_27sept",
        "company_id": 573
    },
    {
        "id": 1645,
        "title": "Maximize Text Score",
        "problem_statement": "<h1>Maximize Text Score</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>You are given three strings: <code>text</code>, <code>prefixString</code>, and <code>suffixString</code>.</p>\r\n<p>Your task is to find a non-empty substring of <code>text</code> that maximizes a value called <code>textScore</code>.</p>\r\n<p>The <code>textScore</code> of a substring is defined as:</p>\r\n<ul>\r\n    <li><code>prefixScore</code>: the length of the longest string <code>P</code> such that <code>P</code> is a suffix of <code>prefixString</code> and also a prefix of the substring.</li>\r\n    <li><code>suffixScore</code>: the length of the longest string <code>S</code> such that <code>S</code> is a prefix of <code>suffixString</code> and also a suffix of the substring.</li>\r\n</ul>\r\n<p><code>textScore = prefixScore + suffixScore</code>.</p>\r\n<p>If multiple substrings achieve the maximum <code>textScore</code>, return the lexicographically smallest one.</p>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input: text = \"nothing\", prefixString = \"bruno\", suffixString = \"ingenious\"\r\nOutput: \"nothing\"</code></pre>\r\n<p><strong>Explanation:</strong></p>\r\n<p>Consider the substring \"nothing\":</p>\r\n<ul>\r\n    <li>\"no\" is a suffix of \"bruno\" and also a prefix of \"nothing\", so <code>prefixScore = 2</code>.</li>\r\n    <li>\"ing\" is a prefix of \"ingenious\" and also a suffix of \"nothing\", so <code>suffixScore = 3</code>.</li>\r\n</ul>\r\n<p><code>textScore = 2 + 3 = 5</code>.</p>\r\n<p>This is the highest score possible, so the answer is \"nothing\".</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li>Strings consist of lowercase English letters (a-z).</li>\r\n    <li><code>1 &le; |text|, |prefixString|, |suffixString| &le; 50</code>.</li>\r\n    <li>It is guaranteed that at least one substring of <code>text</code> contributes positively (matches at least one suffix of <code>prefixString</code> or one prefix of <code>suffixString</code>).</li>\r\n</ul>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nclass Solution {\npublic:\n    std::string maximizeTextScore(const std::string& text, const std::string& prefixString, const std::string& suffixString) {\n        // TODO: Implement the solution logic here\n        return \"\";\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    std::string text;\n    std::string prefixString;\n    std::string suffixString;\n\n    std::cin >> text >> prefixString >> suffixString;\n\n    Solution solution;\n    std::string result = solution.maximizeTextScore(text, prefixString, suffixString);\n\n    std::cout << result << std::endl;\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "Publicis Sapient_27sept",
        "company_id": 573
    },
    {
        "id": 1646,
        "title": "Minimum Swaps to Arrange Even Before Odd",
        "problem_statement": "<h1>Minimum Swaps to Arrange Even Before Odd</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>You are given an array of integers. In one move, you can swap the elements at any two indices.</p>\r\n<p>Your task is to rearrange the array so that:</p>\r\n<ul>\r\n    <li>All even numbers appear before all odd numbers.</li>\r\n    <li>The relative order among even numbers or among odd numbers does not matter.</li>\r\n</ul>\r\n<p>You need to determine the minimum number of moves required to achieve this arrangement.</p>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input: arr = [4, 13, 10, 21, 20]\r\nOutput: 1</code></pre>\r\n<p><strong>Explanation:</strong> Array = [13, 10, 21, 20]<br>Swap 13 (odd) with 20 (even) -> [20, 10, 21, 13].<br>Only 1 move is required.</p>\r\n\r\n<h3>Example 2:</h3>\r\n<pre><code class='language-text'>Input: arr = [5, 8, 5, 11, 4, 6]\r\nOutput: 2</code></pre>\r\n<p><strong>Explanation:</strong> Array = [8, 5, 11, 4, 6]<br>Swap 5 (odd) with 4 (even) -> [8, 4, 11, 5, 6].<br>Swap 11 (odd) with 6 (even) -> [8, 4, 6, 5, 11].<br>A valid arrangement is obtained in 2 moves, which is minimal.</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li>2 <= n <= 10^5</li>\r\n    <li>1 <= a[i] <= 10^9</li>\r\n    <li>The array always contains at least one even and one odd element.</li>\r\n</ul>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <numeric>\n\nclass Solution {\npublic:\n    int minSwaps(std::vector<int>& arr) {\n        // Core logic to find the minimum swaps goes here.\n        return 0;\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    int n;\n    std::cin >> n;\n    std::vector<int> arr(n);\n    for (int i = 0; i < n; ++i) {\n        std::cin >> arr[i];\n    }\n\n    Solution solution;\n    int result = solution.minSwaps(arr);\n\n    std::cout << result << std::endl;\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "Publicis Sapient_27sept",
        "company_id": 573
    }
]