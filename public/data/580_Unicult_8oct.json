[
    {
        "id": 1661,
        "title": "NodeJS: Authentication using JWT",
        "problem_statement": "<h1>NodeJS: Authentication using JWT</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>Implement a REST API to manage authentication using JWT (JSON Web Token).</p>\r\n<p>The task is to implement an Auth API using User model which exposes the following:</p>\r\n\r\n<h3>POST request to /login</h3>\r\n<ul>\r\n    <li>Creates a new JWT every time</li>\r\n    <li>Expects a username and password of the user in the request body</li>\r\n    <li>Checks if the username and password are correct from the DB</li>\r\n    <li>Stores the JWT in the User table</li>\r\n    <li>The response code is 200 on the successful token creation, and the response body is the JWT token</li>\r\n</ul>\r\n\r\n<h3>POST request to /validate</h3>\r\n<ul>\r\n    <li>Decodes the JWT</li>\r\n    <li>Expects the JWT in the request body</li>\r\n    <li>The response code is 200 on the successful token decode, and the response body is the username of the user</li>\r\n</ul>\r\n\r\n<h3>User Model</h3>\r\n<ul>\r\n    <li><strong>id:</strong> The unique id of the user (Integer)</li>\r\n    <li><strong>username:</strong> The unique username of the user (String)</li>\r\n    <li><strong>password:</strong> The password of the user (String)</li>\r\n    <li><strong>token:</strong> The latest JWT (String)</li>\r\n</ul>\r\n\r\n<h3>Notes</h3>\r\n<ul>\r\n    <li>Replace the newly created JWT with the older one in the User table.</li>\r\n    <li>Encode the username and current timestamp in the JWT body like the following -\r\n<pre><code class='language-text'>{\r\n  username: &lt;username&gt;,\r\n  timestamp: &lt;current_timestamp&gt;\r\n}</code></pre>\r\n    </li>\r\n    <li>Use Sequelize ORM to fetch/update User data.</li>\r\n    <li>Get the secret of JWT from the .env file programmatically.</li>\r\n</ul>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1: POST /login</h3>\r\n<p><strong>Request Body:</strong></p>\r\n<pre><code class='language-text'>{\r\n  \"username\": \"Jarvisporter\",\r\n  \"password\": \"myfewsord\"\r\n}</code></pre>\r\n<p><strong>Response Body:</strong></p>\r\n<pre><code class='language-text'>{\r\n  \"token\": \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6IkphcnZpc3BvcnRlciIsInRpbWVzdGFtcCI6MTY3ODg4NjQwMCwiYXRfaWQiOiIxMjM0NTY3ODkwIn0.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkphcnZpc3BvcnRlciIsImlhdCI6MTUxNjIzOTAyMn0.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c\"\r\n}</code></pre>\r\n\r\n<h3>Example 2: POST /validate</h3>\r\n<p><strong>Request Body:</strong></p>\r\n<pre><code class='language-text'>{\r\n  \"token\": \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6IkphcnZpc3BvcnRlciIsInRpbWVzdGFtcCI6MTY3ODg4NjQwMCwiYXRfaWQiOiIxMjM0NTY3ODkwIn0.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkphcnZpc3BvcnRlciIsImlhdCI6MTUxNjIzOTAyMn0.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c\"\r\n}</code></pre>\r\n<p><strong>Response Body:</strong></p>\r\n<pre><code class='language-text'>{\r\n  \"username\": \"Jarvisporter\"\r\n}</code></pre>\r\n\r\n<h2>Constraints</h2>\r\n<h3>Environment</h3>\r\n<ul>\r\n    <li>Node Version: V14(LTS)</li>\r\n    <li>Default Port: 8000</li>\r\n</ul>\r\n\r\n<h3>Read-only files:</h3>\r\n<ul>\r\n    <li>test/spec.js</li>\r\n    <li>fixtures/data.json</li>\r\n    <li>connection.js</li>\r\n    <li>seed.js</li>\r\n    <li>models/users.js</li>\r\n</ul>\r\n\r\n<h3>Software Instructions</h3>\r\n<p>The question(s) requires Node 14 LTS or above.</p>\r\n<ul>\r\n    <li><a href=\"#\">Download & Install Node.js</a></li>\r\n</ul>\r\n\r\n<h3>Git Instructions</h3>\r\n<p>Use the following commands to work with this project</p>\r\n<pre><code class='language-text'>npm start</code></pre>\r\n<pre><code class='language-text'>npm test</code></pre>\r\n<pre><code class='language-text'>npm install</code></pre>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n\nstruct Request {\n    std::string type;\n    std::vector<std::string> params;\n};\n\nclass Solution {\npublic:\n    std::vector<std::string> solve(const std::vector<Request>& requests) {\n        // Core logic for handling authentication and validation goes here.\n        // This would involve simulating a user database and JWT operations.\n        std::vector<std::string> results;\n        results.resize(requests.size());\n        // Placeholder implementation\n        for (size_t i = 0; i < requests.size(); ++i) {\n            if (requests[i].type == \"login\") {\n                results[i] = \"{\\\"token\\\":\\\"placeholder_token\\\"}\";\n            } else if (requests[i].type == \"validate\") {\n                results[i] = \"{\\\"username\\\":\\\"placeholder_username\\\"}\";\n            }\n        }\n        return results;\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    // The problem describes a REST API, not a standard stdin/stdout format.\n    // We will simulate the API calls by reading a series of queries.\n    // Assumed input format:\n    // First line: An integer Q, the number of requests.\n    // Next Q lines: Each line is a request, e.g.,\n    // \"login <username> <password>\"\n    // \"validate <token>\"\n    \n    int q;\n    // Reading number of queries, if provided. If not, this part can be adapted.\n    // For this boilerplate, we assume the number of queries is given.\n    std::string first_line;\n    if (std::getline(std::cin, first_line)) {\n        try {\n            q = std::stoi(first_line);\n        } catch (const std::invalid_argument& e) {\n            // If the first line is not a number, assume it's the first query.\n            q = 1; \n            std::vector<Request> requests;\n            std::stringstream ss(first_line);\n            std::string type;\n            ss >> type;\n            Request req;\n            req.type = type;\n            std::string param;\n            while (ss >> param) {\n                req.params.push_back(param);\n            }\n            requests.push_back(req);\n            \n            // Read remaining q-1 queries\n            for (int i = 0; i < q - 1; ++i) {\n                 // This part is left empty as the logic depends on the exact format\n            }\n\n            Solution solution;\n            std::vector<std::string> results = solution.solve(requests);\n            for (const auto& res : results) {\n                std::cout << res << std::endl;\n            }\n            return 0;\n        }\n    } else {\n        return 0; // No input\n    }\n\n\n    std::vector<Request> requests;\n    for (int i = 0; i < q; ++i) {\n        std::string line;\n        std::getline(std::cin, line);\n        if (line.empty()) {\n            i--;\n            continue;\n        }\n        \n        std::stringstream ss(line);\n        std::string type;\n        ss >> type;\n        \n        Request req;\n        req.type = type;\n        \n        std::string param;\n        while (ss >> param) {\n            req.params.push_back(param);\n        }\n        requests.push_back(req);\n    }\n\n    Solution solution;\n    std::vector<std::string> results = solution.solve(requests);\n\n    for (const auto& res : results) {\n        std::cout << res << std::endl;\n    }\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "Unicult_8oct",
        "company_id": 580
    },
    {
        "id": 1662,
        "title": "Reporting Feature Design",
        "problem_statement": "<h1>Reporting Feature Design</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>You are tasked with building a reporting feature for an e-commerce admin dashboard. The goal is to display the top 5 customers based on total spending. The report should include each customer's name, email, total amount spent, total number of orders, and a list of their 3 most recent orders (with order ID, amount, and date). Using MongoDB and Node.js, explain how you would approach this task.</p>\r\n<p>In your answer, describe:</p>\r\n\r\n<h2>Follow-up</h2>\r\n<ul>\r\n    <li>The structure of the collections involved (e.g., users, orders) and any assumptions you made.</li>\r\n    <li>The steps involved in constructing the MongoDB aggregation pipeline to meet the reporting requirements.</li>\r\n    <li>Challenges you encountered or anticipated, especially around aggregation complexity (e.g., nested sorting, $lookup, $group, $slice).</li>\r\n    <li>How you validated and tested your pipeline during development.</li>\r\n    <li>Did you use AI? Why or why not? And how?</li>\r\n</ul>\r\n<p>Your response should demonstrate both your understanding of MongoDB's aggregation framework and your ability to problem solve real problems.</p>\r\n\r\n<h1>React Component Output</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>What is the output of this component?</p>\r\n\r\n<pre><code class='language-javascript'>export default class Clock extends React.Component {\r\n  constructor() {\r\n    super();\r\n    this.state = {time: new Date()};\r\n  }\r\n\r\n  componentDidMount() {\r\n    this.setState({ time: \"Time never changes\" });\r\n  }\r\n\r\n  render() {\r\n    return &lt;h1&gt;Look at the time: {this.state.time}&lt;/h1&gt;;\r\n  }\r\n}</code></pre>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n\n// It seems the problem statement provided is not a standard competitive programming problem.\n// It describes a system design task involving MongoDB and Node.js, and a React question.\n// Based on the title \"Reporting Feature Design\" and the goal \"display the top 5 customers based on total spending\",\n// I have created a boilerplate for a plausible competitive programming problem with the following interpretation:\n//\n// Input:\n// - Number of customers, N.\n// - N lines of customer data (ID, name).\n// - Number of orders, M.\n// - M lines of order data (order ID, customer ID, amount).\n//\n// Task:\n// - Calculate the total spending for each customer.\n// - Find the top 5 customers with the highest total spending.\n//\n// Output:\n// - The names of the top 5 customers.\n\nvoid setup_io() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n}\n\nclass Solution {\npublic:\n    /**\n     * @brief Finds the top 5 customers based on total spending.\n     * \n     * @param customer_info A map from customer ID to customer name.\n     * @param customer_spending A map from customer ID to their total spending.\n     * @return A vector of strings containing the names of the top 5 customers,\n     *         ordered by spending (descending) and then by customer ID (ascending).\n     */\n    std::vector<std::string> findTopCustomers(\n        const std::map<int, std::string>& customer_info,\n        const std::map<int, long long>& customer_spending) {\n        \n        // --- Core logic to be implemented here ---\n        // 1. Create a temporary data structure (e.g., vector of structs/pairs) \n        //    to hold customer ID and their total spending.\n        // 2. Populate this structure from the input maps.\n        // 3. Sort the structure based on the criteria:\n        //    - Primarily by total spending in descending order.\n        //    - As a tie-breaker, by customer ID in ascending order.\n        // 4. Extract the top 5 customer IDs (or fewer if there are less than 5 customers).\n        // 5. Use the customer_info map to get the names corresponding to these IDs.\n        // 6. Return the vector of names.\n        \n        return {}; // Placeholder return\n    }\n};\n\nint main() {\n    setup_io();\n\n    int n; // Number of customers\n    std::cin >> n;\n\n    std::map<int, std::string> customer_info;\n    for (int i = 0; i < n; ++i) {\n        int id;\n        std::string name;\n        std::cin >> id >> name;\n        customer_info[id] = name;\n    }\n\n    int m; // Number of orders\n    std::cin >> m;\n\n    std::map<int, long long> customer_spending;\n    for (int i = 0; i < m; ++i) {\n        int order_id, customer_id;\n        long long amount;\n        std::cin >> order_id >> customer_id >> amount;\n        customer_spending[customer_id] += amount;\n    }\n\n    Solution solution;\n    std::vector<std::string> top_customers = solution.findTopCustomers(customer_info, customer_spending);\n\n    for (const auto& name : top_customers) {\n        std::cout << name << \"\\n\";\n    }\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "Unicult_8oct",
        "company_id": 580
    },
    {
        "id": 1663,
        "title": "NodeJS: Stock Trades API",
        "problem_statement": "<h1>NodeJS: Stock Trades API</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>In this challenge, you will implement a REST API to manage a collection of stock trades.</p>\r\n<p>Every trade is a JSON object with the following properties:</p>\r\n<ul>\r\n    <li><strong>id:</strong> Unique trade identifier (integer)</li>\r\n    <li><strong>type:</strong> Trade type, either 'buy' or 'sell' (String)</li>\r\n    <li><strong>user_id:</strong> Unique user identifier (Integer)</li>\r\n    <li><strong>symbol:</strong> Stock symbol (String)</li>\r\n    <li><strong>shares:</strong> Number of shares traded, between 10 and 30 inclusive (Integer)</li>\r\n    <li><strong>price:</strong> Price per share at trade time (Integer)</li>\r\n    <li><strong>timestamp:</strong> Epoch time of the trade in milliseconds (Integer)</li>\r\n</ul>\r\n<p>The model implementation is provided and read-only. It includes a Timestamp field of DateTime type that must be serialized to/from JSON's integer timestamp.</p>\r\n<p>Implement a REST service exposing the <code>/trades</code> endpoint with these features:</p>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example Trade Object:</h3>\r\n<pre><code class='language-text'>{\r\n    \"id\": 1,\r\n    \"type\": \"buy\",\r\n    \"user_id\": 1,\r\n    \"symbol\": \"ABC\",\r\n    \"shares\": 30,\r\n    \"price\": 130,\r\n    \"timestamp\": 1531522781000\r\n}</code></pre>\r\n\r\n<h2>API Endpoints</h2>\r\n<ul>\r\n    <li>\r\n        <p><strong>POST request to <code>/trades</code></strong></p>\r\n        <ul>\r\n            <li>Creates a new trade.</li>\r\n            <li>Expects a JSON trade object without an <code>id</code> property.</li>\r\n            <li>Adds the trade to the collection and assigns a unique integer ID (starting from 1).</li>\r\n            <li>Returns status code 201 with the created trade object.</li>\r\n        </ul>\r\n    </li>\r\n    <li>\r\n        <p><strong>GET request to <code>/trades</code></strong></p>\r\n        <ul>\r\n            <li>Returns all trades.</li>\r\n            <li>Returns status code 200 with an array of all trades ordered by id (ascending).</li>\r\n            <li>Optionally accepts query parameters <code>type</code> and <code>user_id</code> (e.g., <code>/trades?type=buy&user_id=123</code>).</li>\r\n            <li>When parameters are present, returns only matching objects.</li>\r\n        </ul>\r\n    </li>\r\n    <li>\r\n        <p><strong>GET request to <code>/trades/:id</code></strong></p>\r\n        <ul>\r\n            <li>Returns a trade with the given <code>id</code>.</li>\r\n            <li>If found, returns status code 200 with the matching trade object.</li>\r\n            <li>If not found, returns status code 404 with text \"ID not found\".</li>\r\n        </ul>\r\n    </li>\r\n    <li>\r\n        <p><strong>DELETE, PUT, PATCH requests to <code>/trades/</code></strong></p>\r\n        <ul>\r\n            <li>Returns status code 405 (method not allowed).</li>\r\n        </ul>\r\n    </li>\r\n</ul>\r\n<p>Complete the project to pass all unit tests. The project supports SQLite3 database by default.</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>id</code> must be a unique integer.</li>\r\n    <li><code>type</code> must be either 'buy' or 'sell'.</li>\r\n    <li><code>user_id</code> must be an integer.</li>\r\n    <li><code>symbol</code> must be a string.</li>\r\n    <li><code>shares</code> must be an integer between 10 and 30, inclusive.</li>\r\n    <li><code>price</code> must be an integer.</li>\r\n    <li><code>timestamp</code> must be an integer representing epoch time in milliseconds.</li>\r\n</ul>\r\n\r\n<h2>Git Instructions</h2>\r\n<p>Use the following commands to work with this project:</p>\r\n<ul>\r\n    <li>\r\n        <pre><code class='language-text'>npm start</code></pre>\r\n    </li>\r\n    <li>\r\n        <pre><code class='language-text'>npm test</code></pre>\r\n    </li>\r\n    <li>\r\n        <pre><code class='language-text'>npm install</code></pre>\r\n    </li>\r\n</ul>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <map>\n#include <algorithm>\n\n// The problem describes a REST API, not a standard competitive programming problem.\n// This boilerplate assumes an input format that simulates the API calls, where\n// each line of input is a single command.\n// For example:\n// POST buy 123 ABC 30 130 1531522781000\n// GET\n// GET_ID 1\n// GET_FILTER type buy user_id 123\n\nstruct Trade {\n    int id;\n    std::string type;\n    int user_id;\n    std::string symbol;\n    int shares;\n    int price;\n    long long timestamp;\n};\n\nclass Solution {\npublic:\n    /**\n     * @brief Processes a series of simulated API queries.\n     * @param queries A vector of strings, where each string is a command.\n     * @return A vector of strings representing the output for each query.\n     */\n    std::vector<std::string> process_api_calls(const std::vector<std::string>& queries) {\n        // Core logic to simulate the REST API will go here.\n        // This will involve parsing each query string, maintaining a state\n        // (e.g., a map of trades), and generating output strings for each command.\n        \n        // Placeholder implementation\n        std::vector<std::string> results;\n        // for (const auto& query : queries) {\n        //     // process query and push result to `results`\n        // }\n        return results;\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    std::vector<std::string> queries;\n    std::string line;\n    while (std::getline(std::cin, line)) {\n        if (line.empty()) {\n            break;\n        }\n        queries.push_back(line);\n    }\n\n    Solution solution;\n    std::vector<std::string> results = solution.process_api_calls(queries);\n\n    for (const auto& res : results) {\n        std::cout << res << std::endl;\n    }\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "Unicult_8oct",
        "company_id": 580
    }
]