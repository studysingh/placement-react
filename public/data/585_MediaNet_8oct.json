[
    {
        "id": 1677,
        "title": "Fruits on Tree",
        "problem_statement": "<h1>Fruits on Tree</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>Given a complete rooted tree with N nodes numbered 1 to N. This tree has its leaves at the top and root at the bottom. A complete tree is a tree which has all its leaf at the same level.</p>\r\n<p>There are some fruits on every leaf of the tree and in order to get all the fruits you have to shake the tree any number of times.</p>\r\n<p>But this tree is a little different than the rest it has following properties:</p>\r\n<ul>\r\n    <li>Every node has its capacity value that represents the number of fruits a node can hold at any moment.</li>\r\n    <li>Only one fruit Falls from each node to its parent node in one Shake.</li>\r\n    <li>If a number of fruits at a node is more than its Capacity then excess fruits(greater than Capacity) on that node at that instant will fall to the ground. This process happens instantly, no shake required.</li>\r\n</ul>\r\n<p>The tree is rooted at 1. You may assume that root is one level above ground so all fruits which fall from root lands on the ground.</p>\r\n<p>You have to find the minimum number of shakes you have to perform such that all the fruits are on the ground.</p>\r\n\r\n<h2>Input Format</h2>\r\n<p>First argument is an integer array A of size N where A[i] denotes the number of fruits on i<sup>th</sup> node.</p>\r\n<p>Second argument is an integer array B of size N where B[i] denotes the capacity of i<sup>th</sup> node.</p>\r\n<p>Third argument is a 2D array C of size (N-1) x 2 denotes edges in the tree. There is an edge between nodes C[i][0] and C[i][1].</p>\r\n\r\n<h2>Output Format</h2>\r\n<p>Return an integer denoting the minimum number of shakes you have to perform such that all the fruits are on the ground.</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>1 &lt;= N &lt;= 10<sup>5</sup></code></li>\r\n    <li><code>1 &lt;= A[i],B[i] &lt;= 10<sup>9</sup></code></li>\r\n    <li><code>1 &lt;= C[i][0],C[i][1] &lt;= N</code></li>\r\n    <li><code>A[i] = 0</code> for non-leaf nodes</li>\r\n    <li>Initially, <code>A[i] &lt;= B[i]</code></li>\r\n</ul>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input: A = [0, 0, 0, 1, 1, 2], B = [1, 1, 1, 1, 1, 2], C = [[1, 2], [1, 3], [2, 5], [2, 6], [3, 4]]\r\nOutput: 4</code></pre>\r\n<p><strong>Explanation:</strong></p>\r\n<p>Given Tree:</p>\r\n<pre><code class='language-text'>6(2) 5(1) 4(1)\r\n\\ | /\r\n \\ 2 3\r\n  \\|/\r\n   1\r\n</code></pre>\r\n<p>Ground: ________</p>\r\n<p>Leaf nodes are (6, 5, 4).</p>\r\n<p>Now after one shake:</p>\r\n<pre><code class='language-text'>6(1) 5(0) 4(0)\r\n\\ | /\r\n(1)2 3(1)\r\n \\|/\r\n  v 1\r\n</code></pre>\r\n<p>Ground: 1</p>\r\n<p>Capacity of node 2 is 1, so the excess fruit i.e. will fall on the ground as shown.</p>\r\n<p>After second shake:</p>\r\n<pre><code class='language-text'>6(0) 5(0) 4(0)\r\n\\ | /\r\n(1)2 3(0)\r\n \\|/\r\n  1 (1)\r\n</code></pre>\r\n<p>Ground: 2</p>\r\n<p>This time there will be excess(i.e 2) fruit at node 1. So one fruit will fall to ground.</p>\r\n<p>Now, 2 more shakes required to fall all 4 fruits on ground. So total shakes will be 4.</p>\r\n\r\n<h3>Example 2:</h3>\r\n<pre><code class='language-text'>Input: A = [0, 0, 0, 5, 5], B = [10, 3, 10, 10], C = [[1, 2], [2, 3], [2, 4]]\r\nOutput: 9</code></pre>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nclass Solution {\npublic:\n    long long solve(std::vector<long long>& A, std::vector<long long>& B, std::vector<std::vector<int>>& C) {\n        // Core logic goes here\n        return 0;\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    int n;\n    // Reading N, the number of nodes.\n    // The problem statement implies N can be derived from the size of A.\n    // For a standalone program, we read N first.\n    // Let's assume the first line of input is N.\n    // Based on Example 1, N=6. Based on Example 2, N=4 (assuming typo in A's size).\n    // We will read N to size the vectors.\n    std::cin >> n;\n\n    std::vector<long long> A(n);\n    for (int i = 0; i < n; ++i) {\n        std::cin >> A[i];\n    }\n\n    std::vector<long long> B(n);\n    for (int i = 0; i < n; ++i) {\n        std::cin >> B[i];\n    }\n\n    // There are N-1 edges in a tree with N nodes.\n    std::vector<std::vector<int>> C(n - 1, std::vector<int>(2));\n    for (int i = 0; i < n - 1; ++i) {\n        std::cin >> C[i][0] >> C[i][1];\n    }\n\n    Solution solution;\n    long long result = solution.solve(A, B, C);\n\n    std::cout << result << std::endl;\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "MediaNet_8oct",
        "company_id": 585
    },
    {
        "id": 1678,
        "title": "Damaged Roads",
        "problem_statement": "<h1>Damaged Roads</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>You are the Prime Minister of a country and once you went for a world tour.</p>\r\n<p>After 5 years, when you returned to your country, you were shocked to see the condition of the roads between the cities. So, you plan to repair them, but you cannot afford to spend a lot of money.</p>\r\n<p>The country can be represented as a N x M grid, where Country[i][j] is a city.</p>\r\n<p>The cost of repairing a road between (i,j) and (i+1,j) is A[i]. The cost of repairing a road between (i,j) and (i,j+1) is B[j].</p>\r\n<p>Return the minimum cost of repairing the roads.</p>\r\n<p>As the cost can be large, return the cost modulo 10<sup>9</sup>+7.</p>\r\n\r\n<p><strong>Input Format:</strong></p>\r\n<p>The first argument will be an integer array, A, of size N.<br>The second argument will be an integer array, B, of size M.</p>\r\n\r\n<p><strong>Output Format:</strong></p>\r\n<p>Return an integer representing the minimum possible cost.</p>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input:\r\nA = [1, 1, 1]\r\nB = [1, 1, 2]\r\nOutput: 16</code></pre>\r\n\r\n<h3>Example 2:</h3>\r\n<pre><code class='language-text'>Input:\r\nA = [1, 2, 3]\r\nB = [4, 5, 6]\r\nOutput: 39</code></pre>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>1 &lt;= N, M &lt;= 1e5</code></li>\r\n    <li><code>1 &lt;= A[i], B[i] &lt;= 1e3</code></li>\r\n</ul>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <numeric>\n\nclass Solution {\npublic:\n    int solve(std::vector<int>& A, std::vector<int>& B) {\n        // Core logic to be implemented here.\n        return 0;\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    int n;\n    std::cin >> n;\n    std::vector<int> A(n);\n    for (int i = 0; i < n; ++i) {\n        std::cin >> A[i];\n    }\n\n    int m;\n    std::cin >> m;\n    std::vector<int> B(m);\n    for (int i = 0; i < m; ++i) {\n        std::cin >> B[i];\n    }\n\n    Solution sol;\n    int result = sol.solve(A, B);\n    std::cout << result << std::endl;\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "MediaNet_8oct",
        "company_id": 585
    },
    {
        "id": 1679,
        "title": "Omega Prime Subsets",
        "problem_statement": "<h1>Omega Prime Subsets</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>Carl is bored of playing with ordinary prime numbers. Thus, he comes up with some special numbers called Omega Primes.</p>\r\n<p>A number X is called Omega Prime, if there exists no perfect square Y (Y > 1) such that Y divides X.</p>\r\n<p>For example, 6 is an Omega Prime because there is no perfect square except 1 that divides 6.</p>\r\n<p>On the other hand, 12 is not an Omega Prime as 4 (which is a perfect square) is a divisor of 12.</p>\r\n<p>Carl decides to play a bit more with Omega Primes. He has an array A of integers. Carl wants to find the number of different subsets such that the product of elements in each subset is an Omega Prime. Help Carl find this number.</p>\r\n<p>The input consists of an integer array <code>A</code>.</p>\r\n<p>Since the number of subsets can be large, return the answer modulo 10<sup>9</sup> + 7.</p>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input: A = [2, 4, 3]\r\nOutput: 3</code></pre>\r\n<p><strong>Explanation:</strong> The full explanation text for this example is cut off in the provided image.</p>\r\n\r\n<h3>Example 2:</h3>\r\n<pre><code class='language-text'>Input: A = [2, 2, 2]\r\nOutput: 3</code></pre>\r\n<p><strong>Explanation:</strong> The full explanation text for this example is cut off in the provided image.</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li>1 &lt;= Length of A &lt;= 2 * 10<sup>4</sup></li>\r\n    <li>1 &lt;= A[i] &lt;= 30</li>\r\n</ul>\r\n\r\n<p>Here is the function signature you need to implement:</p>\r\n<pre><code class='language-javascript'>int Solution::findOmegas(vector&lt;int&gt; &amp;A) {\r\n}</code></pre>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nclass Solution {\npublic:\n    /**\n     * @param A: The integer array\n     * @return: The number of Omega Prime subsets\n     */\n    int findOmegas(std::vector<int> &A);\n};\n\nint Solution::findOmegas(std::vector<int> &A) {\n    // Core logic to find the number of Omega Prime subsets goes here.\n    // The result should be modulo 10^9 + 7.\n    return 0; // Placeholder return\n}\n\n// This main function is provided for local testing purposes.\n// On the judging platform, you might only need to implement the Solution class.\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    // The problem description implies a single array as input.\n    // A common format is to first provide the size of the array,\n    // followed by the array elements.\n    int n;\n    std::cin >> n;\n    std::vector<int> A(n);\n    for (int i = 0; i < n; ++i) {\n        std::cin >> A[i];\n    }\n\n    Solution sol;\n    int result = sol.findOmegas(A);\n\n    std::cout << result << std::endl;\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "MediaNet_8oct",
        "company_id": 585
    }
]