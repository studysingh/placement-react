[
    {
        "id": 1346,
        "title": "Optimal Candy Collection",
        "problem_statement": "```html\r\n<h1>Optimal Candy Collection</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>Given a tree of N nodes and N - 1 edges rooted at node 1, with exactly one candy placed at each node. Let's say the cost of the candy placed on the i<sup>th</sup> node is A<sub>i</sub>. You have K amount of money. Now, you will choose exactly one node (say u) and will start buying the candies placed on the path from node u to the root until you run out of money, that is, first, you will buy the candy placed at node u, then the candy placed at the ancestor of u, then its ancestor and so on until you run out of money or you reach the root node. Also, you cannot skip over a node without buying the candy placed at that node.</p>\r\n<p>Calculate the maximum number of candies in a given amount of money you can buy by choosing exactly one starting node.</p>\r\n\r\n<p><strong>Notes</strong></p>\r\n<ul>\r\n    <li>A graph is connected if, for each pair of nodes u and v, there exists a path between these two nodes in the graph.</li>\r\n    <li>A tree is a connected graph with N nodes and N - 1 edges.</li>\r\n</ul>\r\n\r\n<h3>Function description</h3>\r\n<p>Complete the <code>solve</code> function. This function takes the following 4 parameters and returns an integer:</p>\r\n<ul>\r\n    <li><em>N</em>: Represents the number of nodes in the tree</li>\r\n    <li><em>K</em>: Represents the amount of money you have</li>\r\n    <li><em>A</em>: Represents the cost of candies placed on nodes</li>\r\n    <li><em>Edges</em>: Represents a 2D array representing the edges (u, v) in the tree</li>\r\n</ul>\r\n\r\n<h3>Input format for custom testing</h3>\r\n<p><strong>Note:</strong> Use this input format if you are testing against custom input or writing code in a language where we don't provide boilerplate code.</p>\r\n<ul>\r\n    <li>The first line contains T, which represents the number of test cases.</li>\r\n    <li>For each Test case:\r\n        <ul>\r\n            <li>The first line contains an integer N denoting the number of nodes in the tree.</li>\r\n            <li>The second line contains an integer K denoting the amount of money you have.</li>\r\n            <li>The next line contains N space-separated integers denoting the cost of the candy placed at the i<sup>th</sup> node.</li>\r\n            <li>The next N-1 lines contain two space-separated integers u and v denoting that there is an edge between u and v.</li>\r\n        </ul>\r\n    </li>\r\n</ul>\r\n\r\n<h3>Output format</h3>\r\n<p>For each test case in a new line, return the maximum number of candies you can buy in the given amount of money by choosing exactly one starting node.</p>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'><strong>Input:</strong>\r\n2\r\n6\r\n10\r\n4 12 3 2 5 3\r\n1 2\r\n1 3\r\n3 4\r\n3 5\r\n5 6\r\n3\r\n5\r\n3 2 4\r\n1 2\r\n2 3\r\n\r\n<strong>Output:</strong>\r\n3\r\n2\r\n</code></pre>\r\n<p><strong>Explanation:</strong></p>\r\n<p>The first line contains the number of test cases, T = 2.</p>\r\n<p><strong>The first test case</strong></p>\r\n<p>Given:</p>\r\n<ul>\r\n    <li>N = 6</li>\r\n    <li>K = 10</li>\r\n    <li>Edges = [[1, 2], [1, 3], [3, 4], [3, 5], [5, 6]]</li>\r\n    <li>A = [4, 12, 3, 2, 5, 3]</li>\r\n</ul>\r\n<p>Let's start from each node and find out how many candies we can buy:</p>\r\n<ul>\r\n    <li>For node 1, you can buy the candy placed at node 1. Total candies bought = 1.</li>\r\n    <li>For node 2, you cannot even buy the candy placed at node 2. Total candies bought = 0.</li>\r\n    <li>For node 3, you can buy the candy placed at node 3 and you are left with 10 - 3 = 7 amount of money. Now, you can move to its ancestor, i.e. 1, buy its candy since we have enough money. Remaining money = 7 - 4 = 3. You are now at the root itself, so you stop here. Total candies bought = 2.</li>\r\n    <li>For node 4, you can buy the candy placed at node 4 and you are left with 10 - 2 = 8 amount of money. Now, you can move to its ancestor, i.e. 3, buy its candy since you have enough money. Remaining money = 8 - 3 = 5. Now, you move to its ancestor, i.e. 1, buy its candy since you have enough money. Remaining money = 5 - 4 = 1. You are now at the root itself, so you stop here. Total candies bought = 3.</li>\r\n    <li>For node 5, you can buy the candy placed at node 5 and you are left with 10 - 5 = 5 amount of money. Now, you can move to its ancestor, i.e. 3, buy its candy since you have enough money. Remaining money = 5 - 3 = 2. Now, you move to its ancestor, i.e. 1, you cannot buy its candy since you don't have enough money, so you stop. Total candies bought = 2.</li>\r\n    <li>For node 6, you can buy the candy placed at node 6 and you are left with 10 - 3 = 7 amount of money. Now, you can move to its ancestor, i.e. 5, buy its candy since you have enough money. Remaining money = 7 - 5 = 2. Now, you move to its ancestor, i.e. 3, you cannot buy its candy since you don't have enough money, so you stop. Total candies bought = 2.</li>\r\n</ul>\r\n<p>Therefore, if started from node 4, then you can buy the maximum number of candies which is 3 in this case.</p>\r\n\r\n<p><strong>The second test case</strong></p>\r\n<p>Given:</p>\r\n<ul>\r\n    <li>N = 3</li>\r\n    <li>K = 5</li>\r\n    <li>Edges = [[1, 2], [2, 3]]</li>\r\n    <li>A = [3, 2, 4]</li>\r\n</ul>\r\n<p>Let's start from each node and find out how many candies we can buy:</p>\r\n<ul>\r\n    <li>For node 1, you can buy the candy placed at node 1. Total candies bought = 1.</li>\r\n    <li>For node 2, you can buy the candy placed at node 2 and you are left with 5 - 2 = 3 amount of money. Now, you can move to its ancestor, i.e. 1 and can buy its candy also. Total candies bought = 2.</li>\r\n    <li>For node 3, you can buy the candy placed at node 3 and you are left with 5 - 4 = 1 amount of money. Now, you can move to its ancestor, i.e. 2, but cannot buy its candy because you don't have enough money. Total candies bought = 1.</li>\r\n</ul>\r\n<p>Therefore, if started from node 2, then you can buy the maximum number of candies which is 2 in this case.</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li>1 &le; T &le; 10</li>\r\n    <li>1 &le; N &le; 2 &times; 10<sup>5</sup></li>\r\n    <li>1 &le; u, v &le; N</li>\r\n    <li>1 &le; A[i] &le; 10<sup>9</sup></li>\r\n    <li>1 &le; K &le; 10<sup>18</sup></li>\r\n</ul>\r\n```",
        "google_doc_link": null,
        "solution_code": null,
        "company_name": "Razorpay_4sep",
        "company_id": 469
    },
    {
        "id": 1347,
        "title": "Special Numbers",
        "problem_statement": "```html\r\n<h1>Special Numbers</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>A special number is a number in which:</p>\r\n<ul>\r\n    <li>Prime valued indices consist of prime digits.</li>\r\n    <li>Non-prime valued indices consist of non-prime digits.</li>\r\n</ul>\r\n<p>By indices in a number, we refer to the position of a digit from the left of the number (1-indexed).</p>\r\n<p>For example, <strong>534</strong> consists of <strong>5</strong> at index <strong>1</strong>, <strong>3</strong> at index <strong>2</strong>, and <strong>4</strong> at index <strong>3</strong>.</p>\r\n<p><strong>Note:</strong></p>\r\n<ul>\r\n    <li>Prime digits are: 2, 3, 5, 7.</li>\r\n    <li>Non-prime digits are: 0, 1, 4, 6, 8, 9.</li>\r\n    <li>Prime indices are prime numbers: 2, 3, 5, 7, etc.</li>\r\n    <li>Non-prime indices are non-prime numbers: 1, 4, 6, 8, etc.</li>\r\n</ul>\r\n<p>You are given three numbers named as <em>N</em>, <em>M</em>, and <em>K</em>. Your task is to find out how many <strong>N-digit</strong> special numbers can be formed that leave a remainder <em>K</em> when divided by <em>M</em>.</p>\r\n<p>Since the answer can be very large, print it by taking <strong>modulo 1000000007</strong>.</p>\r\n\r\n<h2>Function Description</h2>\r\n<p>Complete the <code>specialNumber</code> function provided in the editor. The function takes the following 3 parameters and returns the required answer:</p>\r\n<ul>\r\n    <li><em>N</em>: Represents the count of digits allowed in special numbers</li>\r\n    <li><em>M</em>: Represents the value of M</li>\r\n    <li><em>K</em>: Represents the remainder of the special number with M</li>\r\n</ul>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'><strong>Input:</strong> N = 3, M = 4, K = 2\r\n<strong>Output:</strong> 5</code></pre>\r\n<p><strong>Explanation:</strong> The 5 special numbers are 122, 422, 622, 822, and 922. All these numbers leave a remainder 2 when divided by 4. They also follow the rules for special numbers:\r\n<ul>\r\n    <li>Index 1 is non-prime, so the first digit is a non-prime digit (1, 4, 6, 8, 9).</li>\r\n    <li>Indices 2 and 3 are prime, so the second and third digits are prime digits (in this case, both are 2).</li>\r\n</ul>\r\n</p>\r\n\r\n<h3>Example 2:</h3>\r\n<pre><code class='language-text'><strong>Input:</strong> N = 2, M = 2, K = 0\r\n<strong>Output:</strong> 5</code></pre>\r\n<p><strong>Explanation:</strong> For N = 2, M = 2, K = 0, there are 5 possible special numbers: 12, 42, 62, 82, 92. All these numbers are even (remainder 0 when divided by 2) and follow the special number rules:\r\n<ul>\r\n    <li>Index 1 is non-prime, so the first digit is a non-prime digit (1, 4, 6, 8, 9).</li>\r\n    <li>Index 2 is prime, so the second digit is a prime digit (in this case, 2, which is the only even prime).</li>\r\n</ul>\r\n</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>1 &le; N &le; 500</code></li>\r\n    <li><code>1 &le; M &le; 500</code></li>\r\n    <li><code>0 &le; K &lt; M</code></li>\r\n</ul>\r\n```",
        "google_doc_link": null,
        "solution_code": null,
        "company_name": "Razorpay_4sep",
        "company_id": 469
    },
    {
        "id": 1348,
        "title": "Optimized Cache Hit Counter",
        "problem_statement": "```html\r\n<h1>Optimized Cache Hit Counter</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>You are tasked with simulating a cache memory system with a fixed capacity. The system processes a sequence of memory access requests. For each request, it either results in a cache hit (if the item is already in the cache) or a cache miss (if the item is not in the cache and needs to be loaded).</p>\r\n<p>You need to implement a simulation using the Least Recently Used (LRU) eviction policy. When the cache reaches its capacity and a new item needs to be inserted, the least recently used item should be removed to make room.</p>\r\n<p>Due to a high frequency of memory access requests (up to 10<sup>5</sup>), your implementation must be optimized for performance, and choosing the right data structures (e.g., HashMap + Doubly Linked List or OrderedDict) is critical.</p>\r\n<p>Implement the function <code>simulateCacheAccess</code>. The function takes the cache capacity <code>C</code> and a list of memory accesses <code>accesses</code>. It should return the total number of cache hits and total misses.</p>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input:\r\nC = 3\r\nN = 10\r\naccesses = [1, 2, 3, 1, 4, 5, 2, 1, 3, 4]\r\n\r\nOutput: 1 9\r\n</code></pre>\r\n<p><strong>Explanation:</strong> Hits: Only 1 hit (on second access to 1). All others are misses, with evictions when cache is full.</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>1 &le; C &le; 10<sup>4</sup></code></li>\r\n    <li><code>1 &le; N &le; 10<sup>5</sup></code></li>\r\n    <li><code>0 &le; memory address &le; 10<sup>9</sup></code></li>\r\n</ul>\r\n```",
        "google_doc_link": null,
        "solution_code": null,
        "company_name": "Razorpay_4sep",
        "company_id": 469
    }
]