[
    {
        "id": 535,
        "title": "Vanish the Gems",
        "problem_statement": "<h1>Vanish the Gems</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>In front of you there is a treasure containing many gems, soon you realise that they are not as precious as they seem! Infact they are cursed with black magic and bring bad luck with them so you try to minimise the bad luck you get.</p>\r\n<p>You have the power to destroy 1 gem in 1 second. You can destroy gems in any order.</p>\r\n<p>You are given a 2D array A, where for i-th gem it takes A[i][0] seconds to give A[i][1] units of bad luck.At any instant, only one gem can give you the bad luck, and you can decide the order in which you want to receive the bad luck. Once the receiving of bad luck starts from any gem it cannot be destroyed and it automatically vanishes after giving A[i][1] units of bad luck.</p>\r\n<p>Although while receiving bad luck from any gem, you can choose to destroy any other gem which is available in the treasure.</p>\r\n<p>There is no time lapse in between receiving of bad lucks from any two gems. As soon as one gem finishes giving bad luck, you have to choose second gem from the treasure to receive the bad luck.</p>\r\n<p>Return the maximum amount of bad luck that you can avoid/destroy.</p>\r\n<p><strong>Note:</strong> Receiving bad luck is a continuous process.And at any instant you cannot receive bad luck from more than one gem. If you are recieving bad luck from any gem then you can choose second gem only after A[i][0] seconds.</p>\r\n\r\n<h2>Input Format</h2>\r\n<p>First argument is 2D array A containing information about each gem.</p>\r\n\r\n<h2>Output Format</h2>\r\n<p>Return a single integer the maximum amount of bad luck destroyed</p>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input: A = [[0, 1], [0, 10]]\r\nOutput: 0</code></pre>\r\n<p><strong>Explanation:</strong> Destroying a gem will take 1 unit of time, so we cannot destroy any bad luck at all, since both of the gems take 0 seconds to give bad luck.</p>\r\n\r\n<h3>Example 2:</h3>\r\n<pre><code class='language-text'>Input: A = [[0, 10], [1, 4], [1, 3], [1, 20]]\r\nOutput: 30</code></pre>\r\n<p><strong>Explanation:</strong> We can destroy 1st and 4th gem in 2 seconds while receiving bad luck from 2nd and 3rd.</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>1 &lt;= |A| &lt;= 2x10^3</code></li>\r\n    <li><code>|A[i]| == 2</code></li>\r\n    <li><code>0 &lt;= A[i][0] &lt;= 2x10^3</code></li>\r\n    <li><code>1 &lt;= A[i][1] &lt;= 10^6</code></li>\r\n</ul>",
        "google_doc_link": null,
        "solution_code": null,
        "company_name": "MediaNet_21july",
        "company_id": 174
    },
    {
        "id": 536,
        "title": "Fire nation's fury I",
        "problem_statement": "<h1>Fire nation's fury I</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>In the world where avataar is missing, the fire nation has started a war against all other kingdoms. The fire nation has N cities numbered from 1 to N connected with some roads. Given arrays A and B of size N-1, there is a bidirectional road from A[i] to B[i] and we can reach each city from any other city. We consider city with index 1 (1 based index) as the root city.</p>\r\n<p>These cities need to work together in order to conquer the world but they are very egoistic. Each city is associated with some jealousy value.</p>\r\n<p>i<sup>th</sup> city's jealousy value will be equal to number of cities with index > i in its subtree.</p>\r\n<p>The Fire Lord gave you a very important task. Find the total sum of all the jealousy values of all the cities.</p>\r\n<p>Since the answer can be big, return the output % 1000000007</p>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input:\r\nA = [1 2 3]\r\nB = [4 3 2]\r\nOutput: 4</code></pre>\r\n<p><strong>Explanation:</strong></p>\r\n<p>Node 1 is jealous of 2, 3, 4.</p>\r\n<p>Node 2 is jealous of 3.</p>\r\n<p>Total jealousy = 3 + 1 = 4</p>\r\n\r\n<h3>Example 2:</h3>\r\n<pre><code class='language-text'>Input:\r\nA = [1 6 4 2 7 3]\r\nB = [5 1 5 5 4 6]\r\nOutput: 8</code></pre>\r\n<p><strong>Explanation:</strong></p>\r\n<p>Node 1 is jealous of 2, 3, 4, 5, 6, 7.</p>\r\n<p>Node 4 is jealous of 7.</p>\r\n<p>Node 5 is jealous of 7.</p>\r\n<p>Total jealousy = 6 + 1 + 1 = 8</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n<li><code>1 &lt;= N &lt;= 10^5</code></li>\r\n<li><code>1 &lt;= A[i], B[i] &lt;= N</code></li>\r\n</ul>",
        "google_doc_link": null,
        "solution_code": null,
        "company_name": "MediaNet_21july",
        "company_id": 174
    },
    {
        "id": 537,
        "title": "String Rotation Analysis",
        "problem_statement": "<h1>String Rotation Analysis</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>You are given an array A consisting of strings made up of the letters 'a' and 'b' only.</p>\r\n<p>Each string goes through a number of operations, where:</p>\r\n<ol>\r\n    <li>At time 1, you circularly rotate each string by 1 letter.</li>\r\n    <li>At time 2, you circularly rotate the new rotated strings by 2 letters.</li>\r\n    <li>At time 3, you circularly rotate the new rotated strings by 3 letters.</li>\r\n    <li>At time t, you circularly rotate the new rotated strings by t % length(string) letters.</li>\r\n</ol>\r\n<p>Eg: String is \"abaab\"</p>\r\n<ol>\r\n    <li>At time 1, string is \"abaab\", as 1 letter is circularly rotated to the back</li>\r\n    <li>At time 2, string is \"aabaa\", as 2 letters of the string \"baab\" is circularly rotated to the back</li>\r\n    <li>At time 3, string is \"aaab\", as 3 letters of the string \"aaab\" is circularly rotated to the back</li>\r\n    <li>At time 4, string is again \"aaab\", as 4 letters of the string \"aaab\" is circularly rotated to the back</li>\r\n    <li>At time 5, string is \"aaaba\", as 1 letters of the string \"aaab\" is circularly rotated to the back</li>\r\n</ol>\r\n<p>After some units of time, a string becomes equal to its original self.</p>\r\n<p>Once a string becomes equal to itself, it's letters start to rotate from the first letter again (process resets). So, if a string takes t time to get back to the original, at time t+1 one letter will be rotated and the string will be its original self at 2t time.</p>\r\n<p>You have to find the minimum time, where maximum number of strings are equal to their original self.</p>\r\n<p>This time can be very large, give the answer modulo 10<sup>7</sup>.</p>\r\n<p>Note: Your solution will run on multiple test cases so do clear global variables after using them.</p>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input: A: [a, ababa, aba]\r\nOutput: 4</code></pre>\r\n<p><strong>Explanation:</strong></p>\r\n<p>String 'a' is it's original self at time 1, 2, 3 and 4.</p>\r\n<p>String 'ababa' is it's original self only at time 4. (ababa => babaa => baaba => abaab => ababa)</p>\r\n<p>String 'aba' is it's original self at time 2 and 4. (aba => baa => aba)</p>\r\n<p>Hence, 3 strings are their original self at time 4.</p>\r\n\r\n<h3>Example 2:</h3>\r\n<pre><code class='language-text'>Input: A: [a, aa]\r\nOutput: 1</code></pre>\r\n<p><strong>Explanation:</strong></p>\r\n<p>Both strings are their original self at time 1.</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li>1 <= |A| <= 100</li>\r\n</ul>",
        "google_doc_link": null,
        "solution_code": null,
        "company_name": "MediaNet_21july",
        "company_id": 174
    }
]