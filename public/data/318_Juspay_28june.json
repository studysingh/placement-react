[
    {
        "id": 990,
        "title": "Locking the tree of space",
        "problem_statement": "<h1>Locking the tree of space</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>You have a world map represented as an M-Ary tree. An example of such a tree is shown below, illustrating a hierarchy from 'World' down to specific regions like 'BLR'.</p>\r\n<p>For instance, in a complete 3-ary tree, if m = 3, N = 121 represents the number of nodes.</p>\r\n<p>You need to define three operations on this tree:</p>\r\n<ol>\r\n    <li><code>lock(X, uid)</code></li>\r\n    <li><code>unlock(X, uid)</code></li>\r\n    <li><code>upgradeLock(X, uid)</code></li>\r\n</ol>\r\n<p>Where <code>X</code> is the name of a node in the tree (which would be unique) and <code>uid</code> is the user who is performing the operation.</p>\r\n<p>Here are the definitions for the Operations:</p>\r\n\r\n<h3>Lock(X, uid)</h3>\r\n<p>Lock takes an exclusive access on the subtree rooted at <code>X</code>. It is formally defined like this:</p>\r\n<p>Once <code>lock(X, uid)</code> succeeds, then:</p>\r\n<ul>\r\n    <li><code>lock(A, anyUserId)</code> should fail (returns false), where <code>A</code> is a descendant of <code>X</code>.</li>\r\n    <li><code>lock(B, anyUserId)</code> should fail (returns false), where <code>X</code> is a descendant of <code>B</code>.</li>\r\n    <li>Lock operation cannot be performed on a node which is already locked, i.e., <code>lock(X, anyUserId)</code> should fail (returns false).</li>\r\n</ul>\r\n\r\n<h3>Unlock(X, uid)</h3>\r\n<ul>\r\n    <li>Unlock reverts what was done by the Lock operation. It can only be called on same node on which user <code>uid</code> had called a Lock on before. Returns true if it is successful.</li>\r\n</ul>\r\n\r\n<h3>UpgradeLock(X, uid)</h3>\r\n<ul>\r\n    <li>It helps the user <code>uid</code> upgrade their lock to an ancestor node. It is only possible if the node <code>X</code> already has locked descendants and all of them are only locked by the same user <code>uid</code>.</li>\r\n    <li>Upgrade should fail if there is any node which is descendant of <code>X</code> that is locked by a different user.</li>\r\n    <li>Successful Upgrade will 'Lock' the node <code>X</code>.</li>\r\n    <li>UpgradeLock call shouldn't violate the consistency model that Lock/Unlock function requires.</li>\r\n</ul>\r\n\r\n<h2>Notes</h2>\r\n<p>1) The number of nodes in the tree N is very large. So, optimize the time complexity for the above algorithms.</p>\r\n<p>2) The below section contains the input format.</p>\r\n<ul>\r\n    <li>The first line contains the number of Nodes in the tree (N).</li>\r\n    <li>The second line contains number of children per node (value m in m-ary Tree).</li>\r\n    <li>The third line contains number of queries (Q).</li>\r\n    <li>Next N lines contains the <strong>NodeName</strong> (string) in the m-ary Tree.</li>\r\n    <li>Next Q lines contains queries which are in format: <strong>OperationType NodeName UserId</strong></li>\r\n    <li><strong>OperationType</strong> &rarr;\r\n        <ul>\r\n            <li>1 for Lock</li>\r\n            <li>2 for unlock</li>\r\n            <li>3 for upgradeLock</li>\r\n        </ul>\r\n    </li>\r\n    <li><strong>NodeName</strong> &rarr; Name of any node (unique) in m-Ary Tree.</li>\r\n    <li><strong>UserId</strong> &rarr; Integer value representing a unique user.</li>\r\n</ul>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example Input Description:</h3>\r\n<p>With the above input you represent a 2-ary tree with 7 nodes as follows:</p>\r\n<pre><code class='language-text'>World\r\n/     \\\r\nAsia   Africa\r\n/ \\     / \\\r\nChina India SouthAfrica Egypt</code></pre>\r\n\r\n<h3>Sample Input and Output:</h3>\r\n<p><strong>Sample Input:</strong></p>\r\n<pre><code class='language-text'>7\r\n2\r\n5\r\nWorld\r\nAsia\r\nAfrica\r\nChina\r\nIndia\r\nSouthAfrica\r\nEgypt\r\n1 China 9\r\n1 India 9\r\n3 Asia 9\r\n2 India 9\r\n2 Asia 9</code></pre>\r\n<p><strong>Sample Output:</strong></p>\r\n<pre><code class='language-text'>true\r\ntrue\r\ntrue\r\nfalse\r\ntrue</code></pre>\r\n\r\n<p><strong>Explanation:</strong></p>\r\n<ul>\r\n    <li><strong>Query 1:</strong> <code>1 China 9</code> => This operation is success as initially China is unlocked.</li>\r\n    <li><strong>Query 2:</strong> <code>1 India 9</code> => This should be success as none of ancestors and descendants of India are locked.</li>\r\n    <li><strong>Query 3:</strong> <code>3 Asia 9</code> => This also should be success as upgrade operation is done by same user who has locked descendants.</li>\r\n    <li><strong>Query 4:</strong> <code>2 India 9</code> => This should fail as the India is now not locked.</li>\r\n    <li><strong>Query 5:</strong> <code>2 Asia 9</code> => This should be success as Asia was earlier (refer Query 3) locked by user 9.</li>\r\n</ul>\r\n\r\n<h2>Constraints</h2>\r\n<h3>Additional Notes:</h3>\r\n<ul>\r\n    <li>Here \"1 China 3\" indicates the following 'OperationType NodeName UserId'.</li>\r\n    <li>The tree is always fully balanced.</li>\r\n</ul>\r\n<h3>Constraints on the inputs are as follows:</h3>\r\n<ul>\r\n    <li><code>1 &lt; N &lt; 5 * 10^5</code></li>\r\n    <li><code>1 &lt; m &lt; 30</code></li>\r\n    <li><code>1 &lt; Q &lt; 5 * 10^5</code></li>\r\n    <li><code>1 &lt; length of NodeName &lt; 20</code></li>\r\n</ul>\r\n<h3>Optimize the time complexity:</h3>\r\n<ul>\r\n    <li>Lock - <code>O(log_m N)</code></li>\r\n    <li>Unlock - <code>O(log_m N)</code></li>\r\n    <li>UpgradeLock - <code>O(number of LockedNodes * log_m N)</code></li>\r\n</ul>\r\n<h3>Specific Operation Failure Conditions:</h3>\r\n<ul>\r\n    <li>Lock operation on already locked node should fail.</li>\r\n    <li>Once <code>UpgradeLock(X, uid)</code> succeeds on <code>X</code>, it is equivalent to <code>X</code> being locked by <code>uid</code>. So, <code>Lock(A/B, anyUser)</code> should fail as per the definition of Lock and <code>Unlock(X, uid)</code> should also work.</li>\r\n    <li>Upgrade lock operation on a node having no locked descendants should fail and upgrade lock on already locked node should also fail.</li>\r\n</ul>\r\n\r\n<h2>Limits</h2>\r\n<p>Your code must be able to print the sample output from the provided sample input. However, your code is run against multiple hidden test cases. Therefore, your code must pass these hidden test cases to solve the problem statement.</p>\r\n<ul>\r\n    <li>Time Limit: 0.6 sec(s) for each input file</li>\r\n    <li>Memory Limit: 256 MB</li>\r\n    <li>Source Limit: 1024 KB</li>\r\n</ul>\r\n\r\n<h2>Scoring</h2>\r\n<p>Score is assigned if any testcase passes.</p>\r\n\r\n<h2>Allowed Languages</h2>\r\n<p>Bash, C, C++14, C++17, Clojure, C#, D, Erlang, F#, Go, Groovy, Haskell, Java 8, Java 14, Java 17, JavaScript(Node.js), Julia, Kotlin, Lisp (SBCL), Lua, Objective-C, OCaml, Octave, Pascal, Perl, PHP, Python, Python 3, Python 3.8, R(RScript), Racket, Ruby, Rust, Scala, Swift, TypeScript, Visual Basic</p>",
        "google_doc_link": null,
        "solution_code": null,
        "company_name": "Juspay_28june",
        "company_id": 318
    }
]