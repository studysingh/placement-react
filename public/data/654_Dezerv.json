[
    {
        "id": 1854,
        "title": "LFU Cache",
        "problem_statement": "<h1>LFU Cache</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>A cache is a limited storage that stores key-value pairs, implementing an eviction policy to manage its size. Least Frequently Used (LFU) cache removes the least frequently accessed key when the capacity is reached.</p>\r\n<p>You need to implement the Least Frequently Used (LFU) cache with the capacity <code>N</code>.</p>\r\n<p>You are also given <code>Q</code> operations of the following type:</p>\r\n<ul>\r\n    <li><strong>1, key, -1</strong>: Get the value of the key from the cache. If the value does not exist in the cache, return <code>-1</code>.</li>\r\n    <li><strong>2, key, value</strong>: Update the value of the key if present, or insert the key if not already present. When the cache reaches its capacity, it should invalidate and remove the least frequently used key before inserting a new item. For this problem, when there is a tie (two or more keys with the same frequency), the smallest key should be removed.</li>\r\n</ul>\r\n<p>For each operation of type 1, print the required value.</p>\r\n\r\n<h3>Function description</h3>\r\n<p>Complete the function <code>solve()</code>. This function takes the following 3 parameters and returns the required array of results:</p>\r\n<ul>\r\n    <li><code>N</code>: Represents the capacity of the cache</li>\r\n    <li><code>Q</code>: Represents the number of operations on the cache</li>\r\n    <li><code>operations</code>: Represents the operations on the cache</li>\r\n</ul>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<p><strong>Input format for custom testing</strong></p>\r\n<p><strong>Note:</strong> Use this input format if you are testing against custom input or writing code in a language where we don't provide boilerplate code.</p>\r\n<ul>\r\n    <li>The first line contains <code>N</code> denoting the capacity of the cache.</li>\r\n    <li>The next line contains <code>Q</code> denoting the number of operations on the cache.</li>\r\n    <li>The next <code>Q</code> lines contain 3 space-separated integers.</li>\r\n</ul>\r\n<p><strong>Output format</strong></p>\r\n<p>For each query of type 1, print the space-separated values on a single line.</p>\r\n<pre><code class='language-text'>Input:\r\n2\r\n5\r\n2 1 2\r\n2 1 3\r\n2 2 4\r\n2 2 5\r\n1 2 -1</code></pre>\r\n<pre><code class='language-text'>Output:\r\n-1</code></pre>\r\n<p><strong>Explanation:</strong>\r\nLet's trace the operations with capacity <code>N = 2</code>:\r\n<ol>\r\n    <li><strong>Operation: [2, 1, 2]</strong> (Put key=1, value=2)\r\n        Cache: <code>{1:2}</code>. Frequencies: <code>{1:1}</code>.</li>\r\n    <li><strong>Operation: [2, 1, 3]</strong> (Update key=1, value=3)\r\n        Key 1 is present. Update its value and increment its frequency.\r\n        Cache: <code>{1:3}</code>. Frequencies: <code>{1:2}</code>.</li>\r\n    <li><strong>Operation: [2, 2, 4]</strong> (Put key=2, value=4)\r\n        Key 2 is not present. Cache size (1) is less than capacity (2). Insert key 2.\r\n        Cache: <code>{1:3, 2:4}</code>. Frequencies: <code>{1:2, 2:1}</code>.</li>\r\n    <li><strong>Operation: [2, 2, 5]</strong> (Update key=2, value=5)\r\n        Key 2 is present. Update its value and increment its frequency.\r\n        Cache: <code>{1:3, 2:5}</code>. Frequencies: <code>{1:2, 2:2}</code>.</li>\r\n    <li><strong>Operation: [1, 2, -1]</strong> (Get key=2)\r\n        Key 2 is present in the cache with value 5. Accessing it increments its frequency.\r\n        Cache: <code>{1:3, 2:5}</code>. Frequencies: <code>{1:2, 2:3}</code>.\r\n        According to standard LFU behavior, the expected output should be <code>5</code>. The provided sample output of <code>-1</code> suggests a different interpretation of the LFU eviction rules or a specific scenario not fully detailed in the problem description, or a discrepancy in the sample output itself. If key 2 were to be evicted, it would imply a new insertion when the cache is full, and key 2 was the least frequently used (or smallest key in case of a tie). However, operation 4 is an update to key 2, which does not trigger eviction.</li>\r\n</ol>\r\n</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>1 &lt;= N &lt;= 5 * 10^3</code></li>\r\n    <li><code>1 &lt;= Q &lt;= 2 * 10^5</code></li>\r\n    <li><code>1 &lt;= K &lt;= 2 * 10^5</code> (where K is the key)</li>\r\n    <li><code>1 &lt;= value &lt;= 10^9</code></li>\r\n</ul>\r\n\r\n<h2>Note</h2>\r\n<p>Your code must be able to print the sample output from the provided sample input. However, your code is run against multiple hidden test cases. Therefore, your code must pass these hidden test cases to solve the problem statement.</p>\r\n\r\n<h3>Limits</h3>\r\n<p>Time Limit: 10 sec(s) for each input file<br>\r\nMemory Limit: 256 MB<br>\r\nSource Limit: 1024 KB</p>\r\n\r\n<h3>Scoring</h3>\r\n<p>Score is assigned if any testcase passes</p>\r\n\r\n<h3>Allowed Languages</h3>\r\n<p>Bash, C, C++14, C++17, Clojure, C#, D, Erlang, F#, Go, Groovy, Haskell, Java 8, Java 14, Java 17, JavaScript(Node.js), Julia, Kotlin, Lisp (SBCL), Lua, Objective-C, OCaml, Octave, Pascal, Perl, PHP, Python, Python 3, Python 3.8, Racket, Ruby, Rust, Scala, Swift, TypeScript, Visual Basic</p>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <vector>\n#include <string>\n#include <list>\n#include <unordered_map>\n#include <algorithm>\n\nclass Solution {\npublic:\n    std::vector<int> solve(int N, int Q, const std::vector<std::vector<int>>& operations) {\n        // TODO: Implement the LFU cache logic here.\n        std::vector<int> results;\n        return results;\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    int N;\n    std::cin >> N;\n\n    int Q;\n    std::cin >> Q;\n\n    std::vector<std::vector<int>> operations(Q, std::vector<int>(3));\n    for (int i = 0; i < Q; ++i) {\n        std::cin >> operations[i][0] >> operations[i][1] >> operations[i][2];\n    }\n\n    Solution solution;\n    std::vector<int> results = solution.solve(N, Q, operations);\n\n    for (size_t i = 0; i < results.size(); ++i) {\n        std::cout << results[i] << (i == results.size() - 1 ? \"\" : \" \");\n    }\n    if (!results.empty()) {\n        std::cout << std::endl;\n    }\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "Dezerv",
        "company_id": 654
    },
    {
        "id": 1855,
        "title": "Seat reservation",
        "problem_statement": "<h1>Seat reservation</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>A movie theater has <code>N</code> seats numbered 1 to <code>N</code>.</p>\r\n<p>Build a seat reservation system that performs <code>K</code> operations. Each operation is defined by an element <code>seat[i]</code> from an input array <code>seat</code>:</p>\r\n<ul>\r\n    <li>If <code>seat[i] = 0</code>: Fetches the smallest-numbered unreserved seat, reserves it, and implicitly returns its number (though this returned number is not part of the final output).</li>\r\n    <li>If <code>seat[i] > 0</code>: Cancels the reservation for the seat numbered <code>seat[i]</code>.</li>\r\n</ul>\r\n<p>The final result should be an array containing the numbers of all currently reserved seats after all <code>K</code> operations are performed.</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li>Every time a reservation operation (<code>seat[i] = 0</code>) is performed, it is guaranteed that there is at least one unreserved seat available.</li>\r\n    <li>Every time a cancellation operation (<code>seat[i] > 0</code>) is performed, it is guaranteed that the seat numbered <code>seat[i]</code> is currently reserved.</li>\r\n</ul>\r\n\r\n<h2>Function Description</h2>\r\n<p>Complete the function <code>solution()</code> provided in the editor. The function takes the following 3 parameters and returns the solution:</p>\r\n<ul>\r\n    <li><code>N</code>: Represents the total number of seats in the theater (numbered 1 to <code>N</code>).</li>\r\n    <li><code>K</code>: Represents the total number of operations to perform.</li>\r\n    <li><code>seat</code>: An array of integers representing the details of <code>K</code> operations.</li>\r\n</ul>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n\nclass Solution {\npublic:\n    std::vector<int> solve(int N, int K, const std::vector<int>& seat) {\n        // Core logic for the seat reservation problem goes here.\n        // For example, using a set to keep track of reserved seats\n        // and another data structure (like a min-priority_queue or another set)\n        // to find the smallest unreserved seat efficiently.\n        \n        // Placeholder implementation:\n        return {};\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    int N, K;\n    std::cin >> N >> K;\n\n    std::vector<int> seat(K);\n    for (int i = 0; i < K; ++i) {\n        std::cin >> seat[i];\n    }\n\n    Solution solution;\n    std::vector<int> result = solution.solve(N, K, seat);\n\n    for (size_t i = 0; i < result.size(); ++i) {\n        std::cout << result[i] << (i == result.size() - 1 ? \"\" : \" \");\n    }\n    std::cout << std::endl;\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "Dezerv",
        "company_id": 654
    }
]