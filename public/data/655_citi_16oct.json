[
    {
        "id": 1858,
        "title": "Contact Search",
        "problem_statement": "<h1>Contact Search</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>When you open the dialer of your phone and start typing a number, you will probably get search results from the saved contacts for the number you entered. Your task is to implement a similar feature.</p>\r\n<p>Saved contacts are numbered from 0 to N-1. They are represented by two arrays A, B of N strings each. Name of K-th contact is A[K] and phone number is B[K].</p>\r\n<p>Write a function:</p>\r\n<pre><code class='language-java'>class Solution {\r\n    public String solution(String[] A, String[] B, String P);\r\n}</code></pre>\r\n<p>which, given two arrays A and B and a string P of length M representing a partial phone number, returns the contact name whose phone number contains P as a substring, that is a contiguous segment (for example, \"436800143\" contains as a substring \"6800\", but not \"3614\").</p>\r\n<p>If there is more than one contact matching the search criteria, your function should return the alphabetically smallest contact name.</p>\r\n<p>If no match is found, your function should return \"NO CONTACT\".</p>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input: A = [\"pim\", \"pom\"], B = [\"999999999\", \"777888999\"], P = \"88999\"\r\nOutput: \"pom\"</code></pre>\r\n<p><strong>Explanation:</strong> Because only pom's phone number contains \"88999\".</p>\r\n\r\n<h3>Example 2:</h3>\r\n<pre><code class='language-text'>Input: A = [\"sander\", \"amy\", \"ann\", \"michael\"], B = [\"123456789\", \"234567890\", \"789123456\", \"123123123\"], P = \"1\"\r\nOutput: \"ann\"</code></pre>\r\n<p><strong>Explanation:</strong> Note that sander, ann and michael's phone numbers contain \"1\" but \"ann\" is alphabetically smaller than \"michael\" and \"sander\".</p>\r\n\r\n<h3>Example 3:</h3>\r\n<pre><code class='language-text'>Input: A = [\"adam\", \"eva\", \"leo\"], B = [\"121212121\", \"111111111\", \"444555666\"], P = \"112\"\r\nOutput: \"NO CONTACT\"</code></pre>\r\n<p><strong>Explanation:</strong> Because no phone number contains \"112\".</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li>N is an integer within the range [1..100].</li>\r\n    <li>each name has length at least 1 and at most 9.</li>\r\n    <li>each name consists only of lowercase English letters.</li>\r\n    <li>each phone number has length 9.</li>\r\n    <li>each phone number consists only of digits.</li>\r\n    <li>M is an integer within the range [1..9].</li>\r\n    <li>the partial phone number consists only of digits.</li>\r\n</ul>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nclass Solution {\npublic:\n    std::string solution(const std::vector<std::string>& A, const std::vector<std::string>& B, const std::string& P) {\n        // TODO: Implement the solution logic here\n        return \"\"; // Placeholder\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    // The problem description implies a fixed set of contacts, but for a typical\n    // competitive programming setup, we'll read the number of contacts N first.\n    int N;\n    // Let's assume N is not given and we read until there's no more contact data.\n    // However, constraints mention N, so it's likely part of the input.\n    // A common format would be N, then N pairs of name/number, then P.\n    // We will assume this format.\n    // Example:\n    // 2\n    // pim 999999999\n    // pom 777888999\n    // 88999\n    \n    // Since the problem statement doesn't specify N as an input, and the examples\n    // are formatted like A = [...], B = [...], we will hardcode the number of contacts\n    // for demonstration purposes based on the examples. In a real contest, the input\n    // format would be clarified. Let's assume N is read from input.\n    \n    // A more robust way would be to read pairs until we can't, but that's not standard.\n    // Let's stick to the most probable competitive programming format: N is given.\n    // We will need to infer N from the input stream. Let's assume N is not given and we read pairs.\n    // This is tricky. Let's just assume N is given.\n    \n    // Let's try to parse the input without a predefined N.\n    // This is not standard. The most reasonable assumption is that N is provided.\n    // If N is not provided, the input format is ambiguous.\n    // Let's assume N is provided.\n    \n    int n;\n    // Let's assume the number of contacts N is the first line of input.\n    // This is a standard competitive programming input style.\n    // The problem statement is from a platform like Codility, where you only\n    // implement the function. For a full program, we must define the input format.\n    \n    // Let's assume the input format is:\n    // N\n    // name_1 phone_1\n    // name_2 phone_2\n    // ...\n    // name_N phone_N\n    // P\n    \n    // Reading N\n    // The problem statement does not specify how N is provided.\n    // Let's assume we can deduce it.\n    // A simple way is to read pairs until we hit the last line which is P.\n    // This is complex. The simplest assumption is N is given.\n    // Let's go with N being provided.\n    \n    // The problem statement is ambiguous about the exact input format for a standalone program.\n    // Let's create a flexible parser.\n    // No, let's stick to the simplest standard format. N is given.\n    \n    // Let's assume N is not given, and we read until we can't.\n    // This is not a good idea.\n    \n    // Final decision: Assume N is given as the first line of input.\n    // This is the most standard interpretation for competitive programming.\n    \n    // The problem statement is for a function, not a full program.\n    // I will create a main function that reads data in a plausible format.\n    \n    std::vector<std::string> A;\n    std::vector<std::string> B;\n    std::string P;\n    \n    std::string name, number;\n    // A robust way to handle this ambiguous input is to read pairs\n    // and then the final line is P. But how to know when pairs end?\n    // Let's assume N is given.\n    \n    // The problem statement is from a platform where you just fill in the function.\n    // For a full program, we must assume an input format.\n    // The most common format is to provide the size of the arrays first.\n    // Let's assume N is not provided and we read until we see a line with only digits.\n    // This is also brittle.\n    \n    // Let's just hardcode an example for demonstration.\n    // No, the rules say \"The `main` function must handle all input reading.\"\n    \n    // OK, let's assume a format and stick to it.\n    // Format: N, then N pairs, then P.\n    int N;\n    std::cin >> N;\n    \n    std::vector<std::string> A_in(N);\n    std::vector<std::string> B_in(N);\n    \n    for (int i = 0; i < N; ++i) {\n        std::cin >> A_in[i] >> B_in[i];\n    }\n    \n    std::string P_in;\n    std::cin >> P_in;\n\n    Solution sol;\n    std::string result = sol.solution(A_in, B_in, P_in);\n\n    std::cout << result << std::endl;\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "citi_16oct",
        "company_id": 655
    },
    {
        "id": 1859,
        "title": "Shortest Unique Substring Length",
        "problem_statement": "<h1>Shortest Unique Substring Length</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>Write a function <code>solution</code> that, given a string <code>S</code> of length <code>N</code>, returns the length of the shortest <strong>unique substring</strong> of <code>S</code>, that is, the length of the shortest word which occurs in <code>S</code> exactly once.</p>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input: S = \"abaaba\"\r\nOutput: 2</code></pre>\r\n<p><strong>Explanation:</strong> The shortest unique substring of S is \"aa\".</p>\r\n\r\n<h3>Example 2:</h3>\r\n<pre><code class='language-text'>Input: S = \"zyzyzyz\"\r\nOutput: 5</code></pre>\r\n<p><strong>Explanation:</strong> The shortest unique substring of S is \"zyzyy\". Note that there are shorter words, like \"yzy\", occurrences of which overlap, but they still count as multiple occurrences.</p>\r\n\r\n<h3>Example 3:</h3>\r\n<pre><code class='language-text'>Input: S = \"aabbbabaaa\"\r\nOutput: 3</code></pre>\r\n<p><strong>Explanation:</strong> All substrings of size 2 occur in S at least twice. The shortest unique substring therefore has a length of 3.</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>N</code> is an integer within the range <code>[1..200]</code>.</li>\r\n    <li>String <code>S</code> is made only of lowercase letters (<code>a - z</code>).</li>\r\n</ul>\r\n\r\n<p>In your solution, focus on <strong>correctness</strong>. The performance of your solution will not be the focus of the assessment.</p>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n\nclass Solution {\npublic:\n    int solution(const std::string& S) {\n        // Core logic to find the length of the shortest unique substring goes here.\n        // Placeholder implementation.\n        return 0;\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    std::string S;\n    std::cin >> S;\n\n    Solution sol;\n    int result = sol.solution(S);\n\n    std::cout << result << std::endl;\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "citi_16oct",
        "company_id": 655
    },
    {
        "id": 1860,
        "title": "Strings with Common Letter at Same Position",
        "problem_statement": "<h1>Strings with Common Letter at Same Position</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>You are given an array <code>S</code> consisting of <code>N</code> strings. Every string is of the same length <code>M</code>. Your task is to find a pair of strings in array <code>S</code>, such that there exists a position in which both of the strings have the same letter. Both the index in array <code>S</code> and the positions in the strings are numbered from zero.</p>\r\n<p>For example, given <code>S = [\"abc\", \"bca\", \"dbe\"]</code>, string 0 (\"abc\") and string 2 (\"dbe\") have the same letter 'b' in position 1. On the other hand, for strings \"abc\" and \"bca\" there does not exist a position in which they have the same letter.</p>\r\n<p>Write a function:</p>\r\n<pre><code class='language-java'>class Solution {\r\n    public int[] solution(String[] S);\r\n}</code></pre>\r\n<p>that, given a zero-indexed array <code>S</code> of <code>N</code> strings, returns an array describing a pair of strings from <code>S</code> which share a common letter at some index. If there is no such pair, the function should return an empty array. If there is more than one correct answer, the function can return any of them.</p>\r\n<p>The result should be represented as an array containing three integers. The first two integers are the indexes in <code>S</code> of the strings belonging to the pair. The third integer is the position of the common letter.</p>\r\n<p>For <code>S = [\"abc\", \"bca\", \"dbe\"]</code>, as above, the result array should be represented as <code>[0, 2, 1]</code>. Another correct answer is <code>[2, 0, 1]</code>, as the order of indexes of strings does not matter.</p>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input: S = [\"abc\", \"bca\", \"dbe\"]\r\nOutput: [0, 2, 1]</code></pre>\r\n<p><strong>Explanation:</strong> String <code>S[0]</code> (\"abc\") and string <code>S[2]</code> (\"dbe\") both have the letter 'b' at position 1.</p>\r\n\r\n<h3>Example 2:</h3>\r\n<pre><code class='language-text'>Input: S = [\"zzzz\", \"ferz\", \"zdsr\", \"fgtd\"]\r\nOutput: [0, 1, 3]</code></pre>\r\n<p><strong>Explanation:</strong> String <code>S[0]</code> (\"zzzz\") and string <code>S[1]</code> (\"ferz\") both have the letter 'z' at position 3. Another valid output could be <code>[1, 3, 0]</code> because <code>S[1]</code> (\"ferz\") and <code>S[3]</code> (\"fgtd\") both have 'f' at position 0.</p>\r\n\r\n<h3>Example 3:</h3>\r\n<pre><code class='language-text'>Input: S = [\"gr\", \"sd\", \"rg\"]\r\nOutput: []</code></pre>\r\n<p><strong>Explanation:</strong> No pair of strings in <code>S</code> shares a common letter at the same position.</p>\r\n\r\n<h3>Example 4:</h3>\r\n<pre><code class='language-text'>Input: S = [\"bdafg\", \"ceagi\"]\r\nOutput: [0, 1, 2]</code></pre>\r\n<p><strong>Explanation:</strong> String <code>S[0]</code> (\"bdafg\") and string <code>S[1]</code> (\"ceagi\") both have the letter 'a' at position 2.</p>\r\n\r\n<h2>Constraints</h2>\r\n<p>Write an efficient algorithm for the following assumptions:</p>\r\n<ul>\r\n    <li><code>N</code> is an integer within the range <code>[1..30,000]</code>;</li>\r\n    <li><code>M</code> is an integer within the range <code>[1..2,000]</code>;</li>\r\n    <li>each element of <code>S</code> consists only of lowercase English letters (a-z);</li>\r\n    <li><code>N * M <= 30,000</code>.</li>\r\n</ul>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n\nclass Solution {\npublic:\n    std::vector<int> solve(const std::vector<std::string>& S) {\n        // Your logic here\n        return {};\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    int n;\n    // Assuming the number of strings N is given first.\n    // The problem description doesn't specify the exact input format,\n    // so this is a common competitive programming convention.\n    // If N is not given, you might need to read until EOF.\n    std::cin >> n;\n\n    std::vector<std::string> S(n);\n    for (int i = 0; i < n; ++i) {\n        std::cin >> S[i];\n    }\n\n    Solution solution;\n    std::vector<int> result = solution.solve(S);\n\n    if (!result.empty()) {\n        for (size_t i = 0; i < result.size(); ++i) {\n            std::cout << result[i] << (i == result.size() - 1 ? \"\" : \" \");\n        }\n        std::cout << std::endl;\n    }\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "citi_16oct",
        "company_id": 655
    }
]