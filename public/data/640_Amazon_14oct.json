[
    {
        "id": 1815,
        "title": "Code Question 1",
        "problem_statement": "```html\r\n<h1>Code Question 1</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>The developers at Amazon are working on optimising the capacity of their cloud system. In the system, there are n servers where the memory capacity of the ith server is represented by the array <code>memory[i]</code>. A system always contains an even number of servers. If the system has 2x servers, then x of them will be primary and the other x will be backup servers. For each primary server P, there exists a backup server B where the memory capacity of B ≥ memory capacity of P. The system's memory capacity is the sum of the memory capacity of all the primary servers.</p>\r\n<p>Given n servers and an array memory, find the maximum system memory capacity that can be formed using the n servers.</p>\r\n\r\n<h2>Examples</h2>\r\n<p>Consider the following conceptual examples for selecting primary and backup servers:</p>\r\n<table>\r\n    <thead>\r\n        <tr>\r\n            <th>Primary Servers Options</th>\r\n            <th>Backup Servers Options</th>\r\n            <th>Conditions</th>\r\n            <th>Valid Option</th>\r\n        </tr>\r\n    </thead>\r\n    <tbody>\r\n        <tr>\r\n            <td>serverA, serverB</td>\r\n            <td>serverC, serverD</td>\r\n            <td><code>memory[serverA] ≤ memory[serverC]</code><br><code>memory[serverB] ≤ memory[serverD]</code></td>\r\n            <td>No</td>\r\n        </tr>\r\n        <tr>\r\n            <td>serverA, serverD</td>\r\n            <td>serverB, serverE</td>\r\n            <td><code>memory[serverA] ≤ memory[serverB]</code><br><code>memory[serverD] ≤ memory[serverE]</code></td>\r\n            <td>Yes</td>\r\n        </tr>\r\n        <tr>\r\n            <td>serverA, serverC</td>\r\n            <td>serverE, serverB</td>\r\n            <td><code>memory[serverA] ≤ memory[serverE]</code><br><code>memory[serverC] ≤ memory[serverB]</code></td>\r\n            <td>Yes</td>\r\n        </tr>\r\n    </tbody>\r\n</table>\r\n<p>In the second configuration, the system memory capacity is <code>memory[serverA] + memory[serverD] = 3</code>. While in the third configuration, it is <code>memory[serverA] + memory[serverC] = 5</code>. Hence, the maximum system memory capacity is 5.</p>\r\n\r\n<h3>Example 1: (Sample Case 0)</h3>\r\n<pre><code class='language-text'>Input: n = 4, memory = [1, 2, 1, 2]\r\nOutput: 3</code></pre>\r\n<p><strong>Explanation:</strong> Here, we have 4 servers [serverA, serverB, serverC, serverD] having memory sizes as [1, 2, 1, 2]. We can choose serverA and serverB as primary servers, and serverC and serverD as their respective backup. The conditions hold true since <code>memory[serverC] ≥ memory[serverA]</code> and <code>memory[serverD] ≥ memory[serverB]</code>. Hence, the maximum system memory capacity is 3.</p>\r\n\r\n<h3>Example 2: (Sample Case 1)</h3>\r\n<pre><code class='language-text'>Input: n = 3, memory = [1, 2, 1]\r\nOutput: 1</code></pre>\r\n<p><strong>Explanation:</strong> Here, we have 3 servers [serverA, serverB, serverC] having memory sizes as [1, 2, 1] respectively. We can choose serverA as a primary server, and serverB as its respective backup server. The conditions hold true since <code>memory[serverB] ≥ memory[serverA]</code>. Hence, the maximum system memory capacity is 1.</p>\r\n<p><em>Note: The problem statement specifies that a system always contains an even number of servers. Example 2 (Sample Case 1) uses n=3, which is an odd number. This might be a discrepancy in the problem description or an edge case to consider.</em></p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>2 ≤ n ≤ 2 * 10^5</code></li>\r\n    <li><code>1 ≤ memory[i] ≤ 10^9</code></li>\r\n</ul>\r\n\r\n<h2>Function Description</h2>\r\n<p>Complete the function <code>maximumCapacity</code> in the editor below.</p>\r\n<p>The function is expected to return a <code>LONG_INTEGER</code>.</p>\r\n<p>The function accepts the following parameters:</p>\r\n<ul>\r\n    <li><code>int memory_count</code>: the number of servers (n)</li>\r\n    <li><code>int* memory</code>: the memory capacity of the given servers (an array)</li>\r\n</ul>\r\n<pre><code class='language-c'>long maximumCapacity(int memory_count, int* memory) {\r\n    // Function body to be implemented\r\n}</code></pre>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <numeric>\n\nclass Solution {\npublic:\n    long long maximumCapacity(int n, std::vector<int>& memory) {\n        // TODO: Implement the solution logic here\n        return 0;\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    int n;\n    std::cin >> n;\n\n    std::vector<int> memory(n);\n    for (int i = 0; i < n; ++i) {\n        std::cin >> memory[i];\n    }\n\n    Solution sol;\n    long long result = sol.maximumCapacity(n, memory);\n\n    std::cout << result << std::endl;\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "Amazon_14oct",
        "company_id": 640
    },
    {
        "id": 1822,
        "title": "Modified Knapsack Problem",
        "problem_statement": "<h1>Modified Knapsack Problem</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>Given <code>n</code> items where:</p>\r\n<ul>\r\n    <li>The weight of the <code>i<sup>th</sup></code> item is <code>2<sup>i</sup></code> using 0-based indexing.</li>\r\n    <li>The cost of the <code>i<sup>th</sup></code> item is <code>cost[i]</code>.</li>\r\n</ul>\r\n<p>Find the minimum amount needed to purchase items whose combined weight is at least <code>minWeight</code>. Multiple units of an item can be purchased.</p>\r\n<p><strong>Example</strong></p>\r\n<p><code>n = 5</code><br><code>cost = [2, 5, 7, 11, 25]</code><br><code>minWeight = 26</code></p>\r\n<p>An optimal purchase strategy is:</p>\r\n<ul>\r\n    <li>Buy 2 units at <code>cost[0]</code> and 3 units at <code>cost[3]</code> per item</li>\r\n    <li>Total cost = <code>2 * 2 + 3 * 11 = 4 + 33 = 37</code></li>\r\n    <li>Total weight = <code>(2 * 2<sup>0</sup>) + (3 * 2<sup>3</sup>) = 2 + 24 = 26</code>, which meets the minimum weight requirement.</li>\r\n</ul>\r\n<p>The answer is 37, representing the minimum cost to achieve the weight requirement.</p>\r\n\r\n<p><strong>Function Description</strong></p>\r\n<p>Complete the function <code>getMinimunCost</code> in the editor with the following parameters:</p>\r\n<p><code>int cost[]</code>: the cost of each item<br><code>int minWeight</code>: the minimum combined weight of the items</p>\r\n<p><strong>Returns</strong></p>\r\n<p><code>long_int</code>: the minimum amount needed to purchase the items</p>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input:\r\n5\r\n4\r\n3\r\n2\r\n1\r\n10\r\n2\r\nOutput:\r\n1</code></pre>\r\n<p><strong>Explanation:</strong> It is optimal to buy 1 unit of item 3 which has a weight of <code>2<sup>3</sup> = 8</code> units (greater than <code>minWeight = 2</code>) and has a cost of 1.</p>\r\n\r\n<h3>Example 2:</h3>\r\n<pre><code class='language-text'>Input:\r\n4\r\n10\r\n9\r\n8\r\n10\r\n14\r\nOutput:\r\n20</code></pre>\r\n<p><strong>Explanation:</strong> It is optimal to buy 2 units of item 0 (0-based), which weighs 8 units. Total combined weight = <code>2 * 8 = 16</code>, which is greater than <code>minWeight</code>. Total cost = <code>2 * 10 = 20</code>.</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>1 &lt;= n &lt;= 30</code></li>\r\n    <li><code>1 &lt;= cost[i] &lt;= 10<sup>9</sup></code></li>\r\n    <li><code>1 &lt;= minWeight &lt;= 10<sup>9</sup></code></li>\r\n</ul>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nclass Solution {\npublic:\n    long long getMinimumCost(const std::vector<int>& cost, int minWeight) {\n        // Core logic goes here\n        return 0;\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    int n;\n    std::cin >> n;\n\n    std::vector<int> cost(n);\n    for (int i = 0; i < n; ++i) {\n        std::cin >> cost[i];\n    }\n\n    int minWeight;\n    std::cin >> minWeight;\n\n    Solution sol;\n    long long result = sol.getMinimumCost(cost, minWeight);\n\n    std::cout << result << std::endl;\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "Amazon_14oct",
        "company_id": 640
    },
    {
        "id": 1823,
        "title": "Collect The Coins",
        "problem_statement": "<h1>Collect The Coins</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>Alex is playing a game in Hackerland and needs to collect coins from various locations. The city is represented as a tree with n vertices labeled from 0 to n - 1. There is an array called coins of size n, where coins[i] is either 0 or 1, where 1 means the vertex contains a coin.</p>\r\n<p>Alex must travel the tree's edges to collect all the coins. The distance between two vertices is the number of edges between them. From any given vertex x, Alex can collect all coins located within a distance of 2 edges from x.</p>\r\n<p>The goal is to find the shortest path that allows Alex to collect all the coins. Alex can choose any vertex, but must start and end at that vertex. The path can traverse the same edge multiple times, and all edges are bidirectional.</p>\r\n<p>Return the number of edges in the shortest path along which Alex can collect all the coins.</p>\r\n<p>The function is expected to return an <code>INTEGER</code>.</p>\r\n<p>The function accepts the following parameters:</p>\r\n<pre><code class='language-cpp'>int getMinPath(vector<int> coins, int tree_nodes, vector<int> tree_from, vector<int> tree_to)\r\n</code></pre>\r\n<ul>\r\n    <li><code>coins</code>: an array of tree_nodes integers representing coins at each vertex.</li>\r\n    <li><code>tree_nodes</code>: the number of nodes in the graph.</li>\r\n    <li><code>tree_from</code>: one node of each bidirectional edge.</li>\r\n    <li><code>tree_to</code>: the other node of each bidirectional edge.</li>\r\n</ul>\r\n<p><strong>Returns:</strong></p>\r\n<p><code>int</code>: the number of edges in the shortest path.</p>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input:\r\ntree_nodes = 12\r\ncoins = [1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1]\r\ntree_from = [0, 0, 1, 2, 3, 4, 5, 6, 8, 9, 10]\r\ntree_to = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\r\nOutput: 10</code></pre>\r\n<p><strong>Explanation:</strong> One optimum path is to start at vertex 3 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 6 -> 4 -> 3 -> 9 -> 11. Collect coins from vertices 2 (coins at 0, 2 and 3), 6 (coins at 6 and 8), and 9 (coin at vertex 11).</p>\r\n\r\n<h3>Example 2:</h3>\r\n<pre><code class='language-text'>Input:\r\ntree_nodes = 10\r\ncoins = [1, 0, 1, 1, 1, 0, 0, 0, 1, 1]\r\ntree_from = [0, 0, 0, 0, 1, 6, 7, 8]\r\ntree_to = [1, 2, 3, 4, 5, 7, 8, 9]\r\nOutput: 4</code></pre>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>2 <= tree_nodes <= 10^5</code></li>\r\n    <li><code>coins[i] = 0</code> or <code>coins[i] = 1</code>, where <code>0 <= i < tree_nodes</code></li>\r\n    <li><code>0 <= tree_from[i] < tree_nodes</code> where <code>0 <= i < tree_nodes - 1</code></li>\r\n    <li><code>0 <= tree_to[i] < tree_nodes</code> where <code>0 <= i < tree_nodes - 1</code></li>\r\n</ul>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <numeric>\n\nclass Solution {\npublic:\n    int getMinPath(const std::vector<int>& coins, int tree_nodes, const std::vector<int>& tree_from, const std::vector<int>& tree_to) {\n        // Core logic goes here\n        return 0;\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    int tree_nodes;\n    std::cin >> tree_nodes;\n\n    std::vector<int> coins(tree_nodes);\n    for (int i = 0; i < tree_nodes; ++i) {\n        std::cin >> coins[i];\n    }\n\n    // A tree with n nodes has n-1 edges.\n    int num_edges = tree_nodes > 0 ? tree_nodes - 1 : 0;\n    std::vector<int> tree_from;\n    std::vector<int> tree_to;\n    if (num_edges > 0) {\n        tree_from.reserve(num_edges);\n        tree_to.reserve(num_edges);\n        for (int i = 0; i < num_edges; ++i) {\n            int u, v;\n            std::cin >> u >> v;\n            tree_from.push_back(u);\n            tree_to.push_back(v);\n        }\n    }\n\n    Solution sol;\n    int result = sol.getMinPath(coins, tree_nodes, tree_from, tree_to);\n\n    std::cout << result << std::endl;\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "Amazon_14oct",
        "company_id": 640
    }
]