[
    {
        "id": 1841,
        "title": "Code Question 1",
        "problem_statement": "<h1>Code Question 1</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>In a newly planned city, where a city is located at each integral coordinate in a 2-dimensional plane, there are n Amazon retailers. The i^th retailer residing in the city at the coordinate (x_i, y_i) and can deliver to all the cities covered by the rectangle having the 4 corner points (0, 0), (0, y_i), (x_i, y_i), (x_i, 0). We say that a point (a, b) is covered by a rectangle if it lies inside the rectangle or on its boundaries. Note that no 2 retailers reside in the same city.</p>\r\n<p>Given q requests of the form (a, b), determine the number of retailers who can deliver to the city at the coordinate (a, b).</p>\r\n<p>Complete the function <code>findNumRetailers</code> in the editor below.</p>\r\n<p>The function <code>findNumRetailers</code> has the following parameters:</p>\r\n<ul>\r\n    <li><code>int retailers[n][2]</code>: the retailers' coordinates</li>\r\n    <li><code>int requests[q][2]</code>: the coordinates of cities to deliver to</li>\r\n</ul>\r\n<p><strong>Returns:</strong></p>\r\n<ul>\r\n    <li><code>int array[q]</code>: the i^th element is the answer to the i^th query</li>\r\n</ul>\r\n<pre><code class='language-cpp'>vector<int> findNumRetailers(vector<vector<int>> retailers,\r\n                             vector<vector<int>> requests) {\r\n    // Function body to be completed\r\n}</code></pre>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input:\r\nretailers = [[1, 2], [2, 3], [1, 5]]\r\nrequests = [[1, 1], [1, 4]]\r\nOutput: [3, 1]</code></pre>\r\n<p><strong>Explanation:</strong> We have 3 retailers in the cities (1, 2), (2, 3), and (1, 5).</p>\r\n<ul>\r\n    <li>For the first request, the city at coordinate (1, 1):\r\n        <ul>\r\n            <li>Retailer (1,2) covers (0,0) to (1,2). (1,1) is covered.</li>\r\n            <li>Retailer (2,3) covers (0,0) to (2,3). (1,1) is covered.</li>\r\n            <li>Retailer (1,5) covers (0,0) to (1,5). (1,1) is covered.</li>\r\n        </ul>\r\n        All 3 retailers can deliver.\r\n    </li>\r\n    <li>For the second request, the city at coordinate (1, 4):\r\n        <ul>\r\n            <li>Retailer (1,2) covers (0,0) to (1,2). (1,4) is NOT covered (4 > 2).</li>\r\n            <li>Retailer (2,3) covers (0,0) to (2,3). (1,4) is NOT covered (4 > 3).</li>\r\n            <li>Retailer (1,5) covers (0,0) to (1,5). (1,4) is covered.</li>\r\n        </ul>\r\n        Only the third retailer can deliver.\r\n    </li>\r\n</ul>\r\n<p>Hence, the answer for this example will be [3, 1].</p>\r\n\r\n<h3>Example 2:</h3>\r\n<pre><code class='language-text'>Input:\r\nn = 3\r\nretailers = [[1, 4], [2, 4], [1, 5]]\r\nq = 2\r\nrequests = [[2, 6], [1, 4]]\r\nOutput:\r\n0\r\n3</code></pre>\r\n<p><strong>Explanation:</strong></p>\r\n<ul>\r\n    <li>For the first request, the city at coordinate (2, 6):\r\n        <ul>\r\n            <li>Retailer (1,4) covers (0,0) to (1,4). (2,6) is NOT covered (2 > 1).</li>\r\n            <li>Retailer (2,4) covers (0,0) to (2,4). (2,6) is NOT covered (6 > 4).</li>\r\n            <li>Retailer (1,5) covers (0,0) to (1,5). (2,6) is NOT covered (2 > 1).</li>\r\n        </ul>\r\n        None of the retailers can deliver.\r\n    </li>\r\n    <li>For the second request, the city at coordinate (1, 4):\r\n        <ul>\r\n            <li>Retailer (1,4) covers (0,0) to (1,4). (1,4) is covered.</li>\r\n            <li>Retailer (2,4) covers (0,0) to (2,4). (1,4) is covered.</li>\r\n            <li>Retailer (1,5) covers (0,0) to (1,5). (1,4) is covered.</li>\r\n        </ul>\r\n        All 3 retailers can deliver.\r\n    </li>\r\n</ul>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>1 <= n, q <= 7.5 * 10^4</code></li>\r\n    <li><code>1 <= retailers[i][0] <= 10^9</code></li>\r\n    <li><code>1 <= retailers[i][1] <= 10^9</code></li>\r\n    <li><code>0 <= requests[i][0] <= 10^9</code></li>\r\n    <li><code>0 <= requests[i][1] <= 10^9</code></li>\r\n    <li>No two retailers share the same coordinates.</li>\r\n</ul>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <vector>\n#include <string>\n\nclass Solution {\npublic:\n    /**\n     * @param retailers A 2D vector where retailers[i] = {x_i, y_i} are the coordinates of the i-th retailer.\n     * @param requests A 2D vector where requests[i] = {a, b} are the coordinates of the i-th request.\n     * @return A vector of integers where the i-th element is the answer to the i-th query.\n     */\n    std::vector<int> findNumRetailers(const std::vector<std::vector<int>>& retailers, const std::vector<std::vector<int>>& requests) {\n        // Core logic to be implemented here\n        std::vector<int> result(requests.size(), 0);\n        return result;\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    int n;\n    std::cin >> n;\n    std::vector<std::vector<int>> retailers(n, std::vector<int>(2));\n    for (int i = 0; i < n; ++i) {\n        std::cin >> retailers[i][0] >> retailers[i][1];\n    }\n\n    int q;\n    std::cin >> q;\n    std::vector<std::vector<int>> requests(q, std::vector<int>(2));\n    for (int i = 0; i < q; ++i) {\n        std::cin >> requests[i][0] >> requests[i][1];\n    }\n\n    Solution sol;\n    std::vector<int> result = sol.findNumRetailers(retailers, requests);\n\n    for (size_t i = 0; i < result.size(); ++i) {\n        std::cout << result[i] << (i == result.size() - 1 ? \"\" : \" \");\n    }\n    std::cout << std::endl;\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "Amazon_15oct",
        "company_id": 650
    },
    {
        "id": 1842,
        "title": "Total Packing Efficiency",
        "problem_statement": "<h1>Total Packing Efficiency</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>In the Amazon distribution center, there is a collection of <code>n</code> products, each with a distinct volume. The challenge is to evaluate the \"packing efficiency\" of the collection, aiming for proper utilization of space.</p>\r\n<p>More specifically, there is an array <code>volumes</code>, where",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <vector>\n#include <string>\n#include <numeric>\n#include <algorithm>\n\nclass Solution {\npublic:\n    /**\n     * @brief Calculates the total packing efficiency.\n     * \n     * @param n The number of products.\n     * @param volumes A vector of integers representing the volumes of each product.\n     * @return A long long representing the calculated packing efficiency.\n     */\n    long long solve(int n, const std::vector<int>& volumes) {\n        // Core logic to calculate total packing efficiency goes here.\n        return 0;\n    }\n};\n\nint main() {\n    // Fast I/O\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    int n;\n    std::cin >> n;\n\n    std::vector<int> volumes(n);\n    for (int i = 0; i < n; ++i) {\n        std::cin >> volumes[i];\n    }\n\n    Solution solution;\n    long long result = solution.solve(n, volumes);\n\n    std::cout << result << std::endl;\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "Amazon_15oct",
        "company_id": 650
    },
    {
        "id": 1843,
        "title": "Minimum Package Processing Operations",
        "problem_statement": "```html\r\n<h1>Minimum Package Processing Operations</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>An Amazon distribution specialist needs to process <code>n</code> packages from different distribution centers. The center of the <code>i</code>th package is represented by an array <code>centers[i]</code>. The specialist is allowed to perform one operation at a time. Each operation is described below:</p>\r\n<ol>\r\n    <li>If the queue has two or more packages, the specialist can choose two packages <code>x</code> and <code>y</code> from the queue if they are from different distribution centers, i.e. <code>centers[x] != centers[y]</code>, and process both of them.</li>\r\n    <li>If the queue has one or more packages, the specialist can choose one package <code>x</code> from the queue and process it.</li>\r\n</ol>\r\n<p><strong>Note:</strong> After processing a package it gets removed from the queue, and the rest of the packages which are currently not processed come together keeping the order the same as before.</p>\r\n<p>Given <code>n</code> packages and an array <code>centers</code>, find the minimum number of operations that the specialist has to perform to process all of the packages.</p>\r\n\r\n<h3>Function Description</h3>\r\n<p>Complete the function <code>findMinimumOperations</code> in the editor below.</p>\r\n<p>The function is expected to return an <code>INTEGER</code>.</p>\r\n<p>The function accepts <code>INTEGER_ARRAY centers</code> as parameter.</p>\r\n<p><code>findMinimumOperations</code> has the following parameter(s):</p>\r\n<ul>\r\n    <li><code>int centers_count</code>: the number of packages.</li>\r\n    <li><code>int* centers</code>: the distribution center of each package.</li>\r\n</ul>\r\n<p><strong>Returns:</strong></p>\r\n<ul>\r\n    <li><code>int</code>: the minimum number of operations that the specialist has to perform to process all of the packages.</li>\r\n</ul>\r\n<p>The function signature is:</p>\r\n<pre><code class='language-c'>int findMinimumOperations(int centers_count, int* centers) {\r\n    // Function body\r\n}\r\n</code></pre>\r\n\r\n<h2>Examples</h2>\r\n\r\n<h3>Example 1:</h3>\r\n<p><strong>Input:</strong> <code>n = 5</code>, <code>centers = [3, 7, 5, 6, 6]</code></p>\r\n<p><strong>Output:</strong> <code>3</code></p>\r\n<p><strong>Explanation:</strong> The following table shows one possible sequence of operations to process all packages:</p>\r\n<pre><code class='language-text'>Operation | x | y | centers\r\n----------|---|---|--------------------\r\n1.        | 1 | 5 | [7, 6, 6]\r\n2.        | 1 | 3 | [6]\r\n3.        | 1 | - | []\r\n</code></pre>\r\n<p>After 3 operations, all packages are processed.</p>\r\n\r\n<h3>Example 2 (Sample Case 0):</h3>\r\n<p><strong>Input:</strong> <code>n = 4</code>, <code>centers = [1, 3, 1, 2]</code></p>\r\n<p><strong>Output:</strong> <code>2</code></p>\r\n<p><strong>Explanation:</strong> The following table shows one possible sequence of operations to process all packages:</p>\r\n<pre><code class='language-text'>Operation | x | y | centers\r\n----------|---|---|--------------------\r\n1.        | 1 | 4 | [3, 1]\r\n2.        | 1 | 2 | []\r\n</code></pre>\r\n<p>Hence, the specialist needs to perform 2 operations to process all of the packages.</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>1 &le; n &le; 10<sup>5</sup></code></li>\r\n    <li><code>1 &le; centers[i] &le; 10<sup>9</sup></code></li>\r\n</ul>\r\n```",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <map>\n\nclass Solution {\npublic:\n    /**\n     * @brief Finds the minimum number of operations to process all packages.\n     * \n     * @param centers A vector of integers representing the distribution center of each package.\n     * @return An integer representing the minimum number of operations.\n     */\n    int findMinimumOperations(const std::vector<int>& centers) {\n        // Core logic to be implemented here.\n        return 0;\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    int n;\n    std::cin >> n;\n\n    std::vector<int> centers(n);\n    for (int i = 0; i < n; ++i) {\n        std::cin >> centers[i];\n    }\n\n    Solution sol;\n    int result = sol.findMinimumOperations(centers);\n\n    std::cout << result << std::endl;\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "Amazon_15oct",
        "company_id": 650
    },
    {
        "id": 1844,
        "title": "Maximum Total DataFlow",
        "problem_statement": "<h1>Maximum Total DataFlow</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>As an engineer in Amazon's Data Infrastructure Team, you are tasked with optimizing how information flows through its network of processing nodes.</p>\r\n<p>You are given <code>n</code> processing nodes, and the bandwidth capability of each node is given in an integer array named <code>bandwidth</code>.</p>\r\n<p>There are <code>streamCount</code> data channels that need to be connected to two processing nodes, one as the main connection and the other as the secondary. Each data channel must utilize a unique pair of nodes for its connections.</p>\r\n<p>The <code>dataFlow</code> for each data channel is defined as the sum of the bandwidth of its main and secondary nodes.</p>\r\n<p>Given an integer array <code>bandwidth</code> and an integer <code>streamCount</code>, find the maximum total <code>dataFlow</code> that can be achieved by optimally selecting unique pair of connections for each data channel.</p>\r\n<p><strong>Note:</strong> A pair of nodes <code>(x,y)</code> is said to be unique if no other channel has selected the same pair. However, the pairs <code>(y, x)</code> and <code>(x, y)</code> are treated as different connections. It is also possible to select the same node for main and secondary connections, which means that <code>(x,x)</code> is a valid pair for the connection.</p>\r\n\r\n<p>Complete the function <code>determineMaxDataFlow</code> in the editor below.</p>\r\n<p>The function <code>determineMaxDataFlow</code> has the following parameters:</p>\r\n<ul>\r\n    <li><code>int bandwidth[n]</code>: array of bandwidth capability provided by each processing node.</li>\r\n    <li><code>int streamCount</code>: the number of data channels that needs to be connected.</li>\r\n</ul>\r\n<p>The function is expected to return a <code>long</code> integer.</p>\r\n<p><strong>Returns:</strong></p>\r\n<ul>\r\n    <li><code>long</code>: the maximum total dataFlow from the unique connections of node pairs.</li>\r\n</ul>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input:\r\nbandwidth = [6, 4, 7]\r\nstreamCount = 4\r\nOutput: 52</code></pre>\r\n<p><strong>Explanation:</strong> The data channels can select their connections among the following 9 possible node pairs (assuming 1-based indexing of bandwidth array): [1, 1], [1, 2], [1, 3], [2, 1], [2, 2], [2, 3], [3, 1], [3, 2], [3, 3]. However, each data channel must select a unique pair of nodes.</p>\r\n<p>To achieve the maximum total dataFlow, the data channels can optimally choose the pairs [3, 3], [3, 2], [3, 1], [1, 1] to obtain the maximum sum of dataFlow = (7 + 7) + (7 + 4) + (7 + 6) + (6 + 6) = 52.</p>\r\n\r\n<h3>Example 2:</h3>\r\n<pre><code class='language-text'>Input:\r\nbandwidth = [5, 4, 8, 4, 7]\r\nstreamCount = 6\r\nOutput: 86</code></pre>\r\n<p><strong>Explanation:</strong> The six pairs of processing nodes with the highest sum of dataFlow are: [3, 3], [5, 5], [3, 5], [5, 3], [5, 1], [1, 3]. (Assuming 1-based indexing)</p>\r\n<p>Thus total dataFlow will be calculated as: 16 (for [3, 3]) + 15 (for [5, 5]) + 15 (for [3, 5]) + 14 (for [5, 3]) + 13 (for [5, 1]) + 13 (for [1, 3]) = 86. Therefore, the total dataFlow = 86. Hence return 86 as answer.</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>1 &lt;= n &lt;= 2 * 10^5</code></li>\r\n    <li><code>1 &lt;= bandwidth[i] &lt;= 2 * 10^5</code></li>\r\n    <li><code>1 &lt;= streamCount &lt;= min(10^9, n^2)</code></li>\r\n</ul>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <numeric>\n\nclass Solution {\npublic:\n    /**\n     * @param bandwidth A vector of integers representing the bandwidth of each processing node.\n     * @param streamCount The number of data channels to be connected.\n     * @return A long long representing the maximum total dataFlow.\n     */\n    long long determineMaxDataFlow(const std::vector<int>& bandwidth, int streamCount) {\n        // Core logic to find the maximum total dataFlow goes here.\n        return 0;\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    int n;\n    // Reading the size of the bandwidth array.\n    // The problem statement implies 'n' is given, but doesn't specify how.\n    // A common format is to read the size first.\n    // Let's assume the first line of input is the number of nodes 'n'.\n    // If the input format is different, this part needs to be adjusted.\n    // For example, if it's from a function call in a provided main,\n    // this manual reading part would be replaced.\n    // Based on the function signature `int bandwidth[n]`, n must be known.\n    // Let's assume n is read from stdin.\n    std::cin >> n;\n\n    std::vector<int> bandwidth(n);\n    for (int i = 0; i < n; ++i) {\n        std::cin >> bandwidth[i];\n    }\n\n    int streamCount;\n    std::cin >> streamCount;\n\n    Solution sol;\n    long long result = sol.determineMaxDataFlow(bandwidth, streamCount);\n\n    std::cout << result << std::endl;\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "Amazon_15oct",
        "company_id": 650
    }
]