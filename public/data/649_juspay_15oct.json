[
    {
        "id": 1837,
        "title": "Water Pipeline Cost Management",
        "problem_statement": "<h1>Water Pipeline Cost Management</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p><strong>Background:</strong> A water supply company has constructed a network of pipelines to distribute water from a central reservoir to all connected towns. The network is organized in a balanced tree structure, with the reservoir as the root. Each pipeline has a maintenance cost based on its length and condition.</p>\r\n<p><strong>Objective:</strong> You need to manage this pipeline network by calculating the water transport cost between towns and updating pipeline maintenance costs as needed.</p>\r\n\r\n<p><strong>Functionality Requirements:</strong></p>\r\n<p>1. <strong>Transport Cost Query:</strong> Calculate the total maintenance cost for transporting water between any two towns.</p>\r\n<p>2. <strong>Cost Update Query:</strong> Adjust the maintenance cost for any specific pipeline between towns.</p>\r\n\r\n<p><strong>Input Format:</strong></p>\r\n<ul>\r\n    <li><strong>Network Configuration:</strong> The input contains 3 integers, N (the number of towns), R (the root town representing the reservoir), and M (where M = N-1).</li>\r\n    <li>The next N-1 lines each contain three integers I, J, K, where I and J are two connected towns and K is the maintenance cost of the pipeline.</li>\r\n    <li><strong>Queries:</strong> An integer Q indicates the number of queries.</li>\r\n    <li>Each of the next Q lines describes a query, either:\r\n        <ul>\r\n            <li><code>1 A B</code> to calculate the total maintenance cost between towns A and B.</li>\r\n            <li><code>2 I J K</code> to update the maintenance cost for the pipeline between towns I and J to K.</li>\r\n        </ul>\r\n    </li>\r\n</ul>\r\n\r\n<p><strong>Output Format:</strong></p>\r\n<p>Sum of result of each transport cost query, i.e., the sum of the total cost between the specified towns.</p>\r\n\r\n<p>Complete the <code>solve</code> function in the editor below. It has the following parameter(s):</p>\r\n<ul>\r\n    <li><code>N</code> (INTEGER): number of towns</li>\r\n    <li><code>R</code> (INTEGER): root town representing the reservoir</li>\r\n    <li><code>M</code> (INTEGER): N-1 (number of edges)</li>\r\n    <li><code>edges</code> (INTEGER 2D ARRAY): N-1 rows, each containing three integers I, J, K, where I and J are two connected towns and K is the maintenance cost of the pipeline.</li>\r\n    <li><code>Q</code> (INTEGER): number of queries</li>\r\n    <li><code>queries</code> (INTEGER 2D ARRAY): Q rows, each describing a query. A query is either <code>1 A B</code> to calculate the total maintenance cost between towns A and B, or <code>2 I J K</code> to update the maintenance cost for the pipeline between towns I and J to K.</li>\r\n</ul>\r\n\r\n<p><strong>Return:</strong> The function must return an INTEGER denoting the sum of results of each transport cost query, i.e., the sum of the total cost between the specified towns.</p>\r\n\r\n<h2>Examples</h2>\r\n\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input:\r\n2\r\n1\r\n1\r\n1 2 5\r\n3\r\n1 2 1 0\r\n2 1 2 2\r\n1 1 2 0\r\nOutput: 7</code></pre>\r\n<p><strong>Explanation:</strong> No specific explanation provided.</p>\r\n\r\n<h3>Example 2:</h3>\r\n<pre><code class='language-text'>Input:\r\n3\r\n3\r\n2\r\n1 2 1\r\n2 3 1\r\n3\r\n1 1 3 0\r\n2 2 3 5\r\n1 1 3 0\r\nOutput: 8</code></pre>\r\n<p><strong>Explanation:</strong> Initially 1 to 3 had cost 1+1=2. Later, cost = 6. So, 6+2=8.</p>\r\n\r\n<h3>Example 3:</h3>\r\n<pre><code class='language-text'>Input:\r\n5\r\n1\r\n4\r\n1 2 3\r\n1 3 2\r\n2 4 4\r\n2 5 1\r\n4\r\n1 4 5 0\r\n2 1 2 10\r\n1 1 4 0\r\n1 1 3 0\r\nOutput: 21</code></pre>\r\n<p><strong>Explanation:</strong> No specific explanation provided.</p>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <vector>\n#include <string>\n#include <numeric>\n#include <algorithm>\n\nclass Solution {\npublic:\n    long long solve(int N, int R, int M, std::vector<std::vector<int>>& edges, int Q, std::vector<std::vector<int>>& queries) {\n        // TODO: Implement the solution logic here\n        return 0;\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    int N, R, M;\n    std::cin >> N >> R >> M;\n\n    std::vector<std::vector<int>> edges(M, std::vector<int>(3));\n    for (int i = 0; i < M; ++i) {\n        std::cin >> edges[i][0] >> edges[i][1] >> edges[i][2];\n    }\n\n    int Q;\n    std::cin >> Q;\n\n    std::vector<std::vector<int>> queries(Q);\n    for (int i = 0; i < Q; ++i) {\n        int type;\n        std::cin >> type;\n        if (type == 1) {\n            queries[i].resize(3);\n            queries[i][0] = type;\n            std::cin >> queries[i][1] >> queries[i][2];\n        } else { // type == 2\n            queries[i].resize(4);\n            queries[i][0] = type;\n            std::cin >> queries[i][1] >> queries[i][2] >> queries[i][3];\n        }\n    }\n\n    Solution solution;\n    long long result = solution.solve(N, R, M, edges, Q, queries);\n\n    std::cout << result << std::endl;\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "juspay_15oct",
        "company_id": 649
    },
    {
        "id": 1838,
        "title": "Network Technician's Mission",
        "problem_statement": "<h1>Network Technician's Mission</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>In the city of Techville, a network technician named Sam is tasked with inspecting a newly established network of communication towers. The network is structured as a rooted tree with N towers, with the main control tower located at node 1. This control tower serves as the central hub for all communications.</p>\r\n<p>The network is built through various terrains, some of which are marked as hazardous zones. Each tower is either in a safe zone or a hazardous one. The outermost towers (the leaf nodes of the tree) need to be inspected by Sam, but he is cautious and wants to avoid paths that traversethrough too many consecutive hazardous zones.</p>\r\n<p>Your task is to help Sam count the number of outermost towers (leaf nodes) he can safely inspect, where the path from the main control tower to the leaf contains no more than M consecutive hazardous zones.</p>\r\n<p>It is guaranteed that the given set of edges forms a tree structure</p>\r\n\r\n<p>Complete the <code>safeViewPoints</code> function in the editor below. It has the following parameter(s):</p>\r\n<ul>\r\n    <li><strong>N</strong>: INTEGER - the number of nodes in the tree</li>\r\n    <li><strong>M</strong>: INTEGER - the maximum number of consecutive dangerous sections Sam is willing to traverse</li>\r\n    <li><strong>k</strong>: INTEGER - Always equals to N-1</li>\r\n    <li><strong>Arr1</strong>: INTEGER ARRAY - Array of N integers stating if tower in safe zone or not</li>\r\n    <li><strong>Arr2</strong>: INTEGER 2D ARRAY - 2D array of size N-1 with two values</li>\r\n</ul>\r\n<p>The function must return an <strong>INTEGER</strong> denoting the the number of viewpoints (leaf nodes) where the path from the main camp (node 1) contains at most M consecutive dangerous sections</p>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input:\r\n7\r\n1\r\n6\r\n1\r\n0\r\n1\r\n1\r\n0\r\n0\r\n0\r\n1 2\r\n1 3\r\n2 4\r\n2 5\r\n3 6\r\n3 7\r\nOutput: 2</code></pre>\r\n<p><strong>Explanation:</strong> The number of outermost towers (leaf nodes) he can safely inspect.</p>\r\n\r\n<h3>Example 2:</h3>\r\n<pre><code class='language-text'>Input:\r\n5\r\n2\r\n4\r\n1\r\n1\r\n0\r\n1\r\n1\r\n1 2\r\n2 3\r\n3 4\r\n4 5\r\nOutput: 1</code></pre>\r\n<p><strong>Explanation:</strong> The number of outermost towers (leaf nodes) he can safely inspect</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>2 &le; N &le; 10^5</code></li>\r\n    <li><code>1 &le; M &le; N</code></li>\r\n    <li><code>N-1 &le; k &le; N-1</code></li>\r\n    <li><code>1 &le; Arr1[i] &le; 10^5</code></li>\r\n    <li><code>1 &le; Arr2[i][j] &le; 10^5</code></li>\r\n</ul>\r\n\r\n<h2>Input Format for Debugging</h2>\r\n<ul>\r\n    <li>The first line contains an integer, N, denoting the number of elements in Arr1.</li>\r\n    <li>The next line contains an integer, M.</li>\r\n    <li>The next line contains an integer, k, denoting the number of rows in Arr2.</li>\r\n    <li>Each line i of the N subsequent lines (where 0 &le; i &lt; N) contains an integer describing \"Arr1[i]\".</li>\r\n    <li>Each line i of the k subsequent lines (where 0 &le; i &lt; k) contains 2 space separated integers each describing the row Arr2[i].</li>\r\n</ul>",
        "google_doc_link": null,
        "solution_code": null,
        "pregiven_code": "p\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nclass Solution {\npublic:\n    /**\n     * @param N The number of nodes in the tree.\n     * @param M The maximum number of consecutive dangerous sections.\n     * @param k Always equals to N-1.\n     * @param Arr1 Array of N integers stating if a tower is in a safe zone (0) or not (1).\n     * @param Arr2 2D array of size N-1 representing the edges.\n     * @return The number of viewpoints (leaf nodes) that can be safely inspected.\n     */\n    int safeViewPoints(int N, int M, int k, const std::vector<int>& Arr1, const std::vector<std::vector<int>>& Arr2) {\n        // Core logic to be implemented here.\n        // 1. Build an adjacency list representation of the tree from Arr2.\n        // 2. Perform a Depth First Search (DFS) starting from the root (node 1).\n        // 3. In the DFS, keep track of the current count of consecutive hazardous nodes.\n        //    - If a node is hazardous (Arr1[node-1] == 1), increment the count.\n        //    - If a node is safe (Arr1[node-1] == 0), reset the count to 0.\n        // 4. If the consecutive count exceeds M, prune the search from that path.\n        // 5. If a leaf node is reached and the path is valid, increment a result counter.\n        // A leaf node is a node with degree 1 (except for the root if N > 1).\n        return 0; // Placeholder return\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    int N;\n    std::cin >> N;\n\n    int M;\n    std::cin >> M;\n\n    int k;\n    std::cin >> k;\n\n    std::vector<int> Arr1(N);\n    for (int i = 0; i < N; ++i) {\n        std::cin >> Arr1[i];\n    }\n\n    std::vector<std::vector<int>> Arr2(k, std::vector<int>(2));\n    for (int i = 0; i < k; ++i) {\n        std::cin >> Arr2[i][0] >> Arr2[i][1];\n    }\n\n    Solution sol;\n    int result = sol.safeViewPoints(N, M, k, Arr1, Arr2);\n\n    std::cout << result << std::endl;\n\n    return 0;\n}",
        "input_test_case": null,
        "output_test_case": null,
        "company_name": "juspay_15oct",
        "company_id": 649
    }
]