[
    {
        "id": 1380,
        "title": "FindMinIncrease",
        "problem_statement": "<h1>FindMinIncrease</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>A team needs to optimize context switching between processes. There are `n` segments, each assigned a thread. The maximum stack size of a thread in the `j<sup>th</sup>` segment is given by `threadSize[j]` for all `0 <= j < n`.</p>\r\n<p>For any high-priority process, the stack size of some segments must be increased. A segment `i` is considered special if `threadSize[i-1] < threadSize[i] > threadSize[i+1]`. The segments at each end (first and last) cannot be special.</p>\r\n<p>The goal is to modify the stack sizes to maximize the number of special segments. To achieve this:</p>\r\n<ul>\r\n    <li>Select an index `x` and an integer `v`, where `0 <= x < n` and `v <= 10^9`.</li>\r\n    <li>Increase the stack size of the `x<sup>th</sup>` segment from `threadSize[x]` to `threadSize[x] + v`.</li>\r\n</ul>\r\n<p>Determine the minimum total increase in the stack size required to maximize the number of special segments.</p>\r\n\r\n<h2>Function Description</h2>\r\n<p>Complete the function `findMinIncrease` in the editor with the following parameters:</p>\r\n<ul>\r\n    <li>`int threadSize[n]`: the stack sizes for the threads to be assigned to the segments.</li>\r\n</ul>\r\n<p><strong>Returns:</strong></p>\r\n<ul>\r\n    <li>`long`: the minimum required total increase in the stack sizes.</li>\r\n</ul>\r\n<pre><code class='language-cpp'>long findMinIncrease(vector&lt;int&gt; threadSize) {\r\n    // Complete the 'findMinIncrease' function below.\r\n    // The function is expected to return a LONG_INTEGER.\r\n    // The function accepts INTEGER_ARRAY threadSize as parameter.\r\n}</code></pre>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input: n = 6, threadSize = [3, 1, 4, 5, 5, 2]\r\nOutput: 3</code></pre>\r\n<p><strong>Explanation:</strong> A maximum of two special segments can occur in this configuration. It is optimal to add 2 and 1 to the third and fifth segments, respectively. The final stack sizes of the segments are [3, 1, <strong>6</strong>, 5, <strong>6</strong>, 2]. With these changes, there are two special segments. This is the minimum possible increase needed. The answer is 2 + 1 = 3.</p>\r\n\r\n<h3>Example 2:</h3>\r\n<pre><code class='language-text'>Input: n = 5, threadSize = [3, 1, 2, 2, 3]\r\nOutput: 4</code></pre>\r\n<p><strong>Explanation:</strong> Since the segments at the end cannot be special, both the 2<sup>nd</sup> and 4<sup>th</sup> segments must be increased by 2. The final stack sizes are [3, 1, <strong>4</strong>, 2, <strong>5</strong>]. Only two special segments can occur in this configuration. This shows the minimum changes required.</p>\r\n\r\n<h3>Example 3:</h3>\r\n<pre><code class='language-text'>Input: n = 4, threadSize = [2, 3, 4, 5]\r\nOutput: 2</code></pre>\r\n<p><strong>Explanation:</strong> It is optimal to add 2 to either the third or the second segment to make them special. The final stack sizes are [2, 3, <strong>6</strong>, 5] or [2, <strong>5</strong>, 4, 5]. Both configurations satisfy all the conditions with a maximum of 1 possible special segment. Hence, the minimum total increase in the stack sizes = 2.</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li>`3 <= n <= 2 * 10^5`</li>\r\n    <li>`1 <= threadSize[i] <= 10^9`</li>\r\n</ul>",
        "google_doc_link": null,
        "solution_code": null,
        "company_name": "UIpath_5sep",
        "company_id": 480
    },
    {
        "id": 1381,
        "title": "Maximize Profit with Minimum K Losses",
        "problem_statement": "<h1>Maximize Profit with Minimum K Losses</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>You want to maximize the profit from a trading portfolio while taking a minimum number of losses.</p>\r\n<p><strong>Given:</strong></p>\r\n<ul>\r\n    <li>An array <code>pfl</code> of <code>n</code> integers representing monthly profit/losses (negative values are losses).</li>\r\n    <li>An integer <code>k</code> representing the minimum number of losses that must be taken.</li>\r\n</ul>\r\n<p><strong>The traders can:</strong></p>\r\n<ul>\r\n    <li>Add any positive <code>pfl[i]</code> to their profit.</li>\r\n    <li>For negative <code>pfl[i]</code>, either subtract it or skip it.</li>\r\n    <li>The net profit must always be non-negative.</li>\r\n</ul>\r\n<p>Find the maximum total profit that can be earned after taking at least <code>k</code> losses. Return <code>-1</code> if it is not possible to take <code>k</code> losses.</p>\r\n\r\n<p><strong>Function Description:</strong><br>\r\nComplete the function <code>getmaxProfit</code> in the editor below with the following parameters:</p>\r\n<ul>\r\n    <li><code>int[] pfl</code>: the profit/loss predicted</li>\r\n    <li><code>int k</code>: the minimum number of losses that must be taken</li>\r\n</ul>\r\n<p><strong>Returns:</strong></p>\r\n<ul>\r\n    <li><code>long</code>: the maximum profit after taking at least <code>k</code> losses or <code>-1</code></li>\r\n</ul>\r\n\r\n<pre><code class='language-javascript'>long getmaxProfit(vector<int> pfl, int k) {\r\n    // Complete the 'getmaxProfit' function below.\r\n    // The function is expected to return a LONG_INTEGER.\r\n    // The function accepts the following parameters:\r\n    //  1. INTEGER_ARRAY pfl\r\n    //  2. INTEGER k\r\n}</code></pre>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input:\r\nn = 5\r\npfl = [4, -3, 6, -2, 1]\r\nk = 2\r\nOutput: 6</code></pre>\r\n<p><strong>Explanation:</strong> The optimal strategy is:</p>\r\n<ul>\r\n    <li>Take the profit: <code>4 + 6 + 1 = 11</code></li>\r\n    <li>Take the losses: <code>-3</code> and <code>-2</code> (2 losses)</li>\r\n    <li>Net profit: <code>11 - (3 + 2) = 6</code></li>\r\n</ul>\r\n<p>This is the maximum possible profit while taking at least 2 losses.</p>\r\n\r\n<h3>Example 2 (Sample Case 0):</h3>\r\n<pre><code class='language-text'>Input:\r\nn = 6\r\npfl = [10, -13, 9, -2, -2, 1]\r\nk = 3\r\nOutput: -1</code></pre>\r\n<p><strong>Explanation:</strong> There is no way to take 3 losses. The profit will be negative if we take -10 and there are only two other losses available.</p>\r\n\r\n<h3>Example 3 (Sample Case 1):</h3>\r\n<pre><code class='language-text'>Input:\r\nn = 4\r\npfl = [13, 5, -2, -1]\r\nk = 1\r\nOutput: 14</code></pre>\r\n<p><strong>Explanation:</strong> The optimal strategy is to take the profit of 13 and the loss of -1.</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>1 <= n <= 2 * 10^5</code></li>\r\n    <li><code>1 <= k <= n</code></li>\r\n    <li><code>-10^9 <= pfl[i] <= 10^9</code></li>\r\n</ul>",
        "google_doc_link": null,
        "solution_code": null,
        "company_name": "UIpath_5sep",
        "company_id": 480
    },
    {
        "id": 1382,
        "title": "Count Good Arrays",
        "problem_statement": "<h1>Count Good Arrays</h1>\r\n\r\n<h2>Problem Description</h2>\r\n<p>Numbers must be assigned to classmates represented in an array. An arrangement is considered good if the absolute difference between any two adjacent students is at most 1.</p>\r\n<p>The input array contains some missing elements marked as 0. Your task is to find the total number of ways to replace these missing elements with arbitrary integers to form a good array. Since the answer can be large, return it modulo (10<sup>9</sup> + 7).</p>\r\n<p>For example, if <code>arr = [0, 0]</code>, there are 9 ways to replace the zeros to make the array good:</p>\r\n<ul>\r\n    <li>[0,0]</li>\r\n    <li>[0,1]</li>\r\n    <li>[1,0]</li>\r\n    <li>[1,1]</li>\r\n    <li>[1,2]</li>\r\n    <li>[2,1]</li>\r\n    <li>[2,2]</li>\r\n    <li>[3,2]</li>\r\n    <li>[2,3]</li>\r\n</ul>\r\n<p>In each of these arrays, the absolute difference between consecutive elements is at most 1.</p>\r\n<p>Complete the function <code>countGoodArrays</code> in the editor with the following parameters:</p>\r\n<ul>\r\n    <li><code>int arr[n]</code>: an array of integers</li>\r\n</ul>\r\n<p><strong>Returns:</strong> <code>int</code>: the number of ways to replace missing elements to form a good array, modulo (10<sup>9</sup> + 7)</p>\r\n\r\n<pre><code class='language-cpp'>int countGoodArrays(std::vector<int> arr) {\r\n    // Function implementation\r\n}</code></pre>\r\n\r\n<h2>Examples</h2>\r\n<h3>Example 1:</h3>\r\n<pre><code class='language-text'>Input: n = 4, arr = [0, 1, 0, 0]\r\nOutput: 9</code></pre>\r\n<p><strong>Explanation:</strong> The 9 good arrays are:</p>\r\n<ul>\r\n    <li>[0,1,0,1]</li>\r\n    <li>[0,1,1,0]</li>\r\n    <li>[0,1,1,1]</li>\r\n    <li>[0,1,1,2]</li>\r\n    <li>[0,1,2,1]</li>\r\n    <li>[0,1,2,2]</li>\r\n    <li>[0,1,2,3]</li>\r\n    <li>[1,1,0,1]</li>\r\n    <li>[1,1,1,0]</li>\r\n</ul>\r\n<p>In each of these arrays, the absolute difference between each pair of consecutive elements is less than or equal to 1.</p>\r\n\r\n<h3>Example 2:</h3>\r\n<pre><code class='language-text'>Input: n = 4, arr = [1, 0, 0, 2]\r\nOutput: 6</code></pre>\r\n<p><strong>Explanation:</strong> The 6 good arrays are:</p>\r\n<ul>\r\n    <li>[1,1,1,2]</li>\r\n    <li>[1,1,2,2]</li>\r\n    <li>[1,2,1,2]</li>\r\n    <li>[1,2,2,2]</li>\r\n    <li>[1,0,1,2]</li>\r\n    <li>[1,0,0,2]</li>\r\n</ul>\r\n<p>In each of these arrays, the absolute difference between each pair of consecutive elements is less than or equal to 1.</p>\r\n\r\n<h2>Constraints</h2>\r\n<ul>\r\n    <li><code>1 <= n <= 500</code></li>\r\n    <li><code>0 <= arr[i] <= 10<sup>9</sup></code></li>\r\n    <li>There is at least one element in <code>arr</code> that is not equal to 0.</li>\r\n</ul>",
        "google_doc_link": null,
        "solution_code": null,
        "company_name": "UIpath_5sep",
        "company_id": 480
    }
]